---
lang: zh-CN
title: 软件工程
description: 软件工程知识点和笔试题
---



# 软件工程知识点和笔试题

## 知识点

### 第一章：软件工程概述

#### 1.Wasserman 规范

Wasserman 规范（Wasserman's Discipline）作为软件工程领域的核心实践框架，贯穿软件开发的‌**需求分析、设计、实现、测试、维护**‌等全生命周期，其核心是通过标准化方法提升开发效率和软件质量。以下是其在各阶段的具体体现及作用：

------

##### 1.1**需求与设计阶段**‌

1. ‌**用户界面原型化**‌
    通过快速构建用户界面原型，明确功能需求并验证交互逻辑，减少需求偏差风险。例如，利用原型工具（如Axure）实现需求可视化，降低沟通成本。
2. ‌**软件体系结构设计**‌
    强调模块化与分层设计，确保系统可扩展性和可维护性。例如，采用MVC架构分离业务逻辑与界面逻辑。
3. ‌**软件复用**‌
    在需求分析阶段优先识别可复用的组件或模式（如微服务架构中的通用模块），降低开发成本并提升一致性。

------

##### 1.2**开发与测试阶段**‌

1. ‌**过程管理**‌

   通过标准化开发流程（如瀑布模型或V模型）控制进度和质量，明确各阶段输出物（如需求文档、设计文档、测试用例等）‌。

   - 例如，V模型要求测试用例设计在需求阶段同步完成，确保测试覆盖度‌。

2. ‌**度量与工具支持**‌
    对代码质量、测试覆盖率等指标进行量化评估，结合工具（如SonarQube、JIRA）实现自动化监控，确保代码符合规范。

3. ‌**迭代与反馈**‌
    采用敏捷开发中的持续集成（CI）和持续交付（CD），快速响应用户需求变更，并通过测试驱动开发（TDD）保障代码健壮性。

------

##### 1.3**维护与优化阶段**‌

1. ‌**配置管理**‌
    通过版本控制工具（如Git）管理代码变更历史，结合分支策略（如GitFlow）保障多人协作的稳定性‌。
2. ‌**风险管理**‌
    定期评估技术债务和潜在缺陷，例如通过代码审查和静态分析工具（如Checkstyle）识别高风险模块‌。
3. ‌**用户反馈闭环**‌
    收集用户使用数据（如日志分析、用户调研），持续优化功能并修复问题，形成迭代闭环‌。

------

##### 1.4**核心实践总结**‌

Wasserman 规范的八大核心实践（如抽象、建模、复用、度量、原型化、体系结构、过程、工具与集成等）覆盖了从需求到维护的全流程‌：

- ‌**标准化**‌：统一开发流程和文档模板（如需求规格说明书、测试报告）。
- ‌**协作化**‌：通过团队分工（如开发、测试、运维角色分离）提升效率‌。
- ‌**工具化**‌：依赖自动化工具（如Jenkins、Selenium）减少人为错误‌。



**人机界面与硬件代际的关联**‌

1. ‌**电子管时代（第一代）**‌：界面以机械开关、穿孔卡片为主，交互极为原始‌。
2. ‌**晶体管时代（第二代）**‌：引入命令行界面（CLI），支持文本输入与基础交互‌。
3. ‌**集成电路时代（第三代）**‌：图形用户界面（GUI）逐步普及（如鼠标操作、窗口系统）。
4. ‌**大规模集成电路时代（第四代）**‌：触控、语音、手势等自然交互技术成为主流，界面向智能化发展。



**软件的4个发展阶段**

软件的发展经历了‌4个发展阶段：

**阶段划分及特点**

1. ‌**第一阶段（20世纪50年代至50年代末）**‌
   - 称为“程序设计的原始时期”，以个体手工编程为主，无系统化开发方法，应用领域集中于科学计算与工程计算‌。
2. ‌**第二阶段（50年代末至60年代末）**‌
   - 称为“基本软件期”，团队协作出现，高级程序语言（如FORTRAN、COBOL）逐步应用，操作系统和文档规范开始形成。
3. ‌**第三阶段（60年代末至70年代末）**‌
   - 称为“软件工程阶段”，结构化开发方法普及，工程化管理成为核心，但软件开发成本急剧上升，引发“软件危机”‌。
4. ‌**第四阶段（80年代至今）**‌
   - 现代软件工程阶段，以敏捷开发、DevOps、开源生态为标志，强调快速迭代、协作与自动化工具链。





#### 2.软件工程概述

##### **2.1软件工程（SE）的定义、方法、作用：**

- SE的定义：软件工程就是用系统化、工程化的方法解决软件开发问题。系统化、工程化方法结果就是“软件开发规范”，规范里面体现软件开发的固有规律。

- SE 的方法：面向对象模式，结构化模式，基于过程的模式等。
- SE 的作用：付出较低的开发成本，达到要求的软件功能，取得较好的软件性能，开发的软件易于移植，需要较低的维护费用，能按时完成开发工作，及时交付使用。



#### 3.软件发展中出现的问题

##### 3.1零缺陷软件无法出现

 由于市场压力促使软件开发人员快速交付产品，零故障软件无法实现。

##### 3.2故障，错误和失效各自的含义（含举例）及它们之间的联系：

- 错误(error)：是在软件开发过程中人为产生的错误（需求说明中的错误，代码中的错误）。
- 故障(fault)：软件功能实现过程中产生的问题，是错误导致的结果，是软件中一个错误的表现（一个错误可能产生多个故障，静态存在）。
- 失效(failure)：系统违背了它应有的行为（在系统交付前或交付后被发现，动态存在）。

联系：

- 人为原因导致程序错误；该错误编译到系统中导致系统故障；用户使用该系统时，因故障导致失效。
- 故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图，从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。 

##### 3.3关于 bug

- 改正(fixing)有时比重写(rewriting)整个系统要困难。
- 错误修正的越晚，付出的代价越大。
- 复审(review)十分重要，是正式团队的行为规范；自己检查能只能找出开发阶段故障的 1/5，同行评审能够揭示其余 4/5 的故障。


#### 4.软件工程中的核心方法

##### 4.1问题分析方法

- 分析(analysis)：将问题分解成可以理解并能够处理的若干小部分，确定问题的本质含义。

- 合成(synthesis)：将每个小问题的解决方案组合成一个大的结构，合成解决方案。
- 工具(tool)：用更好的方式完成某事情的设备或自动化系统。
- 过程(produce)：把工具和技术结合起来，共同生产特定产品。
- 范型(paradigm)：构造软件的特定方法、途径或哲学（如面向对象开发的模式、结构化开发的模式、基于过程开发的模式、某种订制开发的模式）。



##### 4.2系统化方法

把软件看作一个系统，系统由四大要素组成：实体、活动、关系、系统边界的集合。

(1) 活动和对象
       活动(activity)：活动是发生在系统中的某些事情，通常描述为由某个触发器引发的事件，活动通过改变某一特性把一个事物转变成另一个事物。
       对象(object)或实体(entity)：活动中涉及的元素称为对象或实体（如记录数据的对象）。
(2) 关系和系统边界
       关系(relationship)：对实体和活动间数据项及动作相互关系的描述。

​        系统边界(system boundary)：用于描述系统中包含什么，不包含什么。

活动、关系是核心。 



##### 4.3工程化方法

以工程化方法进行软件开发———将软件开发过程工程化。以固定的阶段、流程进行软件开发。

（1）需求分析：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格说明书》】与复审（所有人）。

（2）系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软件】与复审（开发者与客户）。
（3）程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。

（4）程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。
（5）单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。

（6）集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。
（7）系统测试：按《SRS》对系统总体功能进行测试与复审（开发者与客户）。

（8）系统提交：交付产品【用户手册和操作手册】与复审。
（9）系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团队）。
注：圆括号中的为测试人员，方括号为生成的文档。



#### 5.软件工程的未来

（关键点）使现代软件工程实践发生变化的七个关键因素(by Wasserman)
（1）商用产品投入市场时间的紧迫性
（2）计算技术在经济中的转变：更低的硬件成本，更高的开发、维护成本
（3）功能强大的桌面计算的可用性
（4）广泛的局域网和广域网
（5）面向对象技术的采用及其有效性
（6）使用窗口、图标、菜单和指示器的图形用户界面
（7）软件开发瀑布模型的不可预测性

总结：时间、技术成本、互联网、面向对象技术、图形化用户界面、瀑布模型的缺点


### 第二章：软件过程（过程与生命周期建模）

#### 1 .过程与生命周期是什么

过程的定义：

​        1、一组有序的任务，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。
​        2、过程不仅仅是步骤，过程是步骤的集合，它将步骤组织起来使人们能够生产满足一系列目标和标准的产品。

生命周期的定义：

​       软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。

过程的意义：

​        （1）它强制活动具有一致性和一定的结构。
​        （2）过程结构允许我们分析、理解、控制和改进组成过程的活动，并以此来指导我们的活动。
​        （3）它使我们获取经验并把经验传授给他人。


#### 2.瀑布模型

线性的安排每一个阶段，将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段。一个开发阶段必须在另一个开发阶段开始之前完成。

![img](https://i-blog.csdnimg.cn/direct/5f889b9467564d09bda0c54513459da0.png)



##### 2.1瀑布模型的优点

（1）它的简单性使得开发人员很容易向不熟悉软件开发的客户作出解释。
（2）每一个过程活动都有与其相关联的里程碑和可交付产品，以便于项目经理评估项目进度。
（3）瀑布模型是最基础的模型，很多其他更复杂的模型实际上是在瀑布模型的基础上的润色，如加入反馈循环以及额外的活动。

1、简单，容易解释。
2、每一个过程都有里程碑产品，便于评估项目进度。
3、瀑布模型是很多其他模型的基础，有很好的泛化性，能与多个模型叠加。

##### 2.2瀑布模型的缺点 

（1）除了一些理解非常充分的问题之外，实际上软件是通过大量的迭代进行开发的。软件是一个创造的过程, 不是一个制造的过程。软件变动时, 该模型无法处理实际过程中的重复开发问题。
（2）文档转换有困难。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。

问题：
        1、软件开发需要多次的迭代过程去完成，瀑布模型难以迭代。
        2、文档转化很困难，文档整合困难。

#### 3.原型化的瀑布模型

（1）原型的概念
       一种部分开发的产品，用来让用户和开发者共同研究，提出意见，为最终产品定型。原型可以理解为小样，在某一阶段产品定型前先做一些小样，通过对各种样品的评价和分析，并最终为产品定型。
       原型化的瀑布模型如下图所示，在实现代码前的需求和设计阶段引进原型化的概念，在需求分析阶段，通过设计和分析原型以确保需求是一致、可行和符合实际的，避免在测试阶段付出巨大的代价进行修正；在设计阶段，原型化有助于开发人员评价可选的设计策略以及决定哪一种策略是最适合的。为了确保产品符合需要，在测试阶段要进行确认/核准（validate）和验证（verify）。

![img](https://i-blog.csdnimg.cn/direct/ec27169065004ab093c2c2a49f969245.png)



（2）区分确认和验证：
       确认：确保系统实现了所有需求。
       验证：确保每一项功能都是正确的。
       确认保证开发人员构造的是正确的产品，而验证检查实现的质量。

关键点：

​        1、原型化模型：分析设计阶段的产品，没有进行全面code，仅仅为了帮助大家分析。

​        2、测试阶段：通过确认来审核需求，用验证来审核系统功能吗，如果有问题会返回。


#### 4.V模型

> 通过前面对瀑布模型的研究，我们发现其存在问题：**过程难以回溯**
>
> **过程回溯发生在测试和设计阶段之间，因此V模型将测试和设计分离，增强模型的回溯性**

V 模型是瀑布模型的变种，它说明测试活动是如何与分析和设计相联系的。
       如下图所示，编码位于 V 型的顶点，分析和设计在左边，测试和维护在右边。测试的每个步骤都与分析和设计相对应，如果在验证和确认期间发现了问题，可以重新执行响应的步骤加以修正。验收测试对应需求分析，系统测试对应系统设计，单元测试和集成测试对应程序设计。
![img](https://i-blog.csdnimg.cn/direct/ab178d9d541e4c75a8268b9bb5c4e1b4.png)



> 这是一个非常漂亮的模型，将设计和测试之间的关系一一呈现出来。

> **V 模型与瀑布模型的区别：**
>      （1）V 模型使得隐藏在瀑布模型中的迭代和重做活动更加明确。
>
> ​    （2）瀑布模型关注文档和制品，V 模型关注活动和正确性。





#### 5.原型化模型

 之前在瀑布模型的优化中介绍了原型化的思想，**原型化并不依附于瀑布模型，原型化模型本身是有效的过程模型的基础**。因为它允许用户以独立的工程模型的方式, 每一阶段都基于原型的建立, 以快速构造系统, 逐步完成各阶段任务。

![img](https://i-blog.csdnimg.cn/direct/39c5c8fc1f964d6dbecdb766c52a63d6.png)



 如上图所示，原型化模型并不依赖于明确的需求或设计，在情况不明朗的情况下使用原型化模型，先根据简单的需求和设计构造系统的简单样品以理解或澄清问题，以确保开发人员、用户和客户对产品达成共识。也就是说，要根据对每一阶段样品的反响明确需求和设计的具体内容。原型化设计有助于开发人员和客户达成共识，减少了开发中的风险和不确定性。但是为达成共识可能会需要反复进行原型设计。

关键点：

​        1、原型化开发本身也不像一个具体的模型，它更像是一种思想，这个思想可以运用到过程模型中的每一个部分。

​        2、在该步骤（分析、设计、编码）不清晰时，可以使用原型化思想去帮助理解或澄清问题。


#### 6.阶段化开发模型

问题：商业环境不允许产品有长开发时间，但是较短开发时间难以有高质量且完整的产品。

想法：将产品开发分为几个阶段，后一阶段是前一阶段的补充。边开发边交付，从而为产品开发提供更多时间，用户体验也将更好。

   **定义：**系统被设计成部分提交, 每次用户只能得到部分功能, 而其他部分处于开发过程中。

   **循环周期：**从软件开发时整理需求文档到系统交付经过的时间。
   **为何要阶段化开发：**我们需要了解现在的商业环境不允许产品长时间拖延，所以我们要缩短循环周期，使用阶段化开发模型使系统能一部分的交付，从而在系统其余部分正在开发的同时，用户已经获得了一部分功能。

##### 6.1阶段化开发的特点

(1) 产品系统和开发系统
        因为一边开发一边交付，所以有两个系统在并行运行。
        运行系统/产品系统：当前正在被客户和用户使用的系统。开发系统：准备代替现行产品系统的下一个版本。
        两者关系如下图所示，开发人员总是在开发 n+1，而与此同时 n 正在运行。
![img](https://i-blog.csdnimg.cn/direct/20d4f4f1a5d34dc1a38dca2824ca1d1e.png)



##### 6.2增量开发和迭代开发

​        因为有不断发布的开发系统和已经运行的产品系统，我们需要有一种组织两者的方式。增量开发和迭代开发是两种最常用的方式。
​        ①增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。
​        ②迭代开发：系统开始就提供了整体功能框架，后续版本陆续增强各个子系统，最后版本使各个子系统的功能达到最强。

增量开发：目的是产生新功能，开拓市场

迭代开发：目的是及时修复问题，完成功能优化

##### 6.3迭代进化式开发（迭代增量式开发）

​       一个新发布的版本可能包含新功能，并对已有功能做了改进。两种开发方式结合的原因：
​        ①观察用户反馈。
​        ②为新功能开拓市场。

​        ③及时修复问题。
​		④针对不同版本设置不同专业领域技术的优化。



##### 6.4统一过程开发（目前最核心的开发方式）

​       统一过程（UP/RUP）：用例驱动的、以基本架构为中心的、迭代式和增量式的软件开发过程框架。它使用对象管理组织（OMG）的 UML 并与对象管理组织（OMG）的软件过程工程原模型（SPEM）等相兼容。

统一过程开发

​        1、用例驱动

​        2、基本架构为中心

​        3、结合迭代式和增量式开发

①统一过程的特点：
        (a)统一过程”将重复一系列生命期，这些生命期构成了一个系统的寿命。每个生命期都以向客户推出一个产品版本而结束。
        (b)每个周期包括四个阶段：开始阶段、确立阶段、构建阶段和移交阶段。每个阶段可以进一步划分为多次迭代。

​    	(c)三个支持工序和六个核心工序：

​            支持工序：
​                    (1)配置变更管理工序，用来管理系统和需求变更的配置。

​                    (2)项目管理工序，用来管理项目。
​                    (3)环境配置工序，用来配置项目的环境，包括所涉及到的过程和工具。
​            核心工序：
​                    (1)业务模型工序，用业务模型获取相关知识以理解需要系统自动完成的业务。

​                    (2)需求工序，通过用例模型获取相关知识以理解自动完成业务的系统需求。
​                    (3)分析设计工序，通过分析/设计模型以分析需求，设计系统结构。

​                    (4)实现工序，基于实现模型实现系统。
​                    (5)测试工序，通过测试模型进行针对需求的系统测试。

​                    (6)部署工序，通过部署模型部署系统。

   下图展示了统一过程的四个阶段和六个核心工序之间的关系，上面一行表示四个阶段，左边一列表示六个核心工序，二者都包含在软件项目的生命期中。每个阶段都包含六个工序，但是重点不同。开始阶段最关注业务模型，几乎不涉及测试和部署；确立阶段最关心需求和分析；构建阶段最关心实现；移交阶段最关心测试和部署，几乎不涉及业务模型和需求。图中箭头表示六个工序执行顺序，菱形覆盖的



![img](https://i-blog.csdnimg.cn/direct/00db3242e69d42a2a65ea13c441681c7.png)



特别记忆：
   1、 Wasserman 八大规范：是整个软件工程学习的内容，同样也是整个软件从开发到生命终止的过程，里面包括软件过程。
   2、统一过程是分阶段过程模型的一部分，用来解决开发系统和运行系统的版本问题。统一过程开发中的六大核心工序：业务模型、需求分析、分析设计、实现、测试、部署。本质就是工程化方法的步骤。


#### 7.螺旋模型

   此法将开发活动与风险管理结合起来, 以降低和控制风险。有些类似于迭代开发模型，结合了迭代的思想，同时也结合了原型化的思想。该模型的适用范围于较大型软件工程项目。
       如下图所示，螺旋模型每次迭代有四个任务，依次是计划、目标/可选方案、风险评估、开发与测试。螺旋模型共有四次迭代，依次是操作概念、软件需求、软件设计、开发与测试。每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。

**核心思想：**四轮迭代，每一轮都将的到一个原型化模型

![img](https://i-blog.csdnimg.cn/direct/6dd5a12a42304e2fa59d7ed86c2e4069.png)

#### 8.敏捷方法

##### 8.1敏捷方法的四条原则

​    ①个体和交互的价值胜过过程和工具。
​    ②可以工作的软件胜过面面俱到的文档。

​    ③客户合作胜过合同谈判。
​    ④响应变化胜过遵循计划。

   这四条原则反映了敏捷方法的软件过程倾向性。它强调人与人之间的交互是复杂的，并且其效果从来都是难以预期的，但却是工作中最重要的方面。
   敏捷开发的总体目标：尽可能早的，持续的对有价值的软件的交付活动，以客户满意。

> 敏捷开发：快、准、狠

##### 8.2敏捷开发过程的几种方法

​    ①极限编程(XP)：激发人员创造性，使管理负担最小的一组技术，是敏捷方法中最主要的流派。（稍后有详细介绍）        

​    ②Crystal （水晶法）：每一个不同的项目都需要一套不同的策略、约定和方法论。
​    
​    ③SCRUM（并列争球法）：使用迭代的方法，其中把每 30 天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。
​    
​    ④Adaptive Software Development(ASD) (自适应软件开发)
​    
​    ⑤Feature Driven Development(FDD) (特征驱动软件开发)


**极限编程（XP）：**

​        （a）四个变量：成本、时间、质量和范围，通过研究变量之间的相互作用，将项目开发分析的更加透彻，成功讲述一个项目成功的原则。
​        不同的任务对这四个变量有不同的要求，分析哪一个变量是项目进展的制约，集中精力解决关键问题。
​        （b）四个准则：
​                ①沟通: 客户与开发者之间持续的交流意见。
​                ②简单性: 鼓励开发者选择最简单的设计或实现来应对客户的需求。

​                ③反馈: 指在软件开发过程中的各个活动中,包含各种反馈循环工作。

​                ④勇气: 指尽早的和经常性的交付软件功能的承诺。
​        （c）十二条原则：计划游戏、小版本、隐喻、简单设计、测试、重构、结队编程、代
码集体所有、持续集成、每周工作 40 小时、现场客户、编码标准
​                ①小版本：系统设计要支持尽可能早的交付。（测试要简单有效。）
​                ②简单设计：只处理当前需求，使设计保持简单。（因为假设需求是变化的）

​                ③编码标准：编码支持其他实践，例如测试和重构等。


#### 9.过程建模工具和技术

用来完成软件过程建模的技术和工具
3.3.1 两种主要种类的建模工具

(1) 静态建模——Lai 表示法
        描述一个过程如何由输入转换为输出。
        综合的过程符号描述系统, 允许人们在任何详细的层次上对任何过程建模, 该模型范式中可由人员完成角色,由资源完成活动, 最后导致软件工件/制品的产生。过程模型可以用角色、活动、加工项(工件)来显示彼此之间的关系，用状态表显示每个加工项(工件)在特定时间的完成情况。

​    过程的元素：
​            ①活动：过程中要发生的事件。各种前后关系、触发条件、规则、团队成员等等。也
​            可以理解为子过程。
​            ②序列：活动顺序等等。
​            ③过程模型：小型工程可以认为是开发方式等描述。

​            ④资源：活动所需的各种资源标注。
​            ⑤控制：针对活动的外部影响等。
​            ⑥策略：各种指导原则，包括约束等。
​            ⑦组织：各种层次化结构等描述。包括物理的和软件逻辑的结构。

(2) 动态建模
        推演一个过程，用户和开发人员可以看到中间产品和最终产品如何随着时间的推移进行转换。
        系统动力学：展示资源流(非一般性输入)如何通过活动成为输出。

(3) 在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？
        ①设计对于分析模型应该是可跟踪的：软件的模块可能被映射到多个需求上。

​    	②设计结构应当尽可能的模拟实际问题。
​    	③设计应当表现出一致性。
​    	④不要把设计当成编写代码。
​    	⑤在创建设计时就应该能够评估质量。



| ‌**模型名称**‌           | ‌**定义**‌                                                     | ‌**使用场景**‌                                                 | ‌**优点**‌                                                     | ‌**缺点**‌                                                     |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ‌**瀑布模型**‌           | 线性阶段开发模型，各阶段依次执行且不可逆，强调文档化和阶段评审。 | 需求明确且稳定的项目（如传统行业软件、大型系统）‌。           | 阶段清晰易管理，便于评审和审计；适用于大规模项目‌。           | 缺乏灵活性，需求变更成本高；用户需早期明确需求，后期难调整。 |
| ‌**原型模型**‌           | 通过快速构建原型与用户交互，逐步明确需求并完善系统‌。         | 需求模糊或用户难以准确描述需求的场景（如创新性产品、用户界面设计）‌。 | 快速获取用户反馈，降低需求偏差风险。                         | 可能因需求反复变更导致开发失控；原型可能被抛弃，增加成本。   |
| ‌**增量模型**‌           | 将系统拆分为多个增量组件，分阶段开发并逐步集成‌。             | 需求可拆分且优先级明确的场景（如逐步交付的长期项目）。       | 灵活适应需求变化，降低开发风险；用户可提前使用核心功能‌。     | 需预先设计模块接口，体系结构需开放；可能因增量叠加导致系统复杂度增加‌。 |
| ‌**螺旋模型**‌           | 结合瀑布与原型模型，通过迭代和风险分析驱动开发‌。             | 高风险或复杂度极高的项目（如军工、航空航天系统）‌。           | 支持动态需求变更，强调风险管理；适用于长期复杂项目‌。         | 开发周期长，成本高；对团队风险管理能力要求高‌。               |
| ‌**迭代模型（RUP）**‌    | 以迭代为核心，分阶段完成需求分析、设计、实现和测试，强调渐进式开发‌。 | 需求动态变化或需快速验证核心功能的中大型项目‌。               | 早期发现需求缺陷，支持用户参与迭代；适用于敏捷与结构化结合的团队‌。 | 模型复杂，需高水平项目管理；需开放式架构，易失去整体性‌。     |
| ‌**V模型**‌              | 强调测试与开发并行，每个开发阶段对应特定测试活动（如单元测试、集成测试）‌。 | 对质量要求严格的系统（如医疗设备、金融核心系统）。           | 测试活动贯穿全程，质量可控性高；阶段对应性强‌。               | 灵活性低，需求变更困难；需早期冻结需求‌。                     |
| ‌**边做边改模型**‌       | 无明确规划，直接编码并根据需求即时修改‌。                     | 小型、临时性项目或快速验证想法的场景（如个人工具开发）。     | 开发速度快，成本低‌。                                         | 代码质量差，维护困难；需求不清晰易导致重构成本高‌。           |
| ‌**XP模型（极限编程）**‌ | 敏捷开发模型，强调快速交付、持续集成和用户协作‌。             | 需求频繁变更的中小型项目（如互联网产品、初创企业应用）‌。     | 响应变化快，用户参与度高；结对编程提升代码质量‌。             | 不适用于大型团队或复杂架构；需频繁重构，可能退化为无序开发‌。 |

### 第三章：计划和管理项目

如果要开始一个项目，我们需要跟客户讲述一下我们要做哪些工作来实现这个项目，做多长时间，用多少花费。回答不上这些问题估计客户是不敢找我们干的，回答这些问题就需要我们：
        （1）首先有明确的实现项目的各个步骤活动的具体时间计划
        （2）干的时候十分清楚自己干到了哪一步
        （3）预估整体的预算是多少，凭什么值这个价。
       基于这些需求，我们有了这一部分的内容，即，我们怎么跟踪项目进展到哪里了？怎么组织人去完成项目？怎么预估工作量？怎么通过风险管理节约成本？这些都是站在一个项目负责人的角度应当考虑的问题。

计划和管理项目四个方向：

​        1、时间计划；

​        2、工作量计划；

​        3、人员管理；

​        4、风险管理；

#### 1.时间计划（进度管理）

时间上确定该怎么做，做到哪里了？

##### 1.1关键概念介绍

(1) 项目进度（Project Schedule）
       项目进度是对特定项目的软件开发周期的刻画。包括对项目阶段、步骤、活动的分解，对各个离散活动的交互关系的描述，以及对各个活动完成时间及整个项目完成时间的初步估算。
(2) 项目活动（Project Activity）
       项目的一部分，一般占用项目进度计划中的一段时间（活动图中的线表示项目活动）
(3) 里程碑（Milestone）
       指特定的时间点，标志着活动的结束，通常伴随着提交物。（如一般性文档，功能模块的说明，子系统的说明和展示，精确度的说明和展示，可靠性，安全性，性能说明或展示文档）（活动图中的圆圈表示里程碑）

##### 1.2估算项目完成时间

有了活动图后，我们想要估算项目完成时间，本质上就是要计算关键路径的完成时间。

而想要求解出关键路径的完成时间，就要求解出关键路径。

求解关键路径，就需要知道每一个活动的最早/最迟开始时间，若相等则该活动是关键路径上的。

我们的任务就转变为求解关键路径、最迟开始时间、最早开始时间、冗余时间。



求解关键路径：里程碑（时间点）的最晚开始时间-最早开始时间；

​							最晚结束时间-最早开始时间；



计算最早和最晚开始时间：最早从前往后，多个路径选择最大的；最晚从后往前，多个路径选择最小的

计算最早和最晚结束时间：分别算

![截屏2025-03-25 10.11.13](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-25 10.11.13.png)

![截屏2025-03-25 10.59.35](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-25 10.59.35.png)





#### 2.工作量计划 （‌成本估算）

工作量计划也就是工作量估算，分为两个：估、算

估的典型就是：专家估算法（乐悲观估算、Wolverton模型估算、Delphi估算）

算的典型就是：COCOMO模型

软件项目规划过程包括以下步骤：确定项目的目的和范围，具体说明项目的最终产品以及期望的时间、成本、质量目标；分解和定义整个项目应包括的工作活动和任务；估算完成该项目的规模及其所需资源；制定合理的软件项目计划，包括进度、成本、质量等方面的预测。

软件项目规模的常用估算方法包括代码行、功能点等技术。

1.代码行技术

多名有经验的开发人员分别给出代码行估算，求平均值。

开发人员提出一个有代表性的估算值范围，按最佳的 （a）、可能的（m）、悲观的（b）三种情況给出估算值，计算期望值：L=（a+4m+b）/6。

```
（1）生产率：P=L/PM
```

其中，L是软件的代码行数，其单位是干行代码KLOC；PM是软件开发的工作量，其单位是人月；P是软件开发的生产率，其单位是每人月完成的代码行数。

```
（2） 单位成本：C=S/L
```

其中，S是软件开发的总成本，其单位是人民币或美元等货币单位；C是每行代码的平均成本。

```
（3）代码出错率：EQR=N/L
```

其中，N是软件的错误总数；EQR是每干行代码的平均错误数。

2.功能点技术

一句软件信息域的基本特征和软件复杂性的估计，估算出软件规模，以功能点为单位度量软件规模。

软件信息域的5个基本特征包括外部输入、外部输出、外部查询、内部逻辑文件和外部接口。

软件成本估计：

1. ﻿﻿专家判断；
2. ﻿﻿类比估计；

  3.COCOMO模型

##### 2.1专家估算法

   很多工作量估算方法依赖于专家的判断。使用专家的知识和经验，对软件项目的工作量进行评估，预测的精确性基于估算者的能力、经验、客观性和洞察力。是对构建整个系统或其子系统所需的工作量做出经验性的猜测。



##### 2.2算式估算法

**普通算式估算法：**

​    研究人员已经创建出表示工作量和影响工作量的因素之间关系的模型。这些模型通常用方程式描述，其中**工作量是因变量，而其他因素是自变量。大部分模型认为项目规模是方程式中影响最大的因素**，表示工作量的方程式是：

![E=(a+b S c) m(X)](https://latex.csdn.net/eq?E%3D%28a&plus;b%20S%20c%29%20m%28X%29)



COCOMO模型：

三个阶段的COCOMO：

> 基本COCOMO模型

系统开发的初期，估算整个系统的工作量(包括维护)和软件开发和维护所需的时间

> 中间COCOMO模型

估算各个子系统的工作量和开发时间

> 详细COCOMO模型

估算独立的软构件，如各个子系统的各个模块的工作量和开发时间

COCOMOⅡ是一种工作量估算法，将软件开发分为三个阶段，不同阶段的估算方法不同。

- 阶段一（原型阶段）：通过构建原型解决高风险问题，如用户界面、系统交互和技术成熟度等。此时对最终产品规模了解较少，因此使用应用点来估算项目规模。
- 阶段二（早期设计阶段）：项目开发已经开始推进，设计人员研究不同的体系结构和操作概念。尽管信息比第一阶段多，但仍不足以准确估算工作量和工期。此阶段使用功能点来测量项目规模。

- 阶段三（后体系结构阶段）：开发工作已开始，且已获取更多信息。在此阶段，可以使用功能点或代码行来进行规模估算，并较容易估算相关的成本因素。


基本COCOMO模型具体公式： 

- E = a * (KLOC)^b ;

```less
E是工作量(人月) ，a和b是经验常数，KLOC为代码行数（项目规模）
```

- D = c * E^d ;

```r
D是开发时间(月) ，c和d是经验常数,其取值见下表：
```

> 相比于普通算式估算，COCOMO更加看重项目规模对工作量的影响 



#### 3.人员管理

##### 3.1人员选择的要求（软件人员应具备的能力）

（1）完成工作的能力（2）对工作的兴趣（3）开发类似应用的经验（4）使用类似工具或语言的经验（5）使用类似开发环境的经验（6）使用类似技术的经验（7）培训（8）与其他人交流的能力（9）与其他人共同承担责任的能力（10）管理技能

##### 3.2作方式

外向，内向；感性，理性，不同性格的人搭配会产生不一样的效果。课本上只是粗略的一个分析。

##### 3.3项目（团队）组织

项目组织的结构化和创造性的关系：

   结构化较强的团队：
   按时完成任务，单工作比较循规蹈矩，项目普通但是功能完备。适合人员较多，项目稳定性和一致性高，使用较正规的结构。

   结构化较弱的团队：
   不能按时完成任务但是创造性强，涉及大量的不确定性因素时采用较为民主的方法和相关的团队结构。

可以参考的组织方式： 

   (1) 主程序员负责制（Chief Programmer Team）
   由一个主程序员负责系统设计和开发，其他的成员向其汇报，主程序员对每一个决定有绝对决策权。
   优势：
          使交流最小化
          迅速做出决定

   缺点：
          创造性低
          对主程序员要求高，个人主观性强
   (2) 忘我方法制（Egoless Approach）
   每个成员平等的承担责任，而且过程与个人是分开的；批评是针对产品和结果的，不针对个人的。

前者是专制：结构化强创造性低；

后者是民主：结构化弱创造性强

#### 4风险管理

##### 4.1什么是风险

​    概念：软件生产过程中不希望看到的，有负面结果的事件
​    方面：风险损失，风险概率（相乘为风险暴露（Risk Exposure），即数学期望）

##### 4.2 风险管理活动

​    风险评价：风险识别，风险分析，风险优先级分配
​    风险控制：风险降低，风险管理计划，风险化解

##### 4.3 风险控制

(1) 风险降低
        避免风险（Avoiding the risk）：改变功能和性能需求，使风险没机会发生。比如用 C 语言的程序有内存泄漏的风险改用 Java，避免风险。
        转移风险（Transferring the risk）：通过把风险分配到其他系统中，或者购买保险以便在风险成为事实时弥补经济上的损失。
        假设风险（Assuming the risk）：用项目资源，接受并控制风险。比如在开发时主动有意识地进行测试。

(2) 风险化解（风险+应对方法）
        产品过大：从一个小的产品内核开始，在以后的开发循环中再添加各种功能。

​    	过难或是复杂的功能：在工程开始时化简这些功能，再考虑它们的代替品。
​    	系统支持问题：建立一个早期原型或者小产品版本，以确定你了解支持系统是如何工作的。（通过对核心功能的测试，可以确定其他系统对本软件的系统支持程度）

​    	测试时间：按照 TSPi 进行工作，使用规范的 PSP 方法。
​    	产品控制：这就是在工程开始时进行配置管理的原因。
   	 协同工作问题：工作人员合理搭配问题



#### 5.软件项目管理的核心内容包括：

1. ‌**成本估算**‌：估算项目所需资源与费用，建立成本基线‌。
2. ‌**风险分析**‌：识别潜在风险并制定应对策略‌。
3. ‌**进度管理**‌：通过甘特图、里程碑等工具规划和控制项目时间‌34。
4. ‌**人员管理**‌：合理分配人力资源，组织团队协作（如主程序员组、民主制团队），确保项目高效执行‌。



### 第四章：需求分析

 软件开发的前期需要进行的就是软件分析，软件分析的最后一步也就是最重要的一步就是需求分析。只有做好需求分析，才有可能做好后面的软件开发任务。

#### 1.需求

##### 1.1需求是什么

   定义：用户关于软件系统的期望行为的综合描述，涉及系统的对象、状态、约束、功能等。

##### 1.2需求的类型

需求：

​    ①功能需求：描述系统内部功能或系统与外部功能的交互作用，涉及系统输入应对、实体状态变化、输出结果、设计约束、过程约束等。

​    ②非功能需求：描述软件方案必须具备的某些质量特征，例如系统性能、安全性、响应时间等。

##### 1.3需求的特征

需求的特征：
        正确性；一致性；无二义性；完备性；可行性；相关性；可测试性；可跟踪性。

补充：
        正确：我们和客户都应该评审需求文档，确保它们符合我们对需求的理解
        一致：一般来讲，如果不可能同时满足两个需求，那么这两个需求就是不一致的。
        无二义：如果需求的多个读者能够一致、有效地解释需求，那么需求就是无二义性的。

​    	完备：如果需求指定了所有约束下的、所有状态下的、所有可能的输入的输出以及必需的行为，那么这组需求就是完备的。
​    	可行：当用户要求两个或更多的质量需求时，常常会出现可行性问题
   	 相关：有时，某个需求会不必要地限制开发人员，或者会包含与客户需要没有直接关系的功能。
   	 可测试：如果需求能够提示验收测试（明确证明最终系统是否满足需求），需求就是可测试的。

##### 1.4需求的表示 

   需求的表示就是对需求进行建模。

   建模可以使用UML统一建模语言，例如用例图、类图等来表示。



#### 2.需求的引出

   需求的引出是极为重要的一部分，我们必须使用各种技术来确定客户和用户到底想要什么。

##### 2.1风险承担者

   风险承担者包括：委托人，客户，用户，领域专家，市场研究人员，炉石或审计人员，软件工程师或其他技术专家。

核心思想：

​        1、风险承担者是指项目出现问题，会有真实利益受损的群体。

​        2、只有与风险承担者会谈才有参考价值。非风险承担者的建议不一定可信。

##### 2.2需求引出的具体手段

​    ①与风险承担者进行会谈

​    ②评审相关文档
​    ③观察当前系统
​    ④做用户的学徒，当用户进行任务时更详细的进行学习
​    ⑤以小组形式与用户和风险承担者交谈

​    ⑥使用特定领域的策略
​    ⑦就如何改进产品，与当前的和潜在用户进行集体讨论

具体手段大致可以分为：

​        1、会谈（和风险承担者会谈）：个人/小组

​        2、关注特殊领域/特殊人群（潜在用户）

​        3、观察学习：观察系统、学习用户使用情况

​        4、文件审查：查看相关文档

#### 3.需求分析 

   在引出需求后，面对众多的需求我们需要做的第一件事就是需求的前期处理，不然庞大的需求会让我们眼花缭乱。

##### 3.1需求前期处理

前期处理就是要让庞大的需求更加有逻辑，有针对性。

​        1、优先级划分；

​        2、需求的规范化（正式名字、唯一定义、量化描述）。

(1)需求的优先级划分
       当进行需求的引出时，可能会碰到大家对“需求是什么”存在分歧，此时采用对需求进行
优先级划分的方法是有效的。

​    ①必须要被满足的需求
​    ②非常值得做但是不是必须的需求
​    ③可选的需求（可做可不做）

(2)需求的规范化：
        ①针对需求确定一种量化的描述方法，避免模糊的表达方式
        ②将各种指代用词替代为实体的正式名字
        ③每个名词或事项应在需求文档中给出唯一定义

##### 3.2需求下的约束

​    ①设计约束：已经做出的设计决策或限制问题解决方案集的设计决策。涵盖物理环境、接口、用户等方面。
​    ②过程约束：对用于构建系统的技术和资源的限制，涵盖资源、文档等方面。

##### 3.3需求分析的全过程

   这里我们在意的是需求分析这一个活动的完整过程：

​            ①原始需求获取：客户给出的需求
​            ②问题分析：理解需求并通过建模或模型化方式进行描述
​            ③规格说明草稿：利用符号描述系统将定义规范化表示
​            ④需求核准：开发人员与客户进行核准
​            ⑤软件规格说明（SRS）

信息获取——客户需求、自我建模分析

需求分析结果——规格说明书 

##### 3.4补充知识 

   问题：需求分析时，若小团队且需求不确定，可采用敏捷开发方法；若大团队进行需求确定的开发时可采用“重量级”过程。
    ①敏捷开发方法的需求建模
            适用范围：小团队，不确定的需求
            方法：增量式开发（或迭代式开发）
    ②“重量级”过程
            适用范围：大团队，确定的需求
            特点：开发人员将编码推迟到已经对需求进行了建模和分析，详细的设计已完成，其中每一步都需要模型，模型间是相关的、相互配合的，以便于设计完全实现需求。

核心要点：

​        1、不同软件过程可以结合起来使用。

​        2、软件过程可以结合迭代式思想、增量式思想、原型化思想使用。

​        3、迭代式和增量式这种分阶段开发思想相当适用于敏捷开发 。

#### 4.需求文档化

##### 4.1为什么要文档化

​    配置管理的一种方式，使得需求分析的每个阶段都有文档进行参考。

​    配置管理：是对软件开发过程以及软件生命周期过程的控制，具体来说就是让软件过程各阶段文档保持一致的系列过程。

​    软件配置管理：
​            定义：一种标识、组织和控制修改的技术，目的是最有效的提高生产率，能够协调软件开发，使混乱减少到最小。（协调开发，使混乱最小化）
​            任务：制定软件配置管理计划；确定配置表示规则；实施变更控制；报告配置状态；进行配置审核；进行版本管理和发行管理。
​        	与软件开发过程的关系：变更的评估和批准都需要由软件配置管理人员去做，开发过程应纳入配置管理过程的控制之下。
​        	忽视软件配置管理可能导致的混乱现象：发错了版本，安装后不工作，异地不能正常工作，已经解决的缺陷过后又出现错误，开发人员把产品拿出去出售赢利，找不到最新修改了的源程序，找不到编程序的人

##### 4.2文档化的结果是什么（需求规格说明（SRS））

​    将需求重述为关于要构建的系统将如何运转的规格说明。

​    需求定义在说需求是什么，需求规格说明在说系统在这个需求定义下能做什么。

​    软件工程师的目标：让系统能做什么的范围尽量包括需求是什么的范围。



#### 5.需求的确认

##### 5.1需求确认

检查需求规格文档与需求定义的对应性。

##### 5.2需求复审

再一次审查已经通过的需求规格文档。

##### 5.3需求的测量

测量集中的领域：产品，过程，资源
测量措施：

①产品方面：需求的数目；评估需求文档
②过程方面：需求变化的数目；引起需求变化的原因



#### 6.需求分析阶段需要的图形化工具

**数据流图（DFD图）**‌

**流程图**

**用例图**

**E-R图（实体关系图）**



#### 7.通过哪些⽅⾯验证需求的正确性

1. ‌**⼀致性**‌

   - 所有需求之间不能存在逻辑矛盾，需确保不同需求描述在功能、性能、接口等层面相互兼容‌。

2. ‌**完整性**‌

   - 需求规格需覆盖用户提出的所有功能及性能要求，避免遗漏关键需求或场景‌。

3. ‌**现实性**‌

   - 需求应基于当前硬件技术和软件技术可实现，避免提出超出技术能力范围的要求‌。

4. ‌**有效性**‌

   - 需证明需求能实际解决用户问题，满足业务目标，而非仅理论可行。

   

### 第五章：设计体系结构

系统体系结构就是研究如何将系统分解为单元，以及单元之间如何相互关联。系统体系结构的研究就是设计的一部分——概要设计。

系统体系研究=概要设计（系统设计）=设计的一部分

 本章后续提到的设计都是指体系结构设计。

#### 1.设计过程

##### 1.1相关概念

​    (1) 体系结构 Architecture: 一种软件解决方案，用于解释如何将系统分解为单元，以及单元如何相互关联，还包括这些单元的所有外部特性。
​    (2) 设计 Design: 将需求中的问题描述转变成软件解决方案的创造性过程.
​    (3) 例程设计 routine design: 通过对与相似问题的解决方案进行复用和调整来解决某个问题。

​    (4) 克隆 cloning: 借鉴现有的整个设计设置包括它的代码，对它做少许的调整来解决特定问题

​    (5) 参考模型 reference model: 用于特定应用领域中标准的、一般性的体系结构，指导我们把系统分解成主要构件以及构件之间如何交互

​    (6) 体系结构风格 architectural style: 是已建立的、大规模的系统结构模式，有一系列定义好了的规则、元素和技术。体系结构不是完整的、细节化的解决方案，而是用于提供各种构建组合起来的方法模板。关注的是构件间各种不同的通信、同步或共享数据的方式。

​    (7) 设计模式 design pattern: 一种针对单个软件模块或少量模块而给出的一般性解决方案，它提供较低层次的设计决策。它是一个共同的设计结构的关键方面，包括对象和实例，角色和协作，责任分配。（例如：工厂模式、单例模式、适配器模式等）。

​    (8) 设计原则 design principle: 是良好设计的特征，也是能够把系统功能和行为分解成模块的指导方针。

​    (9) 设计公约 Design Convention: 一系列设计决策和建议的集合，用于提高系统某方面的设计质量。当一种设计公约发展成熟时，将会被封装成设计模式或体系结构风格，最后可能被内嵌为一种程序语言结构。

​    (10) 创新设计 innovation design: 与例程设计相反，用以创造全新解决方案

​    (11) 概念设计和技术设计是两个迭代的过程
​    概念设计 conceptual design 相当于系统设计，确切地告诉客户系统要做什么，即软件架构和功能。
​    技术设计 technical design 相当于程序设计，一旦客户认可概念设计，系统构建人员就将概念设计转换为更为详细的文档，即技术设计，技术设计确切的告诉开发人员系统将如何运转，包括:主要的硬件组件及其功能；软件组件的层次和功能；数据结构和数据流。

​    概念设计强调的是系统功能，而技术设计描述的是系统将要采取的方式。

​    (12) 模块化 Modular: 只有当系统的每个活动都仅由对应的软件单元实现，并且每个软件单元的输入和输出都已经明确的被定义时，这个设计才是模块化的。

> 设计 = 系统设计+模块设计 = 概要设计+详细设计 = 概念设计+技术设计

##### 1.2系统结构设计全过程（如何完成系统结构设计）

​    (1) Modeling 建模:尝试可能的分解，根据需求描述的系统的关键特性等确定软件体系结构风格。
​    (2) Analysis 分析:分析初步的体系结构，主要关注软件系统的质量属性如性能、安全性、可靠性等、各种约束等等。关注系统级别决策。
​    (3) Documentation 文档化:确定各个不同的模型视图。

​    (4) Review 复审:检查文档是否满足所有需求。

​    (5) final output: SAD:Software Architecture Document 软件体系结构文档，用来和开发团队中其他人员交流系统级别设计决策的有力工具。

##### 1.3分解（系统结构设计的核心方法）

分解：是系统结构设计全过程中最重要的一步——建模中的核心思想

分解后产生的就是模块，模块化也就是分解的目的；抽象化和模块化紧紧联系

分解是把大的系统分解成为更小的部分使问题变得更易于处理，是一种自顶向下的方法；另一种自底向上的方法是将小的模块以及小的构件打包成一个更大的整体，被认为其设计出来的系统更加易于维护。

六种分解方法：

​     (1) 功能性分解 Functional decomposition:按照功能和需求进行分解
​     (2) 面向特征的分解 Feature-oriented design:功能性分解的一种，为各个模块指定了各自的特征
​     (3) 面向数据的分解 Data-oriented decomposition :关注如何将数据分解成模块

​     (4) 面向进程的分解 Process-oriented decomposition:将系统分解成为并发进程

​     (5) 面向事件的分解 Event-oriented decomposition:将事件分给不同的模块
​     (6) 面向对象的设计 Object-oriented design:将对象分配给模块

#### 2.设计过程中的若干问题

##### 2.1三种设计层次及其关系

​    (1) 体系结构设计，相当于系统设计，将 SAS 中确定的系统能力和实现这些能力的系统构件关联起来。
​    (2) 代码设计 code：各个构件/模块的算法和数据结构设计。
​    (3) 可执行设计 executable：最底层的设计，包括内存分配，数据格式、位模式等。

这是一种自顶向下的设计，首先设计体系结构，然后进行代码设计，最后是可执行设计，具有可重复性，可以多次修改。

核心要点：

​        这与前面我提到的：设计 = 系统设计+模块设计 = 概要设计+详细设计 = 概念设计+技术设计 并不冲突。

​        严格来说这里的体系结构设计是广义的包括：系统设计和模块设计两部分。



##### 2.2模块化与抽象层次

  (1) 模块化设计 modularity 也称作关注点分离，是一种把系统中各不相关的部分进行分离的原则。在模块化的设计中，构件清晰地定义了输入和输出，设计目标明确，功能独立，可以做独立测试。
  (2) 抽象 abstraction：对细节的隐藏称为抽象，是基于某种归纳水平的问题描述，是我们集中于问题的关系。当探讨或分析两个模块共享某数据时,模块各自的私有细节应隐藏。
  (3) 模块都以某种不同层次结构的抽象的形式出现, 越上层、越早期的模块层次或框架是越抽象的设计。将模块化部件和抽象层次结合，顶层模块通过隐藏细节可以给出解决方案，其他层次模块显示主要职能和实施细节，就可以用不同的方式设计不同构件的能力。

系统结构设计的核心在于分解；分解的目的在于模块化。

因此模块化的质量相当重要，模块独立性就是模块化质量水平高低最好的衡量标准。 



####  3.模块独立性

##### 3.1耦合与内聚的定义

1. ‌**耦合（Coupling）**‌
    指模块之间依赖关系的紧密程度，耦合度越高，模块独立性越差。低耦合是软件设计的核心目标之一，能减少模块间的相互影响，提高系统的灵活性和可维护性‌。
2. ‌**内聚（Cohesion）**‌
    指模块内部各元素（代码、功能等）的逻辑关联程度，内聚度越高，模块的功能越单一且集中。高内聚有助于简化模块逻辑，提升代码可读性和复用性‌。

------

##### 3.2耦合的类型与等级（耦合度从低到高）

1. ‌**非直接耦合**‌：模块间无直接交互，仅通过主模块调用‌。
2. ‌**数据耦合**‌：通过简单数据参数传递信息（如数值、字符串）‌。这是最受欢迎的一种耦合。
3. ‌**标记（特征）耦合**‌：通过参数传递数据结构或记录（如对象地址）‌。
4. ‌**控制耦合**‌：传递控制信号（如标志位）影响其他模块逻辑‌。
5. ‌**外部耦合**‌：共享全局简单变量（非数据结构）‌。依赖共享的外部资源（如文件、数据库、协议），但资源由外部系统而非模块自身管理。
6. ‌**公共耦合**‌：共享同一全局数据结构或内存区域‌。
7. ‌**内容耦合**‌：直接修改对方模块内部数据或代码（耦合度最高）‌。

------

##### 3.3内聚的类型与等级（内聚度从低到高）

1. ‌**偶然内聚**‌：模块内代码无逻辑关联（如随机组合）‌。
2. ‌**逻辑内聚**‌：按相似功能分类（如多种输入处理）‌。
3. ‌**时间内聚**‌：因同一时间段执行而聚合（如初始化操作）‌。
4. ‌**过程内聚**‌：按执行流程顺序组织代码（如多个步骤）‌。
5. ‌**通信内聚**‌：操作共享同一数据源（如读取并处理同一文件）‌。
6. ‌**顺序内聚**‌：前一步骤的输出是下一步骤的输入‌。
7. ‌**功能内聚**‌：模块内所有代码共同完成单一功能（内聚度最高）‌。
8. **信息内聚** ：功能内聚的基础上调整为数据抽象化和基于对象的设计。面向对象设计的目的是高内聚

##### 3.4模块化

如果无限地分割软件，最后为了开发软件而需要的工作量也就小得可以忽略了。事实上，还有另一个因素在起作用，从而使得上述结论不能成立。

当模块数目增加时每个模块的规模将减小，开发单个模块需要的成本(工作量)确实减少了；但是，随着模块数目增加，设计模块间接口所需要的工作量也将增加。根据这两个因素，得出了总成本曲线。每个程序都相应地有一个最适当的模块数目M，使得系统的开发成本最小。
![截屏2025-02-27 10.30.59](/Users/yangluheng/Library/Application Support/typora-user-images/截屏2025-02-27 10.30.59.png)



#### 4.体系结构的评估和改进

##### 4.1故障树分析

​    故障树：通过分解设计寻找可能导致实现的情形。根节点表示想分析的故障/失效，其他节点表示事件或者表示导致根节点失效所发生的故障。其中父节点用逻辑门操作表示，与门指二者必须同时发生才会使父节点发生；或门则是发生一个子节点就足以引发父节点。

##### 4.2错误预防和容错

​    (1) 正确区分错误、故障和失效并知道三者的关系（第一章）
​    (2) 主动进行故障检测：定期检查故障或预测故障，为此应给一个功能预留多个实现途径
​    (3) 被动故障检测：强化故障恢复
​    (4) 进行容错设计：当软件失败发生时,采取措施减少损失并将损害隔离开来, 在用户接受的条件下使系统继续运行 .

如何预防错误：

​        1、概念上理解错误（error）、故障（falut）、失效（failure）的区别。

​        2、主动检查故障以及修复故障：程序可靠性的一部分

##### 4.3设计复审（review）的两种方法：验证与确认

​    复审定义：检查文档是否满足所有功能及质量需求。
​    两种设计检验的方法：
​            (1) 验证 verification：确保设计遵循良好的设计原则，设计文档满足阅读者的需要。验证检查某样东西是否符合之前已定好的标准，就是要用数据证明我们是不是在正确的制造产品。更注重过程正确性，强调做得正确
​            (2) 确认 validation：确认设计能够满足用户需求。确认检查软件在最终的运行环境上是否达到预期的目标，就是要用数据证明我们是不是制造了正确的产品。更注重结果正确性，强调做的东西正确。
​            (3) 验证更多是从开发商角度来做评审、测试来验证产品需求、架构设计等方面是否和用户要求一致，确认更多是从用户的角度或者可以是模拟用户角度来验证产品是否和自己想要的一致。

##### 4.4设计复审的重要性

​    (1) 复审中批评和讨论是“忘我”的，能将开发人员更好地团结在一起，提倡并增强了成员之间的交流
​    (2) 在评审过程中故障的改正还比较容易，成本还不高，在这时候发现故障和问题会使每一个人受益。



#### 5.设计阶段需要的图形化工具

##### **5.1概要设计阶段**

**系统结构图**‌

- ‌**用途**‌：描述软件总体架构与模块划分，指导详细设计与编码‌。



##### **5.2详细设计阶段**

**核心定义**‌：PAD（Problem Analysis Diagram）是一种面向‌**详细设计阶段**‌的图形化工具，主要用于结构化程序设计，支持从问题分析到代码生成的自动化流程‌。

‌**功能定位**‌：

- 在软件开发中，PAD图通过树形结构描述程序逻辑，可直接转换为代码（如通过代码生成工具），实现‌**软件自动化生成**‌‌。
- 与系统分析工具（如DFD图）不同，PAD图更侧重于程序逻辑的详细设计与实现。

**程序流程图**‌

- ‌**用途**‌：描述模块内部算法逻辑与执行流程‌。

‌**UML类图**‌

- ‌**用途**‌：定义类、接口及关联关系，支持面向对象设计‌。

‌**时序图（UML）**‌

- ‌**用途**‌：展示对象间动态交互与消息传递顺序‌。



### 第六章：考虑对象（UML、UML在软件开发中的应用、面向对象方法的软件开发）

#### 1.考虑对象

**软件开发过程：**需求分析、系统设计、软件设计、软件实现、单元测试、系统测试、交付、维护。

**OO软件开发过程不同于传统开发的点在于：**需求分析、设计、编码、测试

##### 1.1面向对象的基本含义

> 面向对象是一种软件开发方法，它将问题及其解决方法组织成一系列独立的对象。数据结构（属性）和动作都被包括在其中。

##### 1.2面向对象的七个特征

 ①标识
 确定对象的身份。对象名称将一个对象和另一个对象区分开来，或区分对象自身的状态，使对象可辨别。
 ②抽象
 层次化的角度描述对象
 ③分类
 将在属性和行为上有共同点的对象分成一个类（一个对象是某特定类的一个实例）
 ④封装
 封装一个对象的属性和行为，隐藏其实现细节
 ⑤继承
 根据对象间相同点和不同点分层次地组织对象
 ⑥多态
 指允许不同类的对象对同一函数调用做出响应。即同一函数调用可以根据调用对象的不同而采用多种不同的行为方式。多态存在的三个必要条件：继承、重写、父类引用指向子类对象
 ⑦持久性
 持久对象不随着创建它的进程结束而消亡（因为在外存中存贮）

##### 1.3关于面向对象的几个问题

 ①OO 开发的优势（相对于传统过程式开发）

>  语言的一致性：采用相同的语义结构（类、对象、接口、属性、行为）描述问题和解决方案
>  全开发过程的一致性：从需求分析和定义、高层设计、底层设计到编码和测试等，所有的过程都采用相同的语义结构

核心点：

> ​     1、语言一致性意味着我们可以更好的描述并理解问题。
>
> ​     2、全开发过程一致性意味着我们可以在开发中减少体系转化。
>

 ②OO 描述类的三个观点

>  静态观点：包括描述对象、属性、行为和关系
>  动态观点：包括描述通信、时间控制、状态和状态转变
>  约束：描述软件结构和动态行为的约束

 类的三个角度：静态、动态、约束

 ③OO 过程的定义

>  OO 需求分析和定义+OO 高层设计+OO 底层设计+OOP+OO 测试
>

 ④OO 开发过程的特征

> ​     全开发过程的一致性是 OO 开发过程和传统过程式开发的关键区别
> ​     OO 方法在软件制作全流程上尚缺乏理论支持，比如测试理论等
> ​     OO 可以被使用于许多不同的软件生命周期
> ​     OO 开发过程更多地考虑了类和对象复用的可能性



#### 2.面向对象开发过程

##### 2.1OO 需求分析

​    ①确定类（粗略的定义）
​    概念层类图<conceptual class diagram>：描述应用领域中的概念, 这些概念和类有很自然的联系, 但两者并没有直接的映射关系。
​    领域模型：这不是对软件对象的描述,而是对现实世界中的概念的表示
​    素描<sketch>：描述大致的轮廓而不去确定细节
​    ②类或领域中的动态行为
​    有时使用活动图来描述行为，也可以使用状态图

​	需求分析（具体层面）：问题分析、建立用例图、类图建立、工作流图、场景。

​	需求分析（OO层面）：确定类、确定类的动态行为

​	OO层面的需求分析是具体层面需求分析的更高层次抽象

其他知识：

​        1、领域模型：一个抽象层次下的模型。并不关心完整事物而是关心在我所关心领域下的事物的模样（不关注软件中的事物，而是关注现实中的事物）。 

​        2、素描：描述大致的轮廓而不去确定细节

​        3、概念类图：仅仅关注概念。只关注类、实体和关系，并不关注类对象的具体行为。

##### 2.2OO 设计

​    ①系统设计
​    步骤：整个系统的构成-->确定类-->确定对象和类之间的交互和关系-->确定其他的一些图
​    ②程序设计
​    步骤：设计算法-->确定类库细节（在系统规模较大的时候，插入类库的细节时还要有一定的次序，即较复杂的类图结构细节化时的次序问题）-->考虑非功能性需求（根据非功能性需求进行追加式的设计以确保软件设计质量）

##### 2.3OO 编码与测试

​    OO 编码即把模型转换成 OO 编程语言
​    OO 测试是一系列的测试活动，包括单元测试、集成测试、系统测试和验收测试



#### 3.UML语言的学习 

 从这里我们看到，OO软件开发过程从需求分析、设计到编码和测试，整体构造非常复杂。因此，我们为了保证前后过程交接时沟通的方便，以及配置管理需要，我们需要一个统一的语言来描述软件。

​    这个语言要求能够较为完备的描述需求分析到测试的每一个步骤，从而便于不同步骤人员的交接，以及配置管理对于每一阶段留存文件的要求。这就是UML统一建模语言的诞生！！

​    同时由于OO方法进行软件开发比起一般软件开发有语言一致性和全开发过程一致性，因此使得创造一个统一语言成为可能。

> UML语言用于OO方法的软件开发：
>
> ​        1、UML语言贯通开发可行性分析：OO方法的软件开发有语言一致性和全过程一致性。因此能够有统一建模语言去贯通软件开发的全过程。
>
> ​        2、UML语言贯通开发好处分析：用UML语言贯通软件开发能够打通软件开发的各个环节，让开发中的沟通以及各步骤之间的连通性更好。
>
> ​        3、UML语言能够在所有软件开发中都起到作用，只是尤其在OO方法的软件开发中更易使用。

##### 3.1用例图

[在用例图。](### 用例图)



##### 3.2顺序图

[在顺序图。](### 顺序图（时序图）)



##### 3.3类图（领域概念模型）

[在类图。](### 类图（初步领域概念模型）)



#### 4.采用 OO 方法做需求分析

​    定义+对象建模（用例图<use case diagram>来确定系统的基本功能和边界等，为系统设计做一定准备）+ 素描式类图<class hierarchy diagram>+数据流图<data flowdiagram>+场景（用自然语言描述过程逻辑，所有的条件或约束）。

核心理解（要点）：

​        1、传统方法由于开发工程师不同，面对问题情况不同，以及对问题的语义结构分析也不同，因此需求分析中问题建模上需要采用的方法也不同（根据看待问题的角度不同）。有时借助用例图、有时借助自然语言等，因此对于需求分析过程中的问题建模没有一个统一的方法。

​        2、OO有全开发过程的一致性特征。在开发的一整个过程中，OO采用类这一种语义结构去描述并解决所有问题。因此在OO需求分析中，由于统一的问题语义结构，需求分析也将有相同的流程。

需求分析完整过程：

​        用户给出问题定义——用户和分析师一起设计用例图为问题建模——软件设计师根据用例图建立类图指导开发——软件开发者根据类图、用例图去详细规划数据流图来确认每一类间的具体数据流动（函数设计）——共同商讨约束、资源等场景描述 

#### 5.采用OO方法做设计

##### 5.1OO 设计原则

​    面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，设计原则主要有以下七个：

​    ①单一职责原则
​    ②重用原则
​    ③开闭原则
​    ④替换原则
​    ⑤依赖倒置原则
​    ⑥接口隔离原则
​    ⑦迪米特法则

##### 5.2OO设计模式 

​    设计模式的定义：软件设计过程中，涉及到的常用问题，以及解决这些问题的方案和核心内容

​    总体来说设计模式分为三大类：

​    创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

​    结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

​    行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

##### 5.3采用OO方法做编码和测试

一般软件开发中编码测试部分的方法还没有介绍，因此这里不展开OO方法软件开发中的编码测试方法。



### 第七章：编写程序

​		这一章节在整体软件工程中属于代码实现这一过程的方法论，即给程序员的指导手册。不同于学生时代的单打独斗，进入公司后程序员需要合作一起完成一个项目的编程工作，这就需要有一定的标准和规范来让程序员编写的代码易于理解以提高沟通效率，方便合作；需要一定的编程指导原则来实现设计人员的设计；需要形成内外部文档便于团队内的长久沟通；需要了解不同的编程过程来提高生产效率。我们看到，这就是程序实现人员的工作职责和项目负责人对他们的殷切期望：在团队合作的背景下，高效地实现设计文档的内容。
​        从课程的角度，由于软件工程这门课侧重于整体的工程流程，而这章大多关注于编程实现，在其他课程中有所涉及，所以这一章的考察点主要在于概念理解上。

为什么说编程工作是复杂甚至令人气馁（daunting）的任务？
        （1） 设计人员可能没有处理平台和编程环境的所有特性，易于用图表示的结构和关系并不是总能直截了当的编写代码。
        （2） 编写易于理解的代码
        （3） 编写的代码要易于重用
        （4） 需要比照着设计进行检查

外界原因：程序员需要掌握工具和集成环境的特性。

内部原因：

1、需求分析、设计后得到的文档不能直接转化为代码。用图、文字表达的结构和关系不一定能一直转成代码；

2、代码不一定符合标准（重用和复用、易于理解）；

3、需要复审去检查代码和设计文档

#### 1.编程标准和步骤

​    不同于学习阶段的独立开发，公司中开发项目需要多人协同合作，编程标准和步骤就是公司们要求公司的代码符合某种风格，格式和内容标准。这样代码和相关的文档对每一个读者就会非常清晰。

核心思想：

​        1、编写程序=代码编写+文档书写

​        2、团队合作中编写程序需要按照某些特定的标准/风格，便于交流分析。

##### 1.1编程标准对自身的作用

​    （1） 帮助自己组织想法，避免错误。
​    （2） 一些过程包括编写代码文档的方法，使得它更清晰且易于遵循
​    （3） 有助于将设计转化成代码（维护设计构件和代码构件的一致性）。

编程标准包括：代码标准 和 文档标准

作用有三部分：开始（便于代码编写）、中间（减少代码错误）、结束（便于文档书写）

##### 1.2编程标准对他人的作用

（1）易于维护（2）易于测试（3）易于重用

这三点就是软件开发后期，以及软件生命周期后期很重要的三部分。

##### 1.3设计与编程实现相匹配

​    （1） 在程序设计构件和程序代码构件间建立起直接的对应关系是最关键的标准。
​    （2） 设计诸如低耦合，高内聚，定义明确等特性的接口。

编程实现必须要和设计相匹配，而不是简单随便的编写代码。

具体实现包括：

​        1、代码构件和设计构件建立直接对应关系

​        2、代码构件要符合设计原则以及设计模式（低耦合高内聚等）

#### 2.编程的指导原则

编程中我们主要思考：数据结构、算法和控制结构（状态转变）。

因此，指导原则也是针对这三者展开的。

##### 2.1数据结构

​    编写程序时，应该安排数据的格式并进行存储，这样的数据管理和操作才能简明易懂。

##### 2.2算法

​    设计时通常会指定一类算法，编程时遵循。
​    选择算法时要在执行时间，设计质量，标准和客户需求之间平衡考虑。
​    编写某种算法时所涉及的问题
​    （1）编写更快代码的代价。可能会是代码更加复杂，从而要花费更多的时间编写代码
​    （2）测试代码的时间代价。代码的复杂度要求有更多的测试用例或测试数据

​    （3）用户理解代码的时间代价。
​    （4）需要修改代码时，修改代码的时间代价。

好处：设计质量越高，程序执行时间越短。

坏处：编程所花费时间越长，测试代码所需的时间越长，用户理解代码的时间越长，修改代码所花费时间越长 

##### 2.3控制结构

​    当设计转变成代码时，我们希望保留组件的控制结构，在隐含调用的面向对象设计中，控制是基于系统状态和变量而变化的。
​    代码重组，模块化代码，注意构件通用性，注释里体现代码耦合，提高代码内聚度。

目的：1、提高设计和代码的联系度；2、提高代码本身的质量

​        1、代码重组

​        2、模块化代码

​        3、构件通用性

​        4、让耦合性和依赖是可见的

​        5、提高代码内聚度

##### 2.4通用编程策略

​    （1） 局部化输入和输出（单独设计 IO），更加易于维护。
​    （2） 设计阶段包含伪代码
​    （3） 改动时从需求改动，重新设计，重新编码，不要打补丁
​    （4） 重用

#### 3.文档化

##### 3.1内部文档

​    内部文档包含的信息是面向阅读程序源码的那些人的，因此它提供概要信息以识别程序，描述数据结构，算法和控制流。包含：

（1） 头注释块（header comment block，HCB）
        将一组注释信息放在每个构件的开始部分，包含构件名，作者，配置在整个系统设计的哪个部分上，何时编写和修改的，为什么要有该构件，构件是如何使用数据结构，算法和控制的。

（2） 其他程序注释

​    包含：
​            a. 可以对程序正在做什么提供逐行的解释。
​            b. 将代码分解成表示主要活动的段，每个活动再分解成更小的步骤。

​            c. 随着时间进行修改的记录。

（3） 有意义的变量名和语句标记
        命名时尽量用有意义的变量名进行命名

（4） 安排格式以增强理解
        注意缩进和间隔来反映基本的控制结构。

 内部文档包括：变量名整理、一般程序解释、程序组成构件解释、合理格式反映控制结构

##### 3.2外部文档

​    外部文档的内容面向不看实际代码的人，如设计人员考虑修改或改进时；它在系统层面回答问题。

#### 4.编程过程

##### 4.1编程作为求解过程

​    分为四步：理解问题，制定计划，执行计划，回顾

##### 4.2极限编程（Extreme Programming，XP）

​    极限编程是敏捷过程的一种具体形式，提供敏捷方法最一般原则的指导方针。XP 的支持者强调敏捷方法的 4 个特性：交流、简单性、勇气以及反馈。
​    交流是指客户与开发人员之间持续地交换看法；简单性激励开发人员选择最简单的设计或实现来处理客户的需要；勇气体现在尽早地和经常交付功能的承诺；在软件开发过程中的各种活动中，都包含反馈循环。例如，程序员一起工作，针对实现设计的最佳方式，相互提供反馈；客户和程序员一起工作时，以完成计划的任务。

极限编程的两类参与者：

客户：

​            （1）定义程序员将要实现的系统特征，使用故事的形式描述系统工作的方式
​            （2）描述测试计划，验证是否实现了所描述的故事
​            （3）为故事及其测试分配优先级

  程序员：
             将客户需求予以编程实现

客户：描述需求+描述测试计划

程序员：实现需求并通过测试

##### 4.3派（结）对编程

​    结对编程属于主要的敏捷开发方法，开发方式是两个程序员共同开发程序，且角色分工明确：一个负责编写程序，另一个负责复审和测试，两个人定期交换角色。

​    优点：提高生产率和质量，但证据不充分，模棱两可
​    缺点：会抑制问题求解的基本步骤，扰乱对问题的关注



### 第八章：单元/集成测试程序

#### 1.故障和失效

   为什么我们需要测试，因为程序不可避免的存在故障和失效的情况。为了减少程序在交付后故障和失效情况的出现（那时修改代价很大），我们需要在程序开发完成后，程序交付前对程序进行测试，看看程序是否符合我们的期待。

​    测试的目的是发现错误而非证明正确性（假设软件系统存在错误）。

##### 1.1故障（falut）

​    故障（falut）的定义：由错误（error）引起的系统内在问题。【着眼于软件运行】

​    故障出现的原因：
​            (1)软件本身，系统处理大量的状态，复杂的公式，活动，算法等；

​            (2)客户不清晰的需求；

​            (3)其他原因，如项目的规模，众多的参与者导致的复杂性。

##### 1.2失效（failure）

​    失效的定义：软件的动作与需求描述的不相符。【着眼于用户使用】

​    造成失效的原因：
​            (1)错误的规格说明，或者遗漏了一些需求；
​            (2)对于指定的硬件和软件，说明中存在一些无法完成的实现；

​            (3)错误的系统设计；
​            (4)错误的程序设计，错误的实现。
​    故障的识别(fault identification)：是确定由哪一个或者哪些故障引起失效的过程。
​    故障改正(fault correction)或故障去除(fault removal)：修改系统使得故障得以去除的过程。

##### 1.3故障的分类

为什么对故障进行分类：

​        1、错误是程序员犯的，难以预知（他如果知道，他也不会犯错啦😂）

​        2、故障是错误的外在表现，很直观可见。

​        3、失效是用户使用中发现的，这个时候才知道就不好了。

​    分类的原因：知道正在处理的是什么类别的故障对于我们具体的测试，以及之后的故障改正都是有很大帮助的。

​    具体分类：

​        (1)算法故障(algorithmic fault)：由于处理步骤中的某些错误，使得对于给定的输入，构件的算法或逻辑没有产生适当的输出。
​        (2)计算故障(computation fault)或精读故障(precision fault)：一个公式的实现是错误的，或者计算结果没有达到要求的精度。
​        (3)文档故障(documentation fault)：文档与程序实际做的事情不一致。（倾向于相信文档）
​        (4)过载故障(overload fault)：对队列长度、缓冲区大小、表的维度等的使用超出了规定的能力。（数据上不可接受）
​        (5)能力故障(capacity fault)：系统活动到达指定的极限时，系统性能会变得不可接受。（用户数量、活动数量不可接受）
​        (6)时序故障(timing fault)：几个同时执行或仔细定义顺序执行的进程之间细条不适当。
​        (7)性能故障(performance fault)：系统不能以需求规定的速度执行。
​        (8)恢复故障(recovery fault)：当系统失效时，不能表现得像设计人员希望的或客户要求的那样。
​        (9)硬件和系统软件故障(hardware and system software fault)：当提供的硬件或者系统软件实际上并没有按照文档中的操作条件或步骤运作时。
​        (10)标准和过程故障(standards and procesure fault)：代码没有遵循组织机构的标准和过程。

##### 1.4正交缺陷分类

​    定义：被分类的任何一项故障都只属于一个类别，则分类方案是正交的。如果一个故障属于不止一个类，则失去了度量的意义。

上面提出的故障类型（fault type）一定要是彼此正交的。



#### 2.测试之前应该明确的几个问题

##### 2.1测试分类

​    (1)单元测试(unittesting)：将每个程序构件与系统中的其他构件隔离，对其本身进行测试。
​    (2)集成测试(integration testing)：验证系统构件是否能够按照系统和程序设计规格说明中描述的那样共同工作的过程。
​    (3)功能测试(function test)：对系统进行评估，以确定集成的系统是否确实执行了需求规格说明中描述的功能，其结果是一个可运转的系统。
​    (4)性能测试(performance test)：测试系统的软硬件性能是否符合需求规格说明文档。其结果是一个确认的系统。
​    (5)验收测试(acceptance test)：确定系统是按照用户的期望运转的。
​    (6)安装测试(installation test)：确保系统在实际环境中按照应有的方式运转。

> 系统测试(system test)：功能测试、性能测试和安装测试统称为系统测试。



##### 2.2测试的态度

- 正确的态度应该是将测试看成是一个发现的过程。
- 不仅仅将程序视作问题的解决方案，同样考虑问题本身是否存在问题。
- 当出现故障或者失效的时候，关注的是修改故障，而不是谴责某个开发人员。

##### 2.3谁执行测试——独立的测试团队

-  开发人员可能担心发现系统故障影响自己的业绩，独立的测试团队避免了故障的个人责任与尽可能多的发现故障的需要之间的冲突；
-  独立团队因为和代码不是太过紧密，所以能更加的客观，有更多的机会发现细微的故障；
-  独立的测试团队可以参与软件开发的整个过程，测试可以和编码并行的进行。

##### 2.4测试的方法

黑盒：

​    将测试的对象看作是一个不了解其内容的闭盒（不了解内部结构），我们的测试就是向闭盒提供输入的数据，并记录产生的输出。测试的目标是确保针对每一种输入，观察到的输出与预期的输出相匹配。黑盒测试参考的文档是系统设计和程序设计阶段的文档。
​     优点：黑盒测试免于受强加给测试对象内部结构和逻辑的约束。更偏向于功能性的测试。

​     缺点：黑盒法以 SRS 为依据，有一定的盲目性和不确定性，不可能揭示所有的错误。没办法总是使用这种方式进行完备的测试。不容易找到具有代表性的测试用例证明所有情况下功能都正确。

> 黑盒测试的核心思想是 忽视内部实现，集中测试系统的功能性，确保系统按预期的方式工作，主要聚焦于 外部表现 和 用户需求。



白盒：

​    将测试对象看作一个白盒，然后根据测试对象的结构用不同的方式进行测试。

​    优点：可以测试一个模块的细节。
​    缺点：该法以模块内部逻辑为依据，当内部逻辑过于复杂时，则不能给出好的或合适的测试用例。有时候，对于大量递归、循环和分支的构件，想要测试完所有的分支也是不现实的。

实际测试中：

没有必要把黑盒测试和白盒测试严格的区分开来。具体测试方法的选择受到很多因素的响。



#### 3.单元测试

##### 3.1检查代码（通过代码复审）

​    代码复审(code review)：由一个客观的专家组进行（代码复审），审查代码及其文档，查找误解、不一致性、性能问题和其他缺陷。

​    代码复审(code review)包括：代码走查(code walkthrough)和代码检查(code inspection)。代码走查非正式，代码审查相对正式，会事先准备关注问题清单，依据它比对代码和文档的一致性。

​	代码复审带来的好处：一个故障在开发过程中发现的越早，它就越容易纠正，所造成的损失也就越小。复审在检测故障方面表现得格外成功。

##### 3.2测试程序构件

​    测试用例(test case)：用于测试程序的输入数据的一个特定选择。

​    测试的完全性：以一种使人信服的方式来证明测试数据展现了所有可能的行为。

​	(1)制定测试目标

​	(2)设计测试计划

​	(3)编写测试用例

​	(4)测试测试用例

​	(5)执行测试 

​	(6)评估测试结果

> 1、测试计划：描述我们将以何种方式向用户证明软件运转正确。制定测试计划的时候要充分的了解需求、功能规格说明、系统设计和代码的模块层次结构。测试计划是随着系统本身的开发而制定的。
>
> 2、计划内容：针对测试的每一个阶段，测试计划详细描述执行每一步所使用的方法。每一种测试方法或技术还要附有一份详细的测试用例列表。测试计划的内容就是描述我们如何测试以及为什么执行测试。

##### 3.3黑盒测试方法

​    (1)等价分类法：将输入域划分为若干等价类。每一个测试用例都代表了一类与它等价的其他例子。如果测试用例没有发现错误，那么对应的等价例子也不会发生错误。有效等价类的测试用例尽量公用，以此来减少测试次数，无效等价类必须每类一个用例，以防止漏掉可能发现的错误。
​    (2)边界值分析法：在等价分类法中，代表一个类的测试数据可以在这个类的允许范围内任意选择。但如果把测试值选在等价类的边界上，往住有更好的效果，这就是边界值分析法的主要思想。
​    (3)错误猜测法：猜测程序中哪些地方容易出错，并据此设计测试用例。更多的依赖于测试人员的直觉和经验。

​    (4)因果图法：适用于被测试程序有很多输入条件，程序的输出又依赖输入条件的各种组合的情况。

##### 3.4白盒测试方法

​    (1)语句(覆盖)测试：在某次测试中，构件中的每条语句至少执行一次。
​    (2)分支测试：对代码中的每个判断点，每个分支在某次测试中至少选择一次。（每个分支都有一次就可以，不两两都组合过）

​    (3)路径测试：通过代码的每一条不同路径在某个测试中至少执行一次。（不仅每个分支都要走过一次，而且两两都要组合过）

注意：一般来说，语句测试使用的测试用例最少，分支测试较多，路径测试最多。



#### 4.集成测试——得到一个正常运作的系统。

##### 4.1自底向上的集成

​    1.含义：使用这种测试方法的时候，每一个处于系统层次中最底层的构件先被单独测试，接着测试的是那些调用了前面已测试构件的构件。反复采用这种方法，直到所有的构件测试完毕。
​    **2.构件驱动程序：代替上级模块传递测试用例的程序。**
​    3.优点：测试用例比较容易生成；符合面向对象的开发思路。
​    4.缺点：顶层构件通常是最重要的，但是却是最后测试的。主要故障的测试将会推迟到测试的后期。（越到后期的故障越难处理）。

##### 4.2自顶向下的集成

​    1.含义：顶层构件通常是一个控制构件，是独立进行测试的。然后将被测构件调用的所有构件组合起来，作为一个更大的单元进行测试。重复这样的操作直到所有的构件都被测试。

​    **2.桩(stub)：代替下级模块的仿真程序**
​    3.优点：一些功能性的设计故障或主要问题可以在测试的早期进行处理。
​    4.缺点：桩不容易编写，桩的正确性可能影响测试的有效性；另一个缺点是可能需要大量的桩。

这个模式下，桩需要能够完美代替下级模块的输出，这要求我们需要知道系统中每一个模块的正确输出，从而完成对上级模块的测试。这就导致测试用例的编写很有难度。

##### 4.3一次性集成

​    1.先测试每一个构件，然后将所有的构件一次性的集成。只适用于小型系统
​    2.缺点：

​            1、有些构件同时需要桩和驱动程序；

​            2、一次性集成，很难发现失效原因；

​            3、很难将接口故障和其他故障区分开。

##### 4.4三明治集成

​    含义：将系统分成三层，目标层处于中间、目标层上有一层，目标层下有一层。在顶层采用自顶向下的方式集成，在较低层采用自底向上的方式集成。测试集中于目标层。



#### 5.确认测试

1. ‌**测试目的**‌

- ‌**确认测试**‌：验证软件是否与用户需求、业务目标及需求规格说明书一致，确保其功能、性能等符合预期‌。

2. ‌**测试内容**‌

- 聚焦功能实现、性能指标、兼容性及安全性验证，重点检查是否覆盖需求规格说明书中的全部要求。
- 通过黑盒测试方法模拟用户操作场景，发现需求分析阶段的潜在问题‌。

3. ‌**执行阶段**‌

- ‌**确认测试**‌：在集成测试完成后、验收测试前执行，属于开发周期的倒数第二阶段，由开发团队或第三方机构完成‌。

4. ‌**执行主体**‌

- ‌**确认测试**‌：通常由开发团队或第三方测试机构执行，侧重于技术细节验证‌。

5. ‌**测试重点**‌

- ‌**确认测试**‌：强调“软件是否被正确构建”（是否符合需求文档）。



#### 6.验收测试

1. ‌**测试目的**‌

**验收测试**‌：确保软件达到可交付标准，由用户验证其在实际使用场景中是否满足合同或业务要求，是软件部署前的最终验证环节‌。

2. ‌**测试内容**‌

**验收测试**‌：

- 包含功能完整性、用户界面交互、数据管理及系统稳定性等全面检查，关注实际业务场景的适用性‌。
- 通常包括性能测试（如高负载响应）和安全测试（如权限管理漏洞排查）。

3. ‌**执行阶段**‌

**验收测试**‌：部署前的最终测试，由用户或客户主导，可能涉及第三方机构参与，以确认软件满足交付标准‌。

4. ‌**执行主体**‌

**验收测试**‌：由用户、客户或利益相关方主导，注重用户实际体验和业务匹配度。

5. ‌**测试重点**‌

**验收测试**‌：强调“软件是否被正确使用”（是否满足实际业务需求）。



#### 6.测试面向对象的系统

软件开发有很多方法，面向对象开发方法是其中最重要的方法，原因如下：

- 语言一致性
- 全开发过程一致性

​    因为这两个特性，在软件开发的所有步骤中都可以使用面向对象方法，并且自成一个开发体系。这个开发体系在软件开发质量标准中都非常高（耦合性低、内聚性高、性能好等） 。

​    传统测试和面向对象测试的区别：

​            (1)测试用例的不可重用性：对过程语言而言，当系统改变时，我们可以针对改变测试是否正确，并使用原有的测试用例来验证剩余的功能是否同原来一致。但是面向对象的测试中，我们可能需要编写不同的测试用例。
​            (2)面向对象趋向于小粒度，并且平常存在于构件内的复杂性常常转移到构件之间的接口上。这意味着，其单元测试较为容易，但是集成测试涉及面变得更加广泛。
​            (3)传统测试和面向对象的测试主要集中在：需求分析和验证、测试用例生成、源码分析和覆盖分析。



#### 7.软件测试阶段详解

软件测试通常分为四个核心阶段，各阶段目标、方法及工具存在显著差异，以下为详细解析：

------

##### ‌**一、单元测试（Unit Testing）**‌

1. ‌**定义与目的**‌
   - ‌**目标**‌：验证代码中最小可测试单元（如函数、类）的功能正确性，关注代码内部逻辑与边界条件‌。
   - ‌**测试主体**‌：开发人员主导，通常伴随编码过程进行‌。
2. ‌**测试方法**‌
   - ‌**白盒测试为主**‌：使用逻辑覆盖技术（如语句覆盖、路径覆盖）设计测试用例‌。
   - ‌**自动化工具支持**‌：通过框架（如JUnit、PyTest）实现快速执行与结果验证。
3. ‌**典型场景与工具**‌
   - ‌**场景**‌：验证算法逻辑、异常处理等；
   - ‌**工具**‌：JUnit（Java）、PyTest（Python）、NUnit（.NET）。

------

##### ‌**二、集成测试（Integration Testing）**‌

1. ‌**定义与目的**‌
   - ‌**目标**‌：验证模块/组件间的接口交互正确性，检测数据传递、调用逻辑等问题‌。
   - ‌**测试主体**‌：开发或测试团队协作，常在单元测试完成后开展‌。
2. ‌**测试方法**‌
   - ‌**灰盒测试结合**‌：部分关注接口输入输出（黑盒），部分分析调用链路（白盒）。
   - ‌**策略**‌：增量式集成（自顶向下/自底向上）、大爆炸集成等。
3. ‌**典型场景与工具**‌
   - ‌**场景**‌：验证API调用、数据库交互、服务间通信；
   - ‌**工具**‌：Postman（API测试）、TestNG（集成测试框架）。

------

##### ‌**三、系统测试（System Testing）**‌

1. ‌**定义与目的**‌
   - ‌**目标**‌：验证完整系统是否符合需求规格说明书，覆盖功能、性能、安全性等全维度‌。
   - ‌**测试主体**‌：独立测试团队主导，模拟真实用户场景‌。
2. ‌**测试方法**‌
   - ‌**黑盒测试为主**‌：通过等价类划分、边界值分析设计用例，关注功能实现。
   - ‌**测试类型扩展**‌：兼容性测试、性能测试（如负载测试）、容错性测试等‌。
3. ‌**典型场景与工具**‌
   - ‌**场景**‌：验证用户注册流程、支付功能稳定性、多浏览器兼容性；
   - ‌**工具**‌：Selenium（Web UI自动化）、JMeter（性能测试）。

------

##### ‌**四、验收测试（Acceptance Testing）**‌

1. ‌**定义与目的**‌
   - ‌**目标**‌：确保软件满足最终用户需求，通常作为上线前的最终验证‌。
   - ‌**测试主体**‌：用户或客户代表参与，验证业务场景的完整性与易用性‌。
2. ‌**测试方法**‌
   - ‌**黑盒测试为主**‌：基于用户手册或合同需求设计测试用例‌。
   - ‌**形式**‌：α测试（内部模拟）、β测试（真实用户环境）‌。
3. ‌**典型场景与工具**‌
   - ‌**场景**‌：验证订单全流程、报表生成准确性；
   - ‌**工具**‌：Cucumber（行为驱动开发工具）、用户验收测试（UAT）清单‌。

------

##### ‌**五、各阶段核心对比**‌

| ‌**维度**‌     | ‌**单元测试**‌  | ‌**集成测试**‌    | ‌**系统测试**‌     | ‌**验收测试**‌       |
| ------------ | ------------- | --------------- | ---------------- | ------------------ |
| ‌**测试范围**‌ | 代码单元      | 模块/组件接口   | 完整系统         | 用户需求与业务流程 |
| ‌**主导角色**‌ | 开发人员      | 开发/测试团队   | 测试团队         | 用户/客户代表      |
| ‌**测试方法**‌ | 白盒为主      | 灰盒结合        | 黑盒为主         | 黑盒为主           |
| ‌**典型工具**‌ | JUnit、PyTest | Postman、TestNG | Selenium、JMeter | Cucumber、UAT清单  |

------

##### ‌**六、实践意义**‌

1. ‌**全生命周期覆盖**‌：从代码级验证到用户级验收，逐层排除缺陷，降低修复成本‌。
2. ‌**质量保障体系**‌：单元测试确保代码健壮性，系统测试验证全局功能，最终通过验收测试实现用户价值‌。

#### 8.软件测试的别名总结

##### 一、‌**通用测试类别别名**‌

1. ‌**功能测试**‌
   - 别名：‌**黑盒测试**‌（关注输入输出，不涉及代码逻辑）。
2. ‌**结构测试**‌
   - 别名：‌**白盒测试**‌（基于代码逻辑验证）。

------

##### 二、‌**测试阶段别名**‌

1. ‌**单元测试**‌
   - 别名：‌**模块测试**‌、‌**逻辑测试**‌（验证最小代码单元）。
2. ‌**集成测试**‌
   - 别名：‌**组装测试**‌、‌**联合测试**‌（验证模块间接口）。
3. ‌**系统测试**‌
   - 别名：‌**完整系统验证**‌（覆盖软硬件及用户场景）‌。
4. ‌**验收测试**‌
   - 别名：‌**交付测试**‌（验证用户需求符合性）‌。

#### 9.白盒测试与黑盒测试方法详解

------

##### ‌**一、白盒测试方法**‌

1. ‌**静态分析方法**‌
   - ‌**代码检查法**‌：人工或工具辅助检查代码语法、规范及潜在错误（如未初始化变量）。
   - ‌**静态结构分析**‌：通过控制流图、数据流图分析程序结构，检测逻辑复杂度与异常调用路径。
   - ‌**代码质量度量**‌：评估代码复杂度、耦合度等指标，辅助优化代码可维护性‌。
2. ‌**动态分析方法**‌
   - ‌**逻辑覆盖法**‌：
     - ‌**语句覆盖**‌：确保每条语句至少执行一次。
     - ‌**分支/判定覆盖**‌：验证每个逻辑分支的真假结果均被覆盖。
     - ‌**条件组合覆盖**‌：覆盖所有条件判断的组合情况（如多条件嵌套）。
   - ‌**基本路径测试**‌：通过程序控制流图生成独立路径，验证循环和复杂逻辑‌。
   - ‌**程序插装**‌：插入监控代码，动态追踪变量状态和执行路径‌。
3. ‌**其他技术**‌
   - ‌**域测试**‌：针对变量取值范围设计测试用例，验证边界和异常输入‌。
   - ‌**符号测试**‌：用符号代替具体输入值，推导程序执行路径的约束条件‌。

------

##### ‌**二、黑盒测试方法**‌

1. ‌**基于输入域的方法**‌
   - ‌**等价类划分**‌：将输入数据划分为有效/无效类别，减少冗余测试用例‌。
   - ‌**边界值分析**‌：针对输入范围的边界值（如最小值、最大值）设计测试数据‌。
2. ‌**基于场景与逻辑的方法**‌
   - ‌**因果图法**‌：通过输入条件的组合推导输出结果，覆盖复杂逻辑场景‌。
   - ‌**判定表驱动法**‌：将因果图转换为判定表，明确输入条件与动作的对应关系‌。
   - ‌**正交实验设计**‌：利用正交表生成最优组合测试用例，减少测试规模‌。

------

##### ‌**三、核心方法对比**‌

| ‌**测试类型**‌ | ‌**典型方法**‌                         | ‌**适用场景**‌               |
| ------------ | ------------------------------------ | -------------------------- |
| ‌**白盒测试**‌ | 逻辑覆盖、静态结构分析、基本路径测试 | 单元测试、代码逻辑缺陷检测 |
| ‌**黑盒测试**‌ | 等价类划分、边界值分析、因果图法     | 系统功能验证、用户场景模拟 |

------

##### ‌**四、方法选择与实践建议**‌

1. ‌**白盒测试适用场景**‌
   - 高安全性系统（如金融算法）需覆盖所有代码路径‌。
   - 开发阶段快速定位代码逻辑错误（如死循环、内存泄漏）。
2. ‌**黑盒测试适用场景**‌
   - 用户需求验证（如电商下单流程）。
   - 复杂业务逻辑的组合测试（如多条件触发规则）。
3. ‌**综合策略**‌
   - ‌**单元测试阶段**‌：白盒为主（逻辑覆盖+代码检查）。
   - ‌**系统测试阶段**‌：黑盒为主（等价类+场景法）‌。
   - ‌**性能测试**‌：黑盒工具（如JMeter）结合白盒代码分析（如内存泄漏检测）‌。

#### 10.黑盒测试与白盒测试方法举例说明

------

##### ‌**一、黑盒测试方法及示例**‌

1. ‌**等价类划分法**‌
   - ‌**方法**‌：将输入数据划分为有效/无效等价类，选取代表值测试。
   - ‌**示例**‌：测试用户登录功能时，将密码输入域划分为：
     - 有效等价类：6-18位字母数字组合；
     - 无效等价类：5位（不足）、19位（超长）、含特殊字符。
2. ‌**边界值分析法**‌
   - ‌**方法**‌：针对输入域的边界值（如最小值、最大值）设计用例。
   - ‌**示例**‌：验证年龄输入框（允许1-120岁）：
     - 测试值：0、1、2、119、120、121。
3. ‌**因果图法**‌
   - ‌**方法**‌：分析输入条件与输出结果的逻辑关系，生成判定表。
   - ‌**示例**‌：电商平台优惠券使用规则：
     - 条件：用户等级（普通/VIP）、订单金额≥100元；
     - 结果：允许使用优惠券。
     - 组合测试：普通用户+99元（无效）、VIP+150元（有效）。
4. ‌**正交试验法**‌
   - ‌**方法**‌：利用正交表减少多因素组合的测试用例数量。
   - ‌**示例**‌：测试文件上传功能，涉及浏览器（Chrome、Firefox）、文件类型（图片、PDF）、网络（WiFi、4G）：
     - 正交表选择代表性组合，如（Chrome+图片+WiFi）、（Firefox+PDF+4G）。

------

##### ‌**二、白盒测试方法及示例**‌

1. ‌**语句覆盖**‌

   - ‌**方法**‌：确保程序每条语句至少执行一次。

   - ‌**示例**‌：以下代码片段：

     ```python
     if x > 0:  
         print("正数")  
     else:  
         print("非正数")  
     ```

     - 测试用例：x=1（覆盖`print("正数")`）、x=-1（覆盖`print("非正数")`）。

2. ‌**判定覆盖（分支覆盖）**‌

   - ‌**方法**‌：覆盖每个逻辑判断的真/假分支。

   - ‌**示例**‌：验证用户权限检查逻辑：

     ```java
     if (user.isAdmin()) {  
         grantAccess();  
     } else {  
         denyAccess();  
     }  
     ```

     - 测试用例：管理员账号（`isAdmin=true`）、普通账号（`isAdmin=false`）。

3. ‌**条件组合覆盖**‌

   - ‌**方法**‌：覆盖多条件判断的所有可能组合。
   - ‌**示例**‌：登录逻辑需同时满足“用户名非空”且“密码长度≥6”：
     - 组合1：用户名空 + 密码5位（无效）；
     - 组合2：用户名非空 + 密码6位（有效）。

4. ‌**基本路径测试**‌

   - ‌**方法**‌：通过控制流图生成独立路径，验证循环和复杂逻辑。

   - ‌**示例**‌：循环计算阶乘的代码：

     ```c
     int factorial(int n) {  
         int result = 1;  
         for (int i=1; i<=n; i++) {  
             result *= i;  
         }  
         return result;  
     }  
     ```

     - 测试路径：n=0（不进入循环）、n=3（循环执行3次）。

------

##### ‌**三、核心方法对比**‌

| ‌**测试类型**‌ | ‌**方法**‌     | ‌**典型工具/技术**‌                   | ‌**适用场景**‌               |
| ------------ | ------------ | ----------------------------------- | -------------------------- |
| ‌**黑盒测试**‌ | 等价类划分   | 需求文档、Excel用例表               | 用户功能验证（如表单提交） |
| ‌**白盒测试**‌ | 条件组合覆盖 | JUnit（Java）、Coverity（静态分析） | 高安全性系统（如支付逻辑）‌ |





### 第九章：系统测试（因果图全解析）

 系统测试与单元测试和集成测试的不同在于，系统测试需要与整个开发团队一起工作、协调你做的工作并且接受测试小组组长的指导；而单元测试时你可以完全控制测试过程——自己设计测试数据、测试样例、运行测试；集成构件时，虽然有时独自工作，但通常是测试小组或者开发团队的一些人合作。在本章内，我们将会讨论测试系统所包含的功能测试、性能测试、验收测试、安装测试。

> 系统测试将是一整个测试团队+开发团队的共同任务



#### 1.系统测试综述 

##### 1.1软件缺陷的来源

软件缺陷可能存在于软件设计开发过程中的任何一个部分。其中：
        (1)需求分析：不正确、遗漏或者不清晰的需求；
        (2)系统设计：对需求设计的误读，不正确或不清晰的设计规格说明；

​    	(3)程序设计：对系统设计的误读，不正确或不清晰的设计规格说明；
   	 (4)程序实现：对程序设计的误读，不正确的文档，不正确的语法语义；

​		(5)单元/集成测试：不完全的测试过程，改正已有故障时引入新故障；

​    	(6)系统测试：不完全的测试过程，改正已有故障时引入新故障；
​    	(7)维护：需求变化，错误的用户文档，负面的人为因素，改正已有故障时引入新故障。



##### 1.2系统测试的目的

​    (1)测试过程应该有足够的完全性，如果测试过程是不全面的，故障仍可能检测不到，所以越早检测出故障越好，早期检测出的故障更容易改正；
​    (2)测试过程应该使每一个人都对系统功能感到满意，包括用户、客户和开发人员，因为在大型系统中，必定会存在一些用户允许存在的，当时不必修复的缺陷存在。

##### 1.3系统测试的主要步骤及目标

​    (1)功能测试——核查开发者的SRS（系统功能需求）
​    (2)性能测试——核查开发者的SRS（其他软件需求）
​    (3)验收测试——核查客户和开发者的SRS（用户需求定义）
​    (4)安装测试——用户环境



#### 2.系统配置

##### 2.1系统配置定义

​    向特定客户交付的一系列部件的集合（产品）。

> 每一个系统配置都是一个针对特定用户的产品 



##### 2.2配置管理

​    对系统不同软件配置的管理及控制方法（其中既有开发，也有测试）。通过控制系统差别以降低风险，减少错误。它的重要性在于它协调测试人员与开发人员之间的工作，从而获取有效配置。

##### 2.3配置管理计划

​    SCM 流程旨在确保在任何时候产品的内容都是已知的、可用的，以及在设计到实施的过程中，产品的功能都是可跟踪的，可以完全控制和保护产品的内容。 

换句话说：就是通过文档等方式对软件开发全过程中发生的所有事情进行跟踪。 

制订配置管理计划的主要步骤如下：

​    （1）建立并维护配置管理的组织方针

​    （2）确定配置管理需使用的资源

​    （3）分配责任

​    （4）培训计划

​    （5）确定“配置管理”的项目干系人，并确定其介入时机

​    （6）制订识别配置项的准则

​    （7）制订配置项管理表

​    （8）确定配置管理软硬件资源

​    （9）制订基线计划

​    （10）制订配置库备份计划

​    （11）制订变更控制流程

​    （12）制订审批计划

##### 2.4配置计划的必要性

如果不使用适当的配置管理计划，我们就经常无法知道哪一个模块是被确定、增强或测试过的。
我们会开发出功能错误或是缺少功能的产品来，而且我们不知道哪些测试正在进行，哪些缺陷已被确定。
我们不得不重新整理已经完成了的工作。

##### 2.5管理计划对系统测试的目标

​    迅速准确地进行测试。

##### 2.6基线

​    软件文档和其他资料的集合，它们代表了产品在某一时间点的情况(以及其他参考点)。

##### 2.7配置管理计划关键的功能

​        (1)每个产品元素（部件）版本的复件；
​        (2)对每一个基线修改的记录；（修改内容的说明：修改位置，修改时间，修改内容等）
​        (3)他们什么时候改变的；
​        (4)改变具体内容是什么；
​        (5)为什么他们要进行改变。
​        (6)可能涉及的其他功能等等(从涉及的基本文档开始统计)。

​        (7)谁进行了这个改变

##### 2.8版本(version)与改进版本/发布(release)定义

​    Version:针对特定系统的特定配置
​    Release:针对旧版本的改进版本
​    Version n.m=Version n and release m.



#### 3.回归测试

##### 3.1回归测试定义

   回归测试是软件开发过程中验证最近更改或更新是否引入新错误或影响原有功能的质量控制过程。（新旧测试用例同时进行测试）

新版本/改进版本是否仍然和旧版本一样以同样方式执行同样功能

##### 3.2测试小组关注人群

​    单元测试、集成测试：主要为开发者；
​    功能测试、性能测试：主要为开发者；
​    验收测试、安装测试：主要为用户；

（因此，程序员不能参与自己负责的模块相关的测试工作。）

##### 3.3测试小组组成

​    (1)专业测试人员：集中于测试开发、方法和过程；

​    (2)分析员：以需求创建者的立场参与测试；
​    (3)系统设计人员：了解系统运作，可以使测试工作更有目的性；
​    (4)配置管理代表：出现失效或变化请求时安排变动，使变动反映在文档、需求、设计、代码或者其他开发制品中。
​    (5)用户：对所发布的软件进行评估。



#### 4.功能测试

##### 4.1功能测试含义与作用

​    测试功能性需求（SRS的）
​    有很高的故障检测概率（因为一项功能测试只面向一小组组件）。

##### 4.2有效的功能测试指导原则

(1)高故障检测概率；
(2)使用独立于设计人员和程序员的测试小组；

(3)了解期望的动作和输出；
(4)既要测试合法输入，也要测试不合法输入；

(5)制定停止测试的标准。



#### 5.因果图

##### 5.1因果图定义

因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况
特点：
1.考虑输入条件的相互制约及组合关系
2.考虑输出条件对输入条件的依赖关系

##### 5.2因果图法产生的背景

等价类划分法和边界值分析法都是着重考虑输入条件，但没有考虑输入条件的各种组合，输入条件之间的相互制约关系，这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。
如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合，相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。

如果你没有考虑多个输入条件的 组合效果，那么可能会出现一些组合条件下的潜在错误，例如：

​    用户选择了负数的商品数量，且选择了信用卡支付方式。这时，如果系统没有验证“商品数量”与“支付方式”之间的逻辑关系（比如“商品数量”过大可能无法支付，或者支付方式限制了最大购买数量），系统可能会出现支付失败或价格错误等问题。
​    用户输入了一个非常远的收货地址（如偏远地区），而且选择了 支付宝支付。如果系统没有处理某些支付方式和地区限制的约束（比如某些支付方式不支持该地区的支付），可能会导致支付流程出错，而不是只在支付阶段处理支付信息错误。

##### 5.3因果图的核心

​	因果图法比较合适输入条件比较多的情况，测试所有的输入条件的排列组合，所谓的原因就是输入，所谓的结果就是输出。

- 因果图的“因“—输入条件
- 因果图的“果”—输出结果

因果图法要注意考虑：

- 所有输入/输出条件的相互制约关系以及组合关系
- 输入条件的依赖关系，也就是什么样的输入组合会产生怎么样的输出结果，即“因果关系”

##### 5.4因果图中的基本符号

​    通常在因果图中用Ci表示原因，用Ei表示结果，各结点表示状态，可取值‘0’或‘1’。‘0’表示某状态不出现‘1‘表示某状态出现。



![img](https://i-blog.csdnimg.cn/direct/a106100ee7a940339220eca0fa643313.png)



![img](https://i-blog.csdnimg.cn/direct/f69b3bd2ed1d4b58999ec6c4a8ead78e.png)



![img](https://i-blog.csdnimg.cn/direct/21cf8dedae714c6e9d4616772b665de4.png)

![img](https://i-blog.csdnimg.cn/direct/409f9367bb2845af94cdb7a1f24e9a9a.png)



##### 5.5因果图构件步骤

利用因果图导出测试用例需要经过一下几个步骤：

1. 找出所有的原因，原因即输入条件或输入条件的等价类。
2. 找出所有的结果，结果即输出条件。
3. 明确所有输入条件之间的制约关系以及组合关系。（哪些条件不能组合到一起，哪些条件可以组合到一起）
4. 明确所有输出条件之间的制约关系以及组合关系。（哪些输出结果不能同时输出，哪些输出结果可以同时输出）
5. 找出什么样的输入条件组合会产生哪种输出结果。
6. 把因果图转换成判定表/决策表

##### 5.6小案例·交通一卡通自动充值软件系统需求

- 系统只接收50或100元纸币，一次只能使用一张纸币，一次充值金额只能为50元或100元；
- 若输入50元纸币，并选择充值50元，完成充值后退卡，提示充值成功；
- 若输入50元纸币，并选择充值100元，提示输入金额不足，并退回50元；
- 若输入100元纸币，并选择充值50元，完成充值后退卡，提示充值成功，找零50元；
- 若输入100元纸币，并选择充值100元，完成充值后退卡，提示充值成功；
- 若输入纸币后在规定时间内不选择充值按钮，退回输入的纸币，并提示错误；
- 若选择充值按钮后不输入纸币，提示错误

构建因果图步骤如下：

1、找出输入输出，并确认其中的约束关系

![img](https://i-blog.csdnimg.cn/direct/b33c339af1304b18a5dfbce9daa80587.png)









![img](https://i-blog.csdnimg.cn/direct/f20ed2ac14f74505841f71e5dda27990.png)



![img](https://i-blog.csdnimg.cn/direct/e0c7443d27514eb7a992cc891741c6b9.png)



**2、分析输入输出之间 的因果关系（仅仅举两个例子）：**

**（这里的组合一次只展示一个测试用例）**



![img](https://i-blog.csdnimg.cn/direct/f939d80b02b848d5ada118171f80eb31.png)



![img](https://i-blog.csdnimg.cn/direct/79073a8bfe46442682e8f3f651bdeba2.png)



**3、根据因果图画出最后的表格（和2中对应，只有两个测试用例）：**

![img](https://i-blog.csdnimg.cn/direct/2f1e583332e54ce0a6b6bf35b46f1e26.png)



![img](https://i-blog.csdnimg.cn/direct/9f58645073884059b8e25c9b0142ec10.png)



#### 6.性能测试

​    性能测试与需求的质量有密切的关系，需求文档需要足够完备才能确保性能测试的成功进行。因此需求的质量通常可以反映在性能测试的容易度上。

> 核心思想：
>
> ​        1、性能测试的容易程度和需求文档质量挂钩。
>
> ​        2、因为性能部分是需求文档中相当容易被忽略的部分，如果这一部分仍然处理的很好就说明需求文档整体就是很好。

##### 6.1性能测试目的与职责

性能测试所针对的是非功能需求。它需要确保这个系统的可靠性、可用性与可维护性。
性能测试由测试小组进行设计和执行并将结果提供给客户。

##### 6.2性能测试种类

- 压力测试(短时间内加载极限负荷，验证系统能力)
- 容量测试(验证系统处理巨量数据的能力)
- 配置测试(测试各种软硬件配置(最小到最大))
- 兼容性测试(如果它与其他系统交互时)
- 回归测试(通过新旧两个测试用例同时进行)
- 安全性测试
- 计时测试
- 环境测试
- 质量测试
- 恢复测试
- 维护测试
- 文档测试
- 人为因素测试/可使用性测试

##### 6.3可靠性、可用性与可维护性定义(括号内为取值范围)

- 可靠性：一个系统对于给定时间间隔内、在给定条件下无失效运作的概率。(0~1)
- 可用性：在给定的时间点上，一个系统能够按照规格说明正确运作的概率。(0/1)
- 可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。(0~1)

> 可靠性的关键：给定条件（是否可靠要看在极度恶劣条件下是不是仍然可以运行）
>
> 可用性的关键：按照SRS正确运作（只有正确运作才算可用）
>
> 可维护性的关键：使用规定过程和资源完成维护活动



#### 7.验收测试

##### 7.1验收测试目的与职责

验收测试的目的是使客户和用户能确定我们构建的系统真正满足了他们的需要和期望。
验收测试的编写、执行和评估都是由客户来进行的。只有在请求某个技术问题的答案的时候才会需要开发人员。

##### 7.2验收测试的种类

(1)基准测试
        由用户准备典型测试用例，在实际安装后的系统运作并由用户对系统执行情况进行评估。
(2)引导测试
        在假设系统已经永久安装的前提下执行系统。它依赖系统的日常工作进行测试，相对基准测试不是非常的正式与结构化。
(3)并行测试

​    并行测试是一种软件测试方法，通常应用于系统升级或版本切换的场景。在并行测试过程中，新旧版本的系统同时运行，并允许用户在一段时间内同时使用旧版和新版软件。这样可以逐步过渡到新系统，确保新版本的功能和性能不会影响到现有用户的操作，同时也帮助用户适应新版系统的变化。

##### 7.3α测试与β测试

​    α测试：在向客户发布一个系统之前，先让来自己组织机构或公司的用户来测试这个系统。在客户进行实际的试验性测试前先试验这个系统。
​    β测试：客户的试验称为β测试。

##### 7.4验收测试的结果

> (1)让用户能够验证他的需求是怎样被实现的；
>
> (2)让客户发现需求中模糊的定义。
> (3)改需求
> (4)如果配置管理人员，则可以记录软件所有的变更。



#### 8.安装测试

##### 8.1安装测试定义

​    在用户环境中配置系统，以测试可能因为开发环境与用户环境的不同而导致的问题。

##### 8.2安装测试目的

​    安装系统的完备性，验证任何可能受场所条件影响的功能和非功能特性。



### 软件工程各阶段核心文档清单

#### ‌**1. 可行性分析阶段**‌

- ‌**可行性研究报告**‌：分析技术、经济、社会可行性，明确项目目标与风险‌。
- ‌**项目开发计划**‌：定义开发进度、资源分配、成本预算等‌。

------

#### ‌**2. 需求分析阶段**‌

- ‌**软件需求说明书（SRS）**‌：详细描述功能、性能、接口等需求‌。
- ‌**数据要求说明书**‌：明确数据结构、输入/输出格式及处理规则‌。
- ‌**初步用户手册**‌：概述系统功能与基本操作流程‌。

------

#### ‌**3. 设计阶段**‌

- ‌**概要设计阶段**‌
  - ‌**概要设计说明书**‌：定义系统架构、模块划分、接口规范‌。
  - ‌**数据库设计说明书**‌：描述数据库逻辑模型、物理存储设计及访问接口‌。
  - ‌**集成测试计划**‌：规划模块间集成测试策略与步骤‌。
- ‌**详细设计阶段**‌
  - ‌**详细设计说明书**‌：细化模块内部逻辑、算法实现与数据结构‌。
  - ‌**单元测试计划**‌：制定模块级测试用例与验证方法‌。

------

#### ‌**4. 编码与测试阶段**‌

- ‌**开发进度月报**‌：记录编码进度与问题追踪‌。
- ‌**测试用例文档**‌：涵盖单元测试、集成测试与系统测试的详细用例‌。
- ‌**测试分析报告**‌：总结测试结果与缺陷修复情况‌。

------

#### ‌**5. 交付与维护阶段**‌

- ‌**用户手册/操作手册**‌：完整说明系统安装、配置与使用方法‌。
- ‌**项目开发总结报告**‌：复盘开发过程、经验教训与成果评估‌。
- ‌**维护修改建议书**‌：记录用户反馈及后续优化需求‌。

------

#### 说明

- ‌**文档关联性**‌：部分文档（如用户手册）需从需求分析阶段开始编写，并在后续阶段逐步完善‌。
- ‌**阶段交叉**‌：测试计划需在设计和编码阶段同步制定，体现“测试左移”原则‌



概要设计阶段完成时应编写的文档包括：概要设计说明书；数据库设计说明书；集成测试计划。

1. ‌**数据库设计说明书**‌
    明确数据库的逻辑结构、物理存储设计及数据表关系，是概要设计的核心输出之一‌。
2. ‌**概要设计说明书**‌
    描述系统整体架构、模块划分、接口定义及运行流程，属于系统说明范畴‌。
3. ‌**集成测试计划**‌
    规划模块间的集成测试策略，通常在概要设计阶段制定‌。





### 第十章：软件维护

#### **一、软件维护类型**‌

1. ‌**纠错性维护（Corrective Maintenance）**‌
   - ‌**定义**‌：修复软件中已发现的错误或缺陷（如逻辑错误、性能异常），确保系统正常运行。
   - ‌**场景**‌：用户使用中触发的程序崩溃、数据处理错误等‌。
   - ‌**占比**‌：占维护工作量的17%–21%‌。
2. ‌**适应性维护（Adaptive Maintenance）**‌
   - ‌**定义**‌：为适应外部环境变化（如操作系统升级、硬件更新、法规调整）而调整软件‌。
   - ‌**场景**‌：数据库迁移至新平台、适配新硬件设备等‌。
   - ‌**占比**‌：占维护工作量的18%–25%‌。
3. ‌**完善性维护（Perfective Maintenance）**‌
   - ‌**定义**‌：优化现有功能、提升性能或扩展新功能以增强用户体验‌。
   - ‌**场景**‌：增加用户需求的功能模块、优化界面交互等‌。
   - ‌**占比**‌：占维护工作量的50%–60%（主要维护类型）。
4. ‌**预防性维护（Preventive Maintenance）**‌
   - ‌**定义**‌：通过重构代码、优化架构等手段预防潜在问题，提高软件可维护性。
   - ‌**场景**‌：代码清理、文档更新以降低未来维护成本‌。





### ‌**软件开发各阶段图形化工具详解**

#### **一、需求分析阶段**‌

1. ‌**业务流程图**‌
   - ‌**用途**‌：描述业务场景的角色、操作步骤及结果，明确流程起点与终点‌。
   - ‌**工具**‌：Draw.io、ProcessOn、Visio‌。
2. ‌**数据流图（DFD图）**‌
   - ‌**用途**‌：可视化数据流动方向、处理过程及存储逻辑，支持结构化需求分析‌。
   - ‌**核心要素**‌：数据流、处理节点、外部实体‌。
3. ‌**用例图（UML）**‌
   - ‌**用途**‌：定义系统功能与用户交互关系，明确功能边界‌。
   - ‌**适用场景**‌：复杂系统功能模块划分‌。
4. ‌**原型图**‌
   - ‌**用途**‌：低保真/高保真界面设计，辅助需求确认。
   - ‌**工具**‌：Axure、墨刀、Figma‌。

------

#### ‌**二、概要设计阶段**‌

1. ‌**系统结构图**‌
   - ‌**用途**‌：描述软件总体架构与模块划分，指导详细设计与编码‌。
2. ‌**UML组件图**‌
   - ‌**用途**‌：展示系统组件间依赖关系与通信机制‌。
3. ‌**部署图（UML）**‌
   - ‌**用途**‌：规划软硬件资源分布及部署策略‌。

------

#### ‌**三、详细设计阶段**‌

1. ‌**程序流程图**‌
   - ‌**用途**‌：描述模块内部算法逻辑与执行流程。
2. ‌**UML类图**‌
   - ‌**用途**‌：定义类、接口及关联关系，支持面向对象设计‌。
3. ‌**时序图（UML）**‌
   - ‌**用途**‌：展示对象间动态交互与消息传递顺序‌。
4. ‌**PAD图（Problem Analysis Diagram）**‌
   - ‌**用途**‌：结构化程序逻辑设计，支持代码自动生成‌。

------

#### ‌**四、软件测试阶段**‌

1. ‌**决策表**‌
   - ‌**用途**‌：描述输入条件与预期输出的组合逻辑，用于黑盒测试‌。
2. ‌**因果图**‌
   - ‌**用途**‌：分析输入变量间的因果关系，生成测试用例‌。
3. ‌**控制流图**‌
   - ‌**用途**‌：检测代码路径覆盖与异常分支，辅助白盒测试‌。

------

#### ‌**五、运行维护阶段**‌

1. ‌**状态图（UML）**‌
   - ‌**用途**‌：追踪对象状态迁移（如订单状态变更）‌。
2. ‌**E-R图（实体关系图）**‌
   - ‌**用途**‌：维护数据库表结构与关联关系‌。



### 环形复杂度

环形复杂度（Cyclomatic Complexity，CC），有的叫巡回秩数，是一种用于‌**量化程序逻辑复杂性**‌的软件度量指标，由Thomas J. McCabe于1976年提出‌。其核心意义包括：

1. ‌**独立路径数量**‌：表示程序控制流图中线性无关的路径条数，即覆盖所有可能情况所需的最少测试用例数‌。
2. ‌**代码质量评估**‌：高环形复杂度通常意味着代码逻辑复杂、维护成本高、潜在缺陷风险大‌。
3. ‌**度量标准**‌：通过数值化的方式辅助开发者识别需重构的模块。



McCabe环形复杂度（VG）的计算公式为：

- ‌**通用公式**‌：VG = E - N + 2P
  - E：边数；
  - N：节点数；
  - P：连通分量数（通常为1）‌。
- ‌**简化公式**‌：VG = 判定节点数（如if、while等） + 1‌。先找分叉点，（分支数-1）求和。
- **其他方法：**VG = 区域数



环形复杂度：一个图中独立路径个数

**注意：**

- 先写短的，并且至少要有一个新的结点（前面写的路径中结点不算）加入。
- 独立路径可能不唯一。



![截屏2025-02-15 21.10.31](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-15 21.10.31.png)

![截屏2025-02-15 21.14.29](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-15 21.14.29.png)



![截屏2025-02-15 21.33.17](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-15 21.33.17.png)



### 判定表、判定树

![截屏2025-02-16 10.59.48](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 10.59.48.png)



![截屏2025-02-16 11.08.04](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 11.08.04.png)

















### 数据流图

#### 1.数据流图的基本概念

![截屏2025-03-01 20.14.10](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-01 20.14.10.png)

在顶层DFD中，数据存储可能不是必需的。



#### 2.数据流图的层次结构

![截屏2025-03-01 20.14.39](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-01 20.14.39.png)

![截屏2025-03-01 20.15.54](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-01 20.15.54.png)



#### 3.画分层数据流图

![截屏2025-03-01 21.03.18](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-01 21.03.18.png)

![截屏2025-03-01 21.09.07](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-01 21.09.07.png)



#### 4.分层数据流图审查

![截屏2025-03-01 21.09.55](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-01 21.09.55.png)



![截屏2025-03-01 21.12.28](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-01 21.12.28.png)



![截屏2025-02-17 12.37.28](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-17 12.37.28.png)

![截屏2025-02-17 13.53.38](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-17 13.53.38.png)









推荐视频：https://www.bilibili.com/video/BV1Yv4y1E71P/?spm_id_from=333.337.search-card.all.click&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5







### 用例图

#### 1.用例图的基本概念

用例图包含：系统、参与者、用例、关系

参与者分为主要参与者（画在左边）和次要参与者（画在右边）

关系类型有：关联、泛化（继承）、包含、扩展

**关联（Association）**‌

- ‌**定义**‌：类之间的结构化连接，表示对象间的协作或依赖关系（如一个类调用另一个类的方法）



**泛化（Generalization）/继承**‌

- ‌**定义**‌：类之间的继承关系，子类继承父类的属性和方法，并可通过重写或扩展实现多态
- 体现“is-a”关系（如“Admin是User”）



**包含（Containment）/组合**‌

- ‌**定义**‌：一个用例（基用例）必须调用另一个用例（包含用例）的功能，表示‌**强制性的行为复用**‌。
- 箭头指向被包含用例。



**扩展（Extension）**‌

- ‌**定义**‌：在用例模型中，表示一个用例（扩展用例）在特定条件下扩展另一个用例（基用例）的行为。
- 箭头指向基用例。



![截屏2025-03-03 16.09.12](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.09.12.png)

![截屏2025-03-03 16.10.03](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.10.03.png)

![截屏2025-03-03 16.02.55](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.02.55.png)



#### 2.画用例图

![截屏2025-03-03 16.24.06](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.24.06.png)

![截屏2025-03-03 16.25.02](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.25.02.png)



推荐视频：https://www.bilibili.com/video/BV1co4y197MR/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5、https://www.bilibili.com/video/BV1qN41177fw?spm_id_from=333.788.recommend_more_video.-1&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5



### 类图（初步领域概念模型）

#### 1.类图的基本概念

关系类型有：泛化（继承）、关联、依赖、实现

**泛化（Generalization）/继承**‌

- ‌**定义**‌：子类继承父类的属性和方法，体现“is-a”关系（如“老虎是动物”）。
- ‌**符号**‌：‌**实线空心三角箭头**‌，箭头指向父类。



**关联（Association）**‌

- ‌**定义**‌：类间的结构化长期关系，通过成员变量体现，表示对象间的协作或拥有关系。
- ‌**符号**‌：‌**实线箭头或直线**‌（可标注导航性和多重性）。



**依赖（Dependency）**‌

- ‌**定义**‌：临时性、偶然性的使用关系，一个类的变化可能影响另一个类。
- ‌**符号**‌：‌**虚线箭头**‌，箭头指向被依赖的类。



**实现（Realization）**‌

- ‌**定义**‌：类实现接口的所有方法，体现功能契约的履行。
- ‌**符号**‌：‌**虚线空心三角箭头**‌，箭头指向接口。



可见性：属性或方法的可见性，用于设置该属性或方法的的可访问性。

| 符号    | 名称      | 描述                                                 |
| ------- | --------- | ---------------------------------------------------- |
| ‌**`+`**‌ | Public    | 公开可见，任何外部类均可访问。                       |
| ‌**`-`**‌ | Private   | 私有可见，仅所属类内部可访问‌。                       |
| ‌**`#`**‌ | Protected | 保护可见，所属类及其子类可访问（部分语言含友元类）。 |
| ‌**`~`**‌ | Package   | 包内可见，同一包/命名空间内的类可访问（Java默认）。  |



类图的多重性（Multiplicity）：

**定义与符号**‌

- ‌**定义**‌：通过“下限..上限”格式标注在关联线两端，表示允许生成的实例数量范围。
  - ‌**示例**‌：`1..*` 表示至少1个，最多无限；`0..1` 表示0或1个；单个数字表示固定数量。
- ‌**符号含义**‌：
  - `*`：零或多个（默认无上限）
  - `1`：必须且仅有一个
  - `1..5`：1到5个（闭区间）。



![截屏2025-03-03 16.18.32](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.18.32.png)



#### 2.画类图

![截屏2025-03-03 16.36.25](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.36.25.png)

![截屏2025-03-03 16.39.30](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.39.30.png)



![截屏2025-03-03 16.40.35](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 16.40.35.png)



![img](https://i-blog.csdnimg.cn/direct/ba139c3dc90a4e51bab5f44ca5164ddb.png)



推荐视频：https://www.bilibili.com/video/BV1co4y197MR/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5、https://www.bilibili.com/video/BV1Wu4y1Y7ya/?spm_id_from=333.788.recommend_more_video.1&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5







### 顺序图（时序图）

#### 1.顺序图的基本概念

**对象**‌：在时序图中，对象用矩形框表示，框中写有对象和/或类名，且名字下面有下划线。

‌**生命线**‌：时序图中的对象在一段时期内的存在用纵向的虚线表示，这称为对象的生命线。对象间的消息存在于两条虚线间。从上往下表示时间顺序的先后。

‌**控制焦点**‌：时序图中的对象执行一项操作的时期用窄的矩形表示，称为控制焦点。

‌**消息**‌：用于对实体间的通信内容建模，信息用于在实体间传递信息。允许实体请求其他的服务，类角色通过发送和接受信息进行通信。消息用对象的生命线之间的水平的消息线来表示，消息线的箭头说明消息的类型，如同步、异步或简单。

**请求消息：实线表示**

**响应消息：虚线表示**

**激活框：**框住生命线上的第一条消息和最后一条消息





![截屏2025-03-03 18.54.48](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 18.54.48.png)



#### 2.画顺序图

![截屏2025-03-03 19.13.45](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 19.13.45.png)

![截屏2025-03-03 19.14.35](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 19.14.35.png)

![截屏2025-03-03 19.15.20](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 19.15.20.png)

![截屏2025-03-03 19.18.22](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 19.18.22.png)

![截屏2025-03-03 19.18.32](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-03 19.18.32.png)



推荐视频：https://www.bilibili.com/video/BV1co4y197MR/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5、https://www.bilibili.com/video/BV1YM411f7dr/?spm_id_from=333.1387.homepage.video_card.click&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5







### 协作图（通信图）

协作图（Collaboration Diagram）是一种类图，包含**类元角色**和**关联角色**，不仅仅是**类元**和**关联**；

**协作图建模对象：**对有交互的对象和这些对象之间的关系建模，不参与交互的对象及它们的关系忽略；

**协作图内容：** 协作图中表现了类操作中用到的参数，布局变量，操作中的永久链

**对象图扩展：** 协作图可以看做对象图的扩展，该图展示了对象之间的关联，显示出了对象间的消息传递

组成元素：协作图=对象+链+消息

（1）对象（Object）
对象：代表协作图交互中的主体，和时序图汇总对象的概念类似
协作图和时序图中对象区别：协作图中对象无法创建和撤销，因此，对象在协作图的位置没有限制

（2）链（Link）
链的表示：链的符号和对象图中链所用的符号是一样的，用来连接两个类角色的实线 

（3）消息（Message）
消息：对象间通过链接发送的就是消息

- 消息传递方向*：*对象之间的箭头表明对象间交换的信息流，一个对象发出消息，链指向的对象接收消息，链用于实现消息传输；
- 消息标识：消息流标有消息的序列号和对象间发送的消息名称；
- 消息结果：每条消息是否会出发接收对象的一系列操作；



![这里写图片描述](https://i-blog.csdnimg.cn/blog_migrate/55508fb1e13a506dc710c3c285b36703.jpeg)



### 软件结构图

![截屏2025-03-11 18.24.49](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.24.49.png)

![截屏2025-03-11 18.25.21](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.25.21.png)

![截屏2025-03-11 18.25.30](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.25.30.png)

![截屏2025-03-11 18.25.41](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.25.41.png)

![截屏2025-03-11 18.25.49](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.25.49.png)

![截屏2025-03-11 18.25.55](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.25.55.png)

![截屏2025-03-11 18.26.09](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.26.09.png)

![截屏2025-03-11 18.26.18](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.26.18.png)

![截屏2025-03-11 18.26.25](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.26.25.png)

![截屏2025-03-11 18.26.34](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.26.34.png)

![截屏2025-03-11 18.26.44](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.26.44.png)

![截屏2025-03-11 18.26.51](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 18.26.51.png)



#### 一、定义

结构图（Structure Chart，简称SC图）是精确表达软件结构的图形表示方法，它以特定的符号表示模块、模块间的调用关系和模块间信息的传递。

#### 二、主要构成

⑴模块（Module）：用矩形框表示，框中写有模块的名字，说明模块的功能。
⑵调用：从一个模块指向另一个模块的箭头表示前一模块对后一模块的调用，一般是上层调用下层。
⑶数据：调用箭头边上的小箭头表示调用时从一个模块传送给另一模块的数据。通常在短箭头附近应注有信息的名字，常用尾端带有空心圆的短箭头表示数据信息，用尾端带有实心圆的短箭头表示控制信息，如：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8624ac81f05f52992169361247c93603.png)





(4)两种符号：当模块A有条件地调用另一个模块B时，在模块A的箭头尾部标以一个菱形符号，当一个模块A反复地调用模块B、和模块D时，在调用箭头尾部则标以一个弧形符号，如图所示。在结构图中这种**条件调用所依赖的条件**和**循环调用所依赖的循环控制条件**通常无需注明。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bea2aa715343a097a2ab8156bc64726d.png)



#### 三、常用的四种模块

1.传入模块

从下属模块取得数据，进行某些处理，再将其结果传给上级模块。在此，将它传送的数据流称为逻辑输入数据流
2.传出模块

从上级模块获得数据，进行某些处理，再将其结果传给下属模块。在此，将它传送的数据流称为逻辑输出数据流
3.变换模块/加工模块

它是从上级模块获得数据，进行特定的处理，将其转换为其他形式，再传回上级模块它所加工的数据流叫做变换数据流
4.协调模块

对所有下属模块进行协调和管理的模块。在一个好的软件结构图中，协调模块应在较高层出现
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e026d306eef5889e02cfd8cd835b8726.png)



#### 四、面向数据流的设计方法概述

概念：SD以数据流图为基础，它定义了把DFD（数据流图）变换成软件结构的不同映射方法。即把问题结构（DFD）映射成软件系统的结构。

分类：在软件设计开始之前,首先要分清DFD图所显示的系统特征，所有系统均可以纳入两种典型的形式：①变换型结构、②事务型结构。

①变换流：信息沿输入通路进入系统，同时由外部形式变换成内部形式，通过系统变换中心，经过加工处理以后再沿输出通路变换成外部形式离开软件系统。
②事务流：数据沿输入通路到达一个处理，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行，即“以事务为中心”







![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/31440094c176b0d4d4ee84aff7b74687.png)

#### 五、如何将DFD映射为软件结构

##### 1.变换型

具有“变换型”的数据流图，明显可以分割为“导入” 、“加工变换”和“导出” 三部分，对应软件结构的“传入子系统”、“中心变换子系统”和“传出子系统”三部分。
步骤

（1）找出边界，进行一级分解,设计上层模块。为每个输入设计一个输入模块，为每个输出设计一个输出模块，同时为每个主加工设计一个处理模块。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b896abbc6bb269888434c313ed11bc96.png)



2）进行二级分解，设计中下层模块。自顶向下，逐步细化，为第一层的每一个输入模块、输出模块、处理模块设计它们的从属模块，设计下层模块的顺序一般从设计输入模块的下层开始，即展开CI、CT、CO

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7652c4945d733cda9cebb7f828cf4e5a.png)

（3）进一步细化

##### 2.事务型

步骤

(1)在DFD上确定事务中心、接收部分和发送部分。
 (2)画出SC框架，把DFD上的三部分分别映射为事务控制模块、接收模块和动作发送模块，如下图所示
 (3)分解细化接收分支和发送分支

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2ce507f4d8235a6d9c6fb02808efaecb.png)



3.总结

机械地遵循变换分析或事务分析的映射规则，很可能会得到一些不必要的控制模块，如果它们确实用处不大，应该把它们合并。
反之，如果一个控制模块功能过分复杂，则应该分解为两个或多个控制模块，或者增加中间层次的控制模块。
所以，对初始映射得到的软件结构还应该进行结构优化。
优化：1）尽可能建立功能模块 2）消除重复功能 3）注意模块的作用范围与控制范围 4）模块的大小适当





参考链接：https://blog.csdn.net/weixin_52323239/article/details/130394275





### 状态转换图

#### 一：定义

状态转换图（简称状态图）通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。此外，状态图还指明了作为特定事件的结果系统将做哪些动作

状态是任何可以被观察到的系统行模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个（或一系列）动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态又做动作。

事件是在某个特定时刻发生的事情，它是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象。简而言之，事件就是引起系统做动作或转换状态的控制信息。

#### 二、符号表示



![截屏2025-03-11 11.06.14](/Users/yangluheng/Library/Application Support/typora-user-images/截屏2025-03-11 11.06.14.png)

##### 2.1 状态

状态转换图的状态有三种包括初态（即初始状态）、终态（即最终状态）和中间状态，在一张状态转换图中只能有一个初态，而终态则可以有0至多个。

初态用实心圆表示，终态用一对同心圆（内圆为实心圆）表示。

中间状态用匮角短形表示，可以用两条水平横线把它分成上、中、下3个部分。上面部分为状态的名称，这部分是必须有的；中间部分为状态变量的名字和值，这部分是可选的；

下面部分是活动表，这部分也是可选的。

##### 2.2活动

活动表的语法格式：事件名（参数表）/动作表达式

事件名：任何事件的名称

常见的3种标准事件：entry、do、exito。 entry事件指的是进入该状态的动作，do事件指的是该状态下的动作，exit事件指的是退出该状态的动作。

![截屏2025-03-11 10.23.41](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 10.23.41.png)

![截屏2025-03-11 11.09.17](/Users/yangluheng/Desktop/截屏2025-03-11 11.09.17.png)

##### 2.3 转换和事件

状态图中两个状态之问带箭头的连线称为状态转换，箭头指明了转换方向。

状态变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后白动触发转换。

事件表达式的语法：事件说明［守卫条件］/动作表达式事件说明：事件名（参数表）

守卫条件：布尔表达式。如果同时使用事件说明和守卫条件，则当且仅当事件说明发生且布尔表达式内真时，状态转换才会发生。如果只有守卫条件没有事件说明，则只要守卫条件为真，状态就会发生。

动作表达式：是一个过程表达式，当状态转换开始时执行该表达式。

![截屏2025-03-11 10.25.26](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 10.25.26.png)

![截屏2025-03-11 10.31.59](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 10.31.59.png)



#### 三、题目

![截屏2025-03-11 10.42.18](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 10.42.18.png)



![截屏2025-03-11 10.53.11](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 10.53.11.png)



![截屏2025-03-11 11.03.41](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-03-11 11.03.41.png)







推荐视频：https://www.bilibili.com/video/BV1Kk4y1p7uw?spm_id_from=333.788.recommend_more_video.0&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5、https://www.bilibili.com/video/BV1Wc41137t1?spm_id_from=333.788.recommend_more_video.0&vd_source=53cc1b70b1cfceb6baf8cdb094b70ac5



### 程序流程图

程序流程图也称为程序框图，是软件开发者最熟悉的算法表达工具。

#### 1.程序流程图的基本控制结构

1. 顺序型：几个连续的加工步骤依次排列构成。
2. 选择型：由某个逻辑判断式的取值决定选择两个加工中的一个。
3. 先判定（while）型循环：在循环控制条件成立时，重复执行特定的加工。
4. 后判定（until）型循环：重复执行某些特定的加工，直至控制条件成立。
5. 多情况（case）型选择：列举多种加工情况，根据控制变量的取值，选择执行其一。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7e3ff2f47ea6fa12db3256d8160ce6ef.png)



#### 2.程序流程图的标准符号

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/dbdb2d170818eaec06f05b4eabbb7dab.png)

#### 3.结构化程序的判断依据及分析

**单入口单出口**‌：程序仅通过顺序、选择、循环结构组合，符合结构化程序设计对控制流的基本要求

**结构化设计工具支持**‌：盒图（N-S图）是典型的结构化设计工具。





### 盒图（N-S图）

Nassi和Shneiderman 提出了一种符合结构化程序设计原则的图形描述工具，叫做盒图 （box-diagram），也叫做N-S图。

在N-S图中，为了表示5种基本控制结构，规定了5种图形构件。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0e0a14c237f26ced60aeb56b44ff3fbc.png)

![img](https://img2022.cnblogs.com/blog/2456626/202204/2456626-20220428203042640-1605605850.png)



![截屏2025-02-16 12.30.05](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 12.30.05.png)

![截屏2025-02-16 12.43.58](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 12.43.58.png)

![截屏2025-02-16 21.40.13](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 21.40.13.png)

![截屏2025-02-18 11.51.38](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-18 11.51.38.png)





### PAD图

PAD也设置了5种基本控制结构的图式，并允许递归使用。

全称为Problem Analysis Diagram，即问题分析图表，利用二维树形结构表示程序的控制流，也就是将程序功能的路线图给画出来，既可以表示程序的逻辑，也可以表示程序的结构，区分它的方法是程序的最左端有一条“竖线”，表示程序的“主线”。

![img](https://i-blog.csdnimg.cn/blog_migrate/2da4d8e42b70f1774de32b14987d87e5.png)



![img](https://img2022.cnblogs.com/blog/2456626/202204/2456626-20220428203125787-528339546.png)



![截屏2025-02-16 12.29.18](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 12.29.18.png)

![截屏2025-02-16 12.44.16](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 12.44.16.png)



![截屏2025-02-18 11.55.30](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-18 11.55.30.png)







### 等价类划分法和边界值分析法

![截屏2025-02-16 22.03.53](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 22.03.53.png)

![截屏2025-02-16 22.05.24](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-16 22.05.24.png)

![截屏2025-02-17 12.16.22](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-17 12.16.22.png)





### 逻辑覆盖法

白盒测试又称为透明盒测试、结构测试，它基于程序内部结构进行测试，而不是测试应用程序的功能（黑盒测试）。因此，测试人员需要了解程序内部逻辑结构，从编程语言的角度设计测试用例。白盒测试可用于单元测试、集成测试和系统测试。

逻辑覆盖法是白盒测试最常用的测试方法，它包括语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖5种。

#### 1.语句覆盖

语句覆盖（Statement Coverage）又称行覆盖、段覆盖、基本块覆盖，它是最常见的覆盖方式。

语句覆盖的目的是测试程序中的代码是否被执行，它只测试代码中的执行语句，这里的执行语句不包括头文件、注释、空行等。

在语句覆盖测试用例中，使程序中每个可执行语句至少被执行一次。

语句覆盖虽然可以测试执行语句是否被执行到，但却无法测试程序中存在的逻辑错误。

![img](https://i-blog.csdnimg.cn/blog_migrate/a747be287d679682a6b6f8e95db60a4d.png)



根据程序流程图中标示的语句执行路径设计测试用例：Test1：x=1 y=-1 z=2，执行上述测试用例，程序运行路径为acd。可以看出程序中acd路径上的每个语句都能被执行，但是语句覆盖对多分支的逻辑无法全面反映，仅仅执行一次不能进行全面覆盖，因此，语句覆盖是弱覆盖方法。

语句覆盖虽然可以测试执行语句是否被执行到，但却无法测试程序中存在的逻辑错误。

#### 2.判定覆盖

判定覆盖（Decision Coverage）又称为分支覆盖，其原则是设计足够多的测试用例，在测试过程中保证每个判定至少有一次为真值，有一次为假值。

判定覆盖的作用是使真假分支均被执行。

![img](https://i-blog.csdnimg.cn/blog_migrate/f77e170575746f3d97e0801e23e7d9ec.png)

这4个测试用例覆盖了acd、abd、ace、abe 4条路径，使得每个判定语句的取值都满足了各有一次“真”与“假”。相比于语句覆盖，判定覆盖的覆盖范围更广泛。

判定覆盖虽然保证了每个判定至少有一次为真值，有一次为假值，但是却没有考虑到程序内部的取值情况，例如，测试用例test4，没有将x>2作为条件进行判断，仅仅判断了z>0的条件。 

判定覆盖语句一般是由多个逻辑条件组成的，如果仅仅判断测试程序执行的最终结果而忽略每个条件的取值，必然会遗漏部分测试路径，因此，判定覆盖也属于弱覆盖。

#### 3.条件覆盖

条件覆盖（Condition Coverage）指的是设计足够多的测试用例，使判定语句中的每个逻辑条件取真值与取假值至少出现一次，例如，对于判定语句IF(a>1 OR c<0)中存在a>1、c<0 2个逻辑条件，设计条件覆盖测试用例时，要保证a>1、c<0的“真”“假”值至少出现一次。

以上面的流程图及其程序为例，设计条件覆盖测试用例，在该程序中，有2个判定语句，每个判定语句有2个逻辑条件，共有4个逻辑条件，使用标识符标识各个逻辑条件取真值与取假值的情况：
![img](https://i-blog.csdnimg.cn/blog_migrate/0a016acd969724be57741aa28848f5dc.png)



#### 4.判定—条件覆盖 

判定-条件覆盖（Condition/Decision Coverage）要求设计足够多的测试用例，使得判定语句中所有条件的可能取值至少出现一次，同时，所有判定语句的可能结果也至少出现一次。

![img](https://i-blog.csdnimg.cn/blog_migrate/3f48288bb83991b89f9bdbac7c5f7302.png)

表中的3个测试用例满足了所有条件可能取值至少出现一次，以及所有判定语句可能结果也至少出现一次的要求。（但依然没有列出所有的可能）

相比于条件覆盖、判定覆盖，判定-条件覆盖弥补了两者的不足之处，但是由于判定-条件覆盖没有考虑判定语句与条件判断的组合情况，其覆盖范围并没有比条件覆盖更全面，判定-条件覆盖也没有覆盖acd路径，因此判定-条件覆盖仍旧存在遗漏测试的情况。



#### 5.条件组合覆盖

条件组合（Multiple Condition Coverage）指的是设计足够多的测试用例，使判定语句中每个条件的所有可能至少出现一次，并且每个判定语句本身的判定结果也至少出现一次，它与判定-条件覆盖的差别是，条件组合覆盖不是简单地要求每个条件都出现“真”与“假”两种结果，而是要求让这些结果的所有可能组合都至少出现一次。

还是以上述的流程图及其程序为例，该程序中共有4个条件：x>0、y<0、x>2、z>0，依然用S1、S2、S3、S4标记这4个条件成立，用-S1、-S2、-S3、-S4标记这些条件不成立。由于这4个条件每个条件都有取“真”“假”两个值，因此所有条件结果的组合有2^4=16种:
![img](https://i-blog.csdnimg.cn/blog_migrate/44e17eec2459ff7d1d025ad04d7bcc1d.png)



表中列出了4个条件所有结果的组合情况，经过分析可以发现，第2、6、8、13这4种情况是不存在的，这几种情况要求x>0不成立，x>2成立，这2种结果相悖，因此最终图中的所有条件组合情况有12种。根据这12种情况设计测试用例：

![img](https://i-blog.csdnimg.cn/blog_migrate/154b9cfd81eeb4cae785654970d6de67.png)

表中有12个测试用例，这12个测试用例覆盖了4个条件结果的所有组合，与判定-条件覆盖相比，条件组合覆盖包括了所有判定-条件覆盖，因此它的覆盖范围更广。但是当程序中条件比较多时，条件组合的数量会呈指数型增长，组合情况非常多，要设计的测试用例也会增加，这样反而会使测试效率降低。



#### 6.路径覆盖‌

**定义**‌：覆盖程序中所有可能的执行路径（包括循环和分支组合）。

‌**特点**‌：覆盖率最高，但复杂度极高，适用于关键模块测试。



### **覆盖方法对比**‌

| ‌**覆盖方法**‌      | ‌**覆盖目标**‌        | ‌**覆盖率**‌ | ‌**复杂度**‌ | ‌**典型应用场景**‌     |
| ----------------- | ------------------- | ---------- | ---------- | -------------------- |
| ‌**语句覆盖**‌      | 每个可执行语句      | 最低       | 低         | 简单功能验证         |
| ‌**判定覆盖**‌      | 每个分支的真/假结果 | 中等       | 中         | 基础分支逻辑验证     |
| ‌**条件覆盖**‌      | 每个条件的真/假结果 | 中高       | 中         | 复杂条件逻辑验证     |
| ‌**判定-条件覆盖**‌ | 分支结果 + 条件取值 | 较高       | 较高       | 综合条件与分支的验证 |
| ‌**条件组合覆盖**‌  | 多条件的组合取值    | 高         | 高         | 多条件交互场景       |
| ‌**路径覆盖**‌      | 所有可能的执行路径  | 最高       | 极高       | 关键模块或高风险代码 |



#### 7.条件覆盖和判定—条件覆盖和条件组合覆盖的区别

##### **1. 条件覆盖（Condition Coverage）**‌

- ‌**定义**‌：确保每个‌**条件**‌（即逻辑表达式中的原子条件，如 `A > 0`、`B < 5`）的真（True）和假（False）都被至少执行一次。
- ‌示例：对于判定 if (A && B)，需要测试：
  - `A=True, B=False`（覆盖 `A` 为真，`B` 为假）
  - `A=False, B=True`（覆盖 `A` 为假，`B` 为真）
- ‌特点：
  - ‌**不关心判定结果**‌（即使所有用例的判定结果都是 `False`，只要条件覆盖了即可）。
  - ‌**可能遗漏判定的覆盖**‌（例如，未覆盖判定为 `True` 的情况）。

------

##### ‌**2. 判定-条件覆盖（Condition/Decision Coverage）**‌

- ‌**定义**‌：结合‌**判定覆盖**‌（每个判定的真/假都被执行）和‌**条件覆盖**‌（每个条件的真/假都被执行）。
- ‌示例：对于 if (A && B)，需要：
  - `A=True, B=True`（判定为 `True`）
  - `A=False, B=False`（判定为 `False`，同时覆盖 `A=False` 和 `B=False`）
- ‌特点：
  - 必须同时满足两个条件：
    1. 每个判定的所有可能结果被覆盖。
    2. 每个条件的所有可能值被覆盖。
  - ‌**测试用例数通常少于条件组合覆盖**‌，但可能‌**未覆盖所有条件组合**‌（例如，`A=True, B=False` 和 `A=False, B=True` 的组合可能未被测试）。

------

##### ‌**3. 条件组合覆盖（Multiple Condition Coverage）**‌

- ‌**定义**‌：覆盖所有可能的条件组合（即所有条件的真/假组合）。
- ‌示例：对于 if (A && B)，需要测试所有 4 种组合：
  - `A=True, B=True`
  - `A=True, B=False`
  - `A=False, B=True`
  - `A=False, B=False`
- ‌特点‌：
  - ‌**覆盖最严格**‌，但测试用例数随条件数量指数级增长（`n` 个条件需要 `2^n` 个组合）。
  - ‌**隐含覆盖前两种覆盖**‌（条件组合覆盖必然满足条件覆盖和判定覆盖）。

------

### ‌**三者的对比**‌

| ‌**覆盖类型**‌  | ‌**覆盖目标**‌                      | ‌**测试用例数**‌     | ‌**严格程度**‌ |
| ------------- | --------------------------------- | ------------------ | ------------ |
| 条件覆盖      | 每个条件的真/假                   | 较低               | 低           |
| 判定-条件覆盖 | 每个条件的真/假 + 每个判定的真/假 | 中等               | 中           |
| 条件组合覆盖  | 所有条件的真/假组合               | 指数级增长（最高） | 高           |







![截屏2025-02-17 12.21.29](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-17 12.21.29.png)

![截屏2025-02-17 12.27.16](/Users/yangluheng/Documents/博士申请/西安交通大学/软件工程/截屏2025-02-17 12.27.16.png)

参考链接：https://blog.csdn.net/weixin_45623883/article/details/130764085









### 软件能力成熟模型（CMM）的五个成熟级别

软件能力成熟模型CMM（Capability Maturity Model for Software）的五个成熟级别
  第一级：初始级(Initial)；**无序，随意**
         初始级的软件过程是无序的，项目的执行是随意甚至是混乱的。工作方式处于救火状态，不断的应对突如其来的危机；
 第二级：可重复级(Repeatable)；**基本的项目管理**
        建立了基本的项目管理过程来跟踪费用，进度和功能特性，制定了必要的过程纪律，能重复早先类似的应用项目取得的成功。
 第三级：已定义级(Defined)；**标准化，文档化**
        已经将软件管理核工程两方面的过程文档化，标准化，并综合成组织的标准软件过程，所有项目均使用该标准开发维护软件。
 第四级：定量管理级(Managed)；**可预测**
        收集对软件过程和产品质量的详细度量，对软件的过程和产品都有定量的理解和控制。
 第五级：优化级(Optimizing)。**优化**
        过程的量化反馈和先进的新思想，新技术促使过程不断改进。





## 笔试题

### 1.西交《软件工程概论》在线作业

**试卷总分:100   得分:100**
一、单选题 (共 19 道试题,共 38 分)
**1.对于集成测试，下列说法错误的是（ ）**
A.应对每一个测试用例都执行测试规程
B.应将测试结果与预期结果比较，研究两者的偏离原因
C.将缺陷报告给相关构件工程师，不需要他们修改
D.将缺陷报告给测试设计人员，由它们评估整个测试工作的结果
答案:C
**2.在软件生存周期中，工作量所占比例最大的阶段是（）阶段**
A.需求分析
B.设计
C.测试

D.维护 
答案:D
**3.在数据流图中，有名字及方向的成分是（ ）**
A.控制流
B.信息流
C.数据流
D.信号流
答案:C
**4.当模块中包含复杂的条件组合,只有( )能够清晰地表达出各种动作之间的对应关系.**
A.判定表和判定树
B.盒图
C.流程图
D.关系图

答案:A
**5.实践表明,确定发生错误的位置和内在原因所需的工作量几乎占整个调试工作量的( )**
A.30
B.50
C.70
D.90
答案:D
**6.技术可行性是可行性研究的关键,其主要内容一般不包括( ).**
A.风险分析
B.资源分析
C.人员分析
D.技术分析
答案:C

**7.以下不属于白盒测试技术的是( )**
A.逻辑覆盖
B.基本路径测试
C.循环覆盖测试
D.等价类划分
答案:D
**8.软件工程中的各种方法是完成软件工程项目的技术手段,它们支持软件工程的( )阶段**
A.各个
B.前期
C.中期
D.后期
答案:A
**9.同一类中有相同的数据结构，这是（ ）级别的共享**

A.不同应用
B.同一应用
C.不同类
D.同一类
答案:D
**10.在软件的开发与维护过程中,用来存储.更新.恢复和管理一个软件的多版本,它是()工**
**具。**
A.文档分析
B.项目管理
C.成本估算
D.版本控制
答案:D
**11.以下说法错误的是（ ）**
A.面向对象方法不仅支持过程抽象，而且支持数据抽象

B.某些面向对象的程序设计语言还支持参数化抽象
C.信息隐藏通过对象的封装性来实现
D.在面向对象方法中，类是最基本的模块
答案:D
**12.瀑布模型的问题是（ ）**
A.用户容易参与开发
B.缺乏灵活性
C.用户与开发者易沟通
D.适用可变需求
答案:B
**13.黑盒测试是从（ ）观点出发的测试，白盒测试是从（）观点出发的测试。正确选**
**项为（ ）**
A.开发人员、管理人员
B.用户、管理人员

C.用户、开发人员
D.开发人员、用户
答案:C
**14.可行性研究的步骤中不包括( )的内容.**
A.复查初步分析结果.
B.研究现有的系统
C.导出新系统高层逻辑模型.
D.建立新系统的物理模型解法.
答案:C
**15.Jackson 方法在需求分析阶段的主要步骤不包括( ).**
A.了解实体行为
B.标识实体与行为
C.生成实体结构图

D.创建软件系统模型 
答案:A
**16.软件生存周期包括可行性分析和项目开发计划、需求分析、概要设计、详细设计、** 
**编码、()、维护等活动。**
A.应用
B.测试
C.检测
D.其他答案都不正确
答案:B

**17.面向对象分析阶段建立的三个模型中，核心的模型是（）模型。**
A.功能
B.动态
C.对象
D.分析

答案:C
**18.软件测试法中，（ ）主要分析程序的内部结构。**
A.白盒法
B.黑盒法
C.因果图法
D.错误推测法
答案:A
**19.以下说法错误的是（ ）**
A.对象具有很强的表达能力和描述功能
B.对象是人们要进行研究的任何事务
C.对象是封装的基本单位
D.类封装比对象封装更具体、更细致
答案:D

二、多选题 (共 1 道试题,共 2 分)
**20.技术可行性考虑的问题有( )**
A.开发风险分析
B.资源分析
C.相关技术的发展
答案:ABC
三、判断题 (共 30 道试题,共 60 分)
**21.详细设计的基本任务有:算法设计、数据结构设计、物理设计、其他设计,例如代码** 
**设计、输入/输出格式设计、人机对话设计、编写详细设计说明书、评审( )**
答案:正确
**22.划分模块时，尽量做到低内聚、高耦合（）**
答案:错误
**23.数据流图一般分为变换型数据流图和事务型数据流图两类（）**
答案:正确

**24.可用性：系统在给定的时间点上根据需求说明成功地运行的概率。也可以说可用性** 
**是当有请求时即在一定时刻）系统能执行有用服务的可能性。()**
答案:正确
**25.测试设计人员尤其看重的两条度量标准是：测试完全性、可靠性。**
答案:正确
**26.软件维护费用增加的主要原因是维护的生产率非常低。**
答案:正确
**27.对象具有状态，一个对象用数据值来描述它的状态。**
答案:正确
**28.增量模型是一种整体开发模型。()**
答案:错误
**29.概要设计的基本任务有：1）设计软件系统结构简称软件结构）2）数据结构及数据** 
**库设计 3）编写概要设计文档 4）评审。( )**
答案:正确

**30.面向对象设计准则是:模块化,抽象信息隐藏,低耦合,高内聚( )**
答案:正确
**31.维护没有副作用。**
答案:错误
**32.任何程序都可以由顺序、选择及重复三种基本控制结构构造（）。**
答案:正确
**33.带来高维护费用的关键因素有：人员的不稳定、合同责任、维护人员技术水平、系**
**统结构衰退。**
答案:正确
**34.在需求分析阶段，首先进行问题识别，即双方确定对问题的综合需求，这些需求包** 
**括：功能需求、性能需求、环境需求、用户界面需求。()**
答案:正确
**35.信息隐蔽是指在设计和确定模块时，使得一个模块内包含的信息，对于不需要这些** 
**信息的其他模块来说是不能访问的（）。**
答案:正确

**36.为了提高模块的独立性,模块内部最好是时间内聚。()**
答案:错误
**37.软件的可维护性、可使用性、可靠性是衡量软件质量的几个主要特性。**
答案:正确
**38.3 种可能的控制流机制分别是：过程驱动控制、事件驱动控制、线程驱动控制（ ）**
答案:正确
**39.类有三种复用方式：实例复用、继承复用、多态复用。**
答案:正确
**40.具有明确功能并可以分离出来的软件或硬件叫做构件( )**
答案:正确
**41.详细设计的基本任务有：算法设计、数据结构设计、物理设计、其他设计，例如代**
**码设计、输入/输出格式设计、人机对话设计、编写详细设计说明书、评审。**
答案:正确
**42.为了克服瀑布模型的局限性，使开发过程具有一定的灵活性和可修改性，于是产生**

**了增量模型。它是在瀑布模型的基础上加以修改而形成的。**
答案:正确
**43.用等价类划分的方法设计测试用例的步骤为：划分等价类、确定测试用例（ ）**
答案:正确
**44.需求文档是需求分析阶段最重要的技术文档之一（）**
答案:正确
**45.深度是指结构图控制的层次，也是模块的层数（）**
答案:正确
**46.软件生存周期包括可行性研究、项目开发计划、需求分析、软件设计、编码、测试、**
**维护等活动。()**
答案:正确
**47.数据流图是 SA 方法中用于表示系统逻辑模型的一种工具（）。**
答案:正确
**48.软件体系结构的几种模型包括:结构模型、框架模型、动态模型、过程模型、功能模型( )**

答案:正确
**49.软件工程过程包含 7 个过程（）**
答案:正确
**50.类之间的连接关系是聚合关系;类之间整体与部分的关系是关联关系( )**
答案:错误



### 2.西交2020年3月《软件工程概论》

一、单选题

**（1）以下说法错误的是( )**

·    A对象具有很强的表达能力和描述功能

·    B对象是人们要进行研究的任何事务

·    C对象是封装的基本单位

·    D类封装比对象封装更具体、更细致

正确答案:D

**（2）下面属于软件调试技术的是( )**

·    A边界值分析

·    B回溯法

·    C循环覆盖

·    D集成测试

正确答案:B

**（3）一个CASE工作台是一组( ),支持设计、实现或测试等特定的软件开发阶段**

·    A工具集

·    B软件包

·    C平台集

·    D程序包

正确答案:A

**（4）下面哪个不是集成测试使用的图模型( )**

·    A顺序图

·    B协作图

·    C活动图

·    D用例图

正确答案:D

**（5）软件是一种( )产品**

·    A有形

·    B逻辑

·    C物质

·    D消耗

正确答案:B

**（6）软件设计一般分为总体设计和详细设计,它们之间的关系是( )**

·    A全局和局部

·    B抽象和具体

·    C总体和层次

·    D功能和结构

正确答案:A

**（7）面向对象设计语言不同于其他语言的最主要特点是( )**

·    A模块性

·    B抽象性

·    C继承性

·    D共享性

正确答案:C

**（8）面向对象程序设计语言与其他程序设计语言的最主要差别是它具有( )**

·    A模块性

·    B抽象性

·    C继承性

·    D共享性

正确答案:C

**（9）白盒测试方法重视( )的度量**

·    A测试覆盖率

·    B测试数据多少

·    C测试费用

·    D测试周期

正确答案:A

**（10）SA方法是一种( )**

·    A自顶向下逐层分解的分析方法

·    B自底向上逐层分解的分析方法

·    C面向对象的分析方法

·    D其他都不是

正确答案:A

**（11）软件生存周期模型有多种,下列选项中,()不是软件生存周期模型。**

·    A螺旋模型

·    B增量模型

·    C功能模型

·    D瀑布模型

正确答案:C

**（12）加工是对数据流图中不能再分解的基本加工的精确说明,下述()是加工的最核心。**

·    A加工顺序

·    B加工逻辑

·    C执行频率

·    D激发条件

正确答案:B

**（13）软件开发环境支持一定的()或按照一定的软件开发模型组织而成。**

·    A软件生存周期

·    B软件过程

·    C软件开发方法

·    D软件开发模型

正确答案:C

**（14）软件开发方法中的原型化方法是一种()型的设计过程。**

·    A自外向内

·    B自顶向下

·    C自内向外

·    D自底向上

正确答案:A

**（15）是计算机程序及其说明程序的各种文档。**

·    A软件

·    B文档

·    C数据

·    D程序

正确答案:A

**（16）可行性分析中,系统流程图用于描述()。**

·    A当前运行系统

·    B当前逻辑模型

·    C目标系统

·    D新系统

正确答案:A

**（17）表示集成是指一个系统中的工具使用共同的风格以及采用共同的用户交互标准集。表示集成有三种不同级别:窗口系统集成、命令集成和()。**

·    A数据集成

·    B平台集成

·    C界面集成

·    D交互集成

正确答案:D

**（18）()支持工作台或环境中一个工具对系统中其他工具的访问。**

·    A过程集成

·    B控制集成

·    C平台集成

·    D界面集成

正确答案:B

**（19）软件工程学的目的应该是最终解决软件生产的()问题。**

·    A提高软件的开发效率

·    B使软件生产工程化

·    C消除软件的生产危机

·    D加强软件的质量保证

正确答案:B

**（20）在计算机软件开发和维护中所产生的一系列严重的问题通常称为软件危机,这些问题中相对次要的因素是()。**

·    A文档质量

·    B开发效率

·    C软件功能

·    D软件性能

正确答案:D

**（21）为了进一步改善软件系统的可维护性和可靠性,并为以后的改进奠定基础的软件维护称为( ).**

·    A纠错性维护

·    B适应性维护

·    C改善性维护

·    D预防性维护

正确答案:D

**（22）软件工程中的各种方法是完成软件工程项目的技术手段,它们支持软件工程的( )阶段.**

·    A各个

·    B前期

·    C中期

·    D后期

正确答案:A

**（23）SA方法是一种（ ）**

·    A自顶向下逐层分解的分析方法

·    B自底向上逐层分解的分析方法

·    C面向对象的分析方法

·    D其他都不是

正确答案:A

**（24）软件是一种（ ）产品**

·    A有形

·    B逻辑

·    C物质

·    D消耗

正确答案:B

**（25）对象模型的描述工具是（ ）**

·    A状态图

·    B数据流图

·    C对象图

·    D结构图

正确答案:C

**（26）以下说法错误的是（ ）**

·    A对象具有很强的表达能力和描述功能

·    B对象是人们要进行研究的任何事务

·    C对象是封装的最基本单位

·    D类封装比对象封装更具体、更细致

正确答案:D

**（27）将软件组装成系统的一种测试技术叫( ).**

·    A集成测试

·    B单元测试

·    C集合测试

·    D系统测试

正确答案:A

**（28）研究软硬件资源的有效性是进行（ ）研究的一方面。**

·    A技术可行性

·    B经济可行性

·    C社会可行性

·    D操作可行性

正确答案:A

**（29）一个CASE工作台是一组（ ），支持设计、实现或测试等特定的软件开发阶段。**

·    A工具集

·    B软件包

·    C平台集

·    D程序包

正确答案:A

**（30）瀑布模型的问题是（）**

·    A用户容易参与开发

·    B缺乏灵活性

·    C用户与开发者易沟通

·    D适用可变需求

正确答案:B

**（31）需求分析是（）**

·    A软件开发工作的基础

·    B软件生存周期的开始

·    C由系统分析员单独完成的

·    D由用户自己单独完成的

正确答案:A

**（32）软件工程对维护工作的主要目标是提高（ ），降低维护的代价。**

·    A软件的生产率

·    B软件的可靠性

·    C软件的可维护性

·    D维护的效率

正确答案:A

**（33）以下不属于软件维护的困难表现的是（ ）**

·    A读懂别人的程序是困难的

·    B文档的不一致性

·    C源程序及相关文档的错误或丢失

·    D软件开发和软件维护在人员和时间上的差异

·    E软件维护不是一项吸引人的工作

正确答案:C

**（34）以下说法错误的是（ ）**

·    A对象具有很强的表达能力和描述功能

·    B对象是人们要进行研究的任何事务

·    C对象是封装的基本单位

·    D类封装比对象封装更具体、更细致

正确答案:D

**（35）软件测试的目的是（）**

·    A证明软件的正确性

·    B找出软件系统中存在的所有错误

·    C证明软件系统中存在错误

·    D尽可能多的发现软件系统中的错误

正确答案:B

**（36）白盒测试方法重视（ ）的度量**

·    A测试覆盖率

·    B测试数据多少

·    C测试费用

·    D测试周期

正确答案:A

**（37）以下说法错误的是（ ）**

·    A面向对象方法不仅支持过程抽象，而且支持数据抽象

·    B某些面向对象的程序设计语言还支持参数化抽象

·    C信息隐藏通过对象的封装性来实现

·    D在面向对象方法中，类是最基本的模块

正确答案:D

**（38）可行性研究的步骤中不包括( )的内容.**

·    A复查初步分析结果.

·    B研究现有的系统

·    C导出新系统高层逻辑模型.

·    D建立新系统的物理模型解法.

正确答案:C

**（40）SA方法是一种（ ）**

·    A自顶向下逐层分解的分析方法

·    B自底向上逐层分解的分析方法

·    C面向对象的分析方法

·    D其他都不是

正确答案:A

**（41）分层DFD是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（ ）**

·    A细节

·    B输入与输出

·    C软件的作者

·    D绘制的时间

正确答案:B

**（42）对象模型的描述工具是（）**

·    A状态图

·    B数据流图

·    C对象图

·    D结构图

正确答案:C

**（43）软件是一种（ ）产品**

·    A有形

·    B逻辑

·    C物质

·    D消耗

正确答案:B

**（44）传统的测试策略是从（ ）开始**

·    A单元测试

·    B集成测试

·    C系统测试

·    D人员测试

正确答案:A

**（45）软件工程方法得以实施的主要保证是（ ）**

·    A硬件环境

·    B开发人员的素质

·    C软件开发工具和软件开发的环境

·    D软件开发的环境

正确答案:C

**（46）同一类中有相同的数据结构，这是（ ）级别的共享**

·    A不同应用

·    B同一应用

·    C不同类

·    D同一类

正确答案:D

**（47）指出PDL是下列（）语言**

·    A高级程序设计语言

·    B伪码

·    C中级程序设计语言

·    D低级程序设计语言

正确答案:B

**（48）根据用户在软件使用过程中提出的建设性意见而进行的维护活动称为( ).**

·    A纠错性维护

·    B适应性维护

·    C改善性维护

·    D预防性维护

正确答案:C

**（49）在软件生存周期中，工作量所占比例最大的阶段是（）阶段**

·    A需求分析

·    B设计

·    C测试

·    D维护

正确答案:D

**（50）技术可行性是可行性研究的关键,其主要内容一般不包括( ).**

·    A风险分析

·    B资源分析

·    C人员分析

·    D技术分析

正确答案:C

**（51）以下说法错误的是（ ）**

·    A面向对象分析与面向对象设计的定义没有明显的区别

·    B在实际的软件开发过程中面向对象分析与面向对象设计的界限是模糊的

·    C面向对象分析和面向对象设计活动是一个多次反复迭代的过程

·    D从面向对象分析到面向对象设计，是一个逐渐扩充模型的过程

正确答案:A

**（52）结构化设计是一种面向（ ）的设计方法**

·    A数据流

·    B数据结构

·    C数据库

·    D程序

正确答案:A

**（53）软件维护工作的最主要部分是（）**

·    A校正性维护

·    B适应性维护

·    C完善性维护

·    D预防性维护

正确答案:C

**（54）从事物的属性侧面来描述事物的方法就是( )的方法.**

·    A面向对象

·    B面向数据

·    C面向过程

·    D面向属性

正确答案:B

**（56）Jackson方法在需求分析阶段的主要步骤不包括( ).**

·    A了解实体行为

·    B标识实体与行为

·    C生成实体结构图

·    D创建软件系统模型

正确答案:A

**（57）当模块中包含复杂的条件组合,只有( )能够清晰地表达出各种动作之间的对应关系.**

·    A判定表和判定树

·    B盒图

·    C流程图

·    D关系图

正确答案:A

**（58）下面哪个不是集成测试使用的图模型（ ）**

·    A顺序图

·    B协作图

·    C活动图

·    D用例图

正确答案:D

**（59）一个模块的( )是指能直接控制该模块的模块数.**

·    A扇出数

·    B扇入数

·    C宽度

·    D深度

正确答案:B

**（60）为适应软件运行环境的变化而修改软件的活动称为( ).**

·    A纠错性维护

·    B适应性维护

·    C改善性维护

·    D预防性维护

正确答案:B

**（61）尽管有不合法的输入，软件仍能继续正常工作的能力是指（ ）**

·    A兼容性

·    B可靠性

·    C容错性

·    D稳定性

正确答案:C

**（62）瀑布模型的问题是（ ）**

·    A用户容易参与开发

·    B缺乏灵活性

·    C用户与开发者容易沟通

·    D适用可变需求

正确答案:B

**（63）分层的数据流图是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（ ）**

·    A细节

·    B输入与输出

·    C软件的作者

·    D绘制的时间

正确答案:B

**（64）程序的3中基本结构是（ ）**

·    A过程、子程序、分程序

·    B顺序、条件、循环

·    C递归、堆栈、队列

·    D调用、返回、转移

正确答案:B

**（65）瀑布模型的问题是（ ）**

·    A用户容易参与开发

·    B缺乏灵活性

·    C用户与开发者易沟通

·    D适用可变需求

正确答案:B

**（66）SA方法是一种（ ）**

·    A自顶向下逐层分解的分析方法

·    B自底向上逐层分解的分析方法

·    C面向对象的分析方法

·    D其他都不是

正确答案:A

**（67）为改正软件系统中潜藏的错误而进行的维护活动称为( )**

·    A纠错性维护

·    B适应性维护

·    C改善性维护

·    D预防性维护

正确答案:A

**（68）软件维护工作的最主要部分是（ ）**

·    A校正性维护

·    B适应性维护

·    C完善性维护

·    D预防性维护

正确答案:C

**（69）通道技术可以在（　　　）之间直接交换数据。**

·    A内存与CPU

·    BCPU与外设

·    C内存与外设

·    D内存、CPU和外设三者

正确答案:C

**（70）黑盒测试是从（）观点出发的测试，白盒测试是从（）观点出发的测试。**

·    A开发人员、管理人员

·    B用户、管理人员

·    C用户、开发人员

·    D开发人员、用户

正确答案:C

**（71）软件测试法中，（　　）主要分析程序的内部结构。**

·    A白盒法

·    B黑盒法

·    C因果图法

·    D错误推测法

正确答案:A

**（72）从事物的组成部件及每个部件的属性,功能来认识事物.这种方法被称为( )的方法.**

·    A面向对象

·    B面向数据

·    C面向过程

·    D面向属性

正确答案:A

**（73）面向对象(Object Oriented)方法是将现实世界的事物以对象的方式( )到计算机世界的方法.**

·    A对应

·    B映射

·    C反映

·    D反射

正确答案:B

**（74）面向数据的设计方法就是根据问题的数据结构定义一组映射,把问题的数据结构转换为问题解的( )结构**

·    A程序

·    B数据

·    C逻辑

·    D物理

正确答案:A

**（75）人机界面的风格大致经过了( )代的演变.**

·    A三

·    B四

·    C五

·    D六

正确答案:B

**（76）描述类中对象的行为，反映了状态与事件关系的是（ ）**

A数据流图

B状态图

C对象图

D结构图

正确答案:B

**（77）详细设计的任务是确定每个模块的（ ）**

·    A外部特性

·    B内部特性

·    C算法和使用的数据

·    D功能和输入输出数据

正确答案:C

**（78）指出PDL是下列（ ）语言**

·    A高级程序设计语言

·    B伪码

·    C中级程序设计语言

·    D低级程序设计语言

正确答案:B

**（79）软件设计的准则中不包括（　　）。**

·    A编程语言选择准则

·    B信息屏蔽准则

·    C结构化和模块化准则

·    D抽象准则

正确答案:A

**（80）需求分析的任务不包括( ).**

·    A问题分析

·    B系统设计

·    C需求描述

·    D需求评审.

正确答案:B

二、多选题

**（1）技术可行性考虑的问题有( )**

·    A开发风险分析

·    B资源分析

·    C相关技术的反展

正确答案:ABC

**（2）需求分析的任务包括( )**

·    A问题识别

·    B编写文档

·    C导出软件的物理模型

·    D导出软件的逻辑模型

正确答案:ABD

**（3）模块的基本属性有( )**

·    A接口

·    B参数

·    C功能

·    D逻辑

·    E状态

正确答案:ACDE

**（4）面向对象的特征有( )**

·    A对象唯一性

·    B分类性

·    C继承性

·    D抽象性

·    E多态性

正确答案:ABCE

**（5）软件工程的目标包括( )**

·    A付出较低的开发成本

·    B取得较好的软件性能

·    C易于移植

·    D能够按时完成开发任务

·    E较低的维护费用

·    F较高的软件可靠性

正确答案:ABCDEF

**（6）可行性研究的任务包括( )**

·    A技术可行性

·    B经济可行性

·    C社会可行性

·    D过程可行性

正确答案:ABC

**（7）软件工程的目标包括( )**

·    A付出较低的开发成本

·    B取得较好的软件性能

·    C易于移植

·    D能够按时完成开发任务

·    E较低的维护费用

·    F较高的软件可靠性

正确答案:ABCDEF

**（8）模块的基本属性有( )**

·    A接口

·    B参数

·    C功能

·    D逻辑

·    E状态

正确答案:ACDE

**（9）下列方法属于软件开发方法的是( )**

·    A结构化方法

·    BJackson方法

·    C维也纳开发方法

·    D面向对象的方法

正确答案:ABCD

**（10）面向对象的特征有( )**

·    A对象唯一性

·    B分类性

·    C继承性

·    D抽象性

·    E多态性

正确答案:ABCE

**（11）选择程序设计语言时，我们需要考虑的问题有( )**

·    A项目应用领域

·    B软件开发方法

·    C软件的执行环境

·    D算法和数据结构的复杂性

·    E软件开发人员的知识

正确答案:ABCDE

三、判断题

**（1）针对不同工作目标,软件项目计划有:项目实施计划、质量保证计划、软件测试计划、文档编制计划、用户培训计划、综合支持计划、软件发布计划( )**

·    A对

·    B错

正确答案:A

**（2）用等价类划分的方法设计测试用例的步骤为:划分等价类、确定测试用例( )**

·    A对

·    B错

正确答案:A

**（3）为了克服瀑布模型的局限性,使开发过程具有一定的灵活性和可修改性,于是产生了增量模型,它是在瀑布模型的基础上加以修改而形成的( )**

·    A对

·    B错

正确答案:A

**（4）数据流图有四个基本成分:数据流、加工、数据存储、数据的源点或终点( )**

·    A对

·    B错

正确答案:A

**（5）软件体系结构的几种模型包括:结构模型、框架模型、动态模型、过程模型( ))**

·    A对

·    B错

正确答案:A

**（6）软件的可维护性、可使用性、可靠性是衡量软件质量的几个主要特性( )**

·    A对

·    B错

正确答案:A

**（7）软件测试一般分为四个步骤:单元测试也称模块测试、集成测试也称组装测试,联合测试、确认测试也称验收测试,有效性测试、系统测试( )**

·    A对

·    B错

正确答案:A

**（8）瀑布模型本质上不是一种线性顺序模型( )**

·    A对

·    B错

正确答案:B

**（9）面向对象设计可分为系统设计和对象设计( )**

·    A对

·    B错

正确答案:A

**（10）类之间的连接关系是聚合关系;类之间整体与部分的关系是关联关系( )**

·    A对

·    B错

正确答案:B

**（11）渐增式测试:该测试是逐个把未经过测试的模块组装到已经测试过的模块上去,进行集成测试。每加入一个新模块进行一次集成的测试,重复此过程直至程序组装完毕( )**

·    A对

·    B错

正确答案:A

**（12）风险管理的活动有:(1)风险识别(2)风险分析(3)风险规划(4)风险控制( )**

·    A对

·    B错

正确答案:A

**（13）对象具有状态,一个对象用数据值来描述它的状态( )**

·    A对

·    B错

正确答案:A

**（14）对象建模的过程:确定类、准备数据字典、确定关联、确定属性、使用继承来细化类、完善对象模型( )**

·    A对

·    B错

正确答案:A

**（15）传统的SA方法主要用于数据处理方面的问题,主要工具DFD体现了系统的“做什么”功能,但它仅是一个静态模型,没有处理的顺序,即控制模型( )**

·    A对

·    B错

正确答案:A

**（16）Lethbridge对领域分析的理解是:领域分析是软件工程师了解背景信息的过程( )**

·    A对

·    B错

正确答案:A

**（17）CASE这一术语的英文是Computer Aided Software Engineering( )**

·    A对

·    B错

正确答案:A

**（18）3种可能的控制流机制分别是:过程驱动控制、事件驱动控制、线程驱动控制( )**

·    A对

·    B错

正确答案:A

**（19）大多数开发系统都采用基于文件集成的策略。**

·    A对

·    B错

正确答案:A

**（20）瀑布模型本质上是一种线性顺序模型。**

·    A对

·    B错

正确答案:A

**（21）支持设计、实现或测试等特定软件开发阶段的CASE工作台是一组软件包。()**

·    A对

·    B错

正确答案:B

**（22）需求分析要回答“软件必须做什么?”()**

·    A对

·    B错

正确答案:A

**（23）增量模型是一种整体开发模型。()**

·    A对

·    B错

正确答案:B

**（24）为了提高模块的独立性,模块内部最好是时间内聚。()**

·    A对

·    B错

正确答案:B

**（25）逻辑覆盖是黑盒测试方法之一（）**

·    A错误

·    B正确

正确答案:A

**（26）维护没有副作用。()**

·    A错误

·    B正确

正确答案:A

**（27）软件再工程是视图增加当前系统的总体质量、提高可维护性的工程。**

·    A错误

·    B正确

正确答案:B

**（28）维护没有副作用。( )**

·    A错误

·    B正确

正确答案:A

**（29）模型是对构架设计师和开发人员构造的系统的抽象（）**

·    A错误

·    B正确

正确答案:B

**（30）数据流图一般分为变换型数据流图和事务型数据流图两类（）**

·    A错误

·    B正确

正确答案:B

**（31）模块之间耦合性越强，独立性则越差（）**

·    A错误

·    B正确

正确答案:B

**（32）划分模块时，尽量做到低内聚、高耦合（）**

·    A错误

·    B正确

正确答案:A

**（33）软件再工程是试图增加当前系统的总体质量、提高可维护性的工程（ ）**

·    A错误

·    B正确

正确答案:B

**（34）深度是指结构图控制的层次，也是模块的层数（）**

·    A错误

·    B正确

正确答案:B

**（35）测试模型包括：测试用例、测试数据、测试构件。()**

·    A错误

·    B正确

正确答案:B

**（36）变换型数据处理的工作过程一般分为数据、变换数据和给出数据三步（）**

·    A错误

·    B正确

正确答案:B

**（37）维护技术通常由两类维护技术：面向维护的技术和维护支援技术（）**

·    A错误

·    B正确

正确答案:B

**（38）风险管理的活动有：（1）风险识别（2）风险分析（3）风险规划（4）风险控制**

·    A错误

·    B正确

正确答案:B

**（39）Booch方法的开发模型分静态模型和动态模型类型。( )**

·    A错误

·    B正确

正确答案:B

**（40）测试人员将一次迭代内测试工作的结果和测试计划建立的目标进行对比，做出评估，这一过程叫做评估测试。( )**

·    A错误

·    B正确

正确答案:B

**（41）通过黑盒测试主要发现以下错误：1）是否有不正确或遗漏了的功能。2）在接口上，能否正确地接受输入数据，能否产生正确的输出信息。3）访问外部信息是否有错。4）性能上是否满足要求等等。( )**

·    A错误

·    B正确

正确答案:B

**（42）桩模块用来代替被测模块所调用的模块。它的作用是返回被测模块所需的信息。( )**

·    A错误

·    B正确

正确答案:B

**（43）为了克服瀑布模型的局限性，使开发过程具有一定的灵活性和可修改性，于是产生了增量模型。它是在瀑布模型的基础上加以修改而形成的。**

·    A错误

·    B正确

正确答案:B

**（44）传统程序的复用以调用公共模块为主，而面向对象复用很多是用继承实现的。**

·    A错误

·    B正确

正确答案:B

**（45）对象具有状态，一个对象用数据值来描述它的状态。**

·    A错误

·    B正确

正确答案:B

**（46）任何程序都可以由顺序、选择及重复三种基本控制结构构造（）。**

·    A错误

·    B正确

正确答案:B

**（47）瀑布模型本质上不是一种线性顺序模型（ ）**

·    A错误

·    B正确

正确答案:A

**（48）分析的几项原则有：（1）组装与分解相结合的原则。（2）抽象化与具体化相结合的原则（3）封装原则（4）相关性原则（5）行为约束原则。( )**

·    A错误

·    B正确

正确答案:B

**（49）软件维护内容有四种：校正性维护，适应性维护，完善性维护和预防性维护（ ）**

·    A错误

·    B正确

正确答案:B

**（50）软件维护分为改正性维护、适应性维护、增强性维护（ ）**

·    A错误

·    B正确

正确答案:A

**（51）面向对象的特征：(1)对象唯一性(2)分类性(3)继承性(4)多态性(多形性)**

·    A错误

·    B正确

正确答案:B

**（52）软件调试方法一般分为动态测试方法、静态测试方法。动态测试方法中又根据测试用例的设计方法不同，分为黑盒测试、白盒测试两类（ ）**

·    A错误

·    B正确

正确答案:B

**（53）UI设计必须考虑软件使用者的体力和脑力，人的能力是界面设计原则的基础。**

·    A错误

·    B正确

正确答案:B

**（54）针对不同工作目标，软件项目计划有：项目实施计划、质量保证计划、软件测试计划、文档编制计划、用户培训计划、综合支持计划、软件发布计划。**

·    A错误

·    B正确

正确答案:B

**（55）静态测试是指通过运行程序发现问题（）**

·    A错误

·    B正确

正确答案:A

**（56）传统的SA方法主要用于数据处理方面的问题，主要工具DFD体现了系统的“做什么”功能，但它仅是一个静态模型，没有处理的顺序，即控制模型（ ）**

·    A错误

·    B正确

正确答案:B

**（57）用等价类划分的方法设计测试用例的步骤为：划分等价类、确定测试用例（ ）**

·    A错误

·    B正确

正确答案:B

**（58）面向对象设计可分为系统设计和对象设计（ ）**

·    A错误

·    B正确

正确答案:B

**（59）详细设计的基本任务有：算法设计、数据结构设计、物理设计、其他设计，例如代码设计、输入/输出格式设计、人机对话设计、编写详细设计说明书、评审。**

·    A错误

·    B正确

正确答案:B

**（60）概要设计的基本任务有：1）设计软件系统结构简称软件结构）2）数据结构及数据库设计3）编写概要设计文档4）评审。( )**

·    A错误

·    B正确

正确答案:B

**（61）偶然内聚是最强的内聚（）**

·    A错误

·    B正确

正确答案:A

**（62）类有三种复用方式：实例复用、继承复用、多态复用。**

·    A错误

·    B正确

正确答案:B

**（63）面向对象设计准则是：模块化，抽象信息隐藏，低耦合，高内聚。**

·    A错误

·    B正确

正确答案:B

**（64）面向对象软件的测试过程有：单元测试、集成测试、确认测试等。()**

·    A错误

·    B正确

正确答案:B

**（65）需求文档是需求分析阶段最重要的技术文档之一（）**

·    A错误

·    B正确

正确答案:B

**（66）CASE这一术语的英文是Computer Aided Software Engineering。**

·    A错误

·    B正确

正确答案:B

**（67）软件测试一般分为四个步骤：单元测试也称模块测试）、集成测试也称组装测试，联合测试）、确认测试也称验收测试，有效性测试）、系统测试。**

·    A错误

·    B正确

正确答案:B

**（68）非渐增式测试：该测试是首先对每个模块分别进行单元测试，然后再把所有的模块按设计要求组装在一起进行的测试。**

·    A错误

·    B正确

正确答案:B

**（69）基本的估算方法有自顶向下估算、自底向上估算、差别估算法等等。()**

·    A错误

·    B正确

正确答案:B

**（70）3种可能的控制流机制分别是：过程驱动控制、事件驱动控制、线程驱动控制（ ）**

·    A错误

·    B正确

正确答案:B

**（71）RUP设计的主要结果是设计模型，用来可视化的描述系统的实现。()**

·    A错误

·    B正确

正确答案:B

**（72）数据字典有以下四类条目：数据流、数据项、数据存储、基本加工。**

·    A错误

·    B正确

正确答案:B

**（73）UML是一种定义良好、易于表达、功能强大且普遍适用的建模语言。( )**

·    A错误

·    B正确

正确答案:B

**（74）软件项目计划有:（1）项目实施计划（软件开发计划）（2）质量保证计划（3）软件测试计划（4）文档编制计划（5）用户培训计划（6）综合支持计划（7）软件发布计划。( )**

·    A错误

·    B正确

正确答案:B

### 3.西交23秋《软件工程概论》在线作业

试卷总分:100 得分:100

一、单选题 (共 25 道试题,共 50 分)

**1.盒图也称为( )或Chapin图.这种表达方式取消了流程线,它强迫程序员以结构化方式思考和解决问题.**

A.流程图

B.框图

C.判定表

D.N-S图

 正确答案：D

**2.以下说法错误的是（）**

A.面向对象方法不仅支持过程抽象，而且支持数据抽象

B.某些面向对象的程序设计语言还支持参数化抽象

C.信息隐藏通过对象的封装性来实现

D.在面向对象方法中，类是最基本的模块

 正确答案：D

**3.将软件组装成系统的一种测试技术叫( ).**

A.集成测试

B.单元测试

C.集合测试

D.系统测试

正确答案： A

**4.黑盒测试是从（ ）观点出发的测试，白盒测试是从（ ）观点出发的测试。正确选项为（ ）**

A.开发人员、管理人员

B.用户、管理人员

C.用户、开发人员

D.开发人员、用户

正确答案：C

**5.一个CASE工作台是一组( ),支持设计、实现或测试等特定的软件开发阶段**

A.工具集

B.软件包

C.平台集

D.程序包

正确答案：A

**6.分层DFD是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（ ）**

A.细节

B.输入与输出

C.软件的作者

D.绘制的时间

正确答案：B

**7.黑盒测试是从（）观点出发的测试，白盒测试是从（）观点出发的测试。**

A.开发人员、管理人员

B.用户、管理人员

C.用户、开发人员

D.开发人员、用户

正确答案：C

**8.软件生存周期中时间最长的阶段是()。**

A.需求分析阶段

B.概要设计阶段

C.测试阶段

D.维护阶段

正确答案：D

**9.以下不属于白盒测试技术的是( )**

A.逻辑覆盖

B.基本路径测试

C.循环覆盖测试

D.等价类划分

正确答案：D 解析：属于黑盒测试

**10.软件设计的准则中不包括（　　）。**

A.编程语言选择准则

B.信息屏蔽准则

C.结构化和模块化准则

D.抽象准则

正确答案：A

**11.软件工程学的目的应该是最终解决软件生产的()问题。**

A.提高软件的开发效率

B.使软件生产工程化

C.消除软件的生产危机

D.加强软件的质量保证

正确答案：B

**12.分层的数据流图是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（ ）**

A.细节

B.输入与输出

C.软件的作者

D.绘制的时间

正确答案：B

**13.需求分析最终结果是产生( )**

A.项目开发计划

B.可行性分析报告

C.需求规格说明书

D.设计说明书

正确答案：C

**14.可行性研究的步骤中不包括( )的内容.**

A.复查初步分析结果.

B.研究现有的系统

C.导出新系统高层逻辑模型.

D.建立新系统的物理模型解法.

正确答案：C

**15.加工是对数据流图中不能再分解的基本加工的精确说明,下述()是加工的最核心。**

A.加工顺序

B.加工逻辑

C.执行频率

D.激发条件

正确答案：B

**16.同一类中有相同的数据结构，这是（ ）级别的共享**

A.不同应用

B.同一应用

C.不同类

D.同一类

正确答案：D

**17.以下说法错误的是（ ）**

A.对象具有很强的表达能力和描述功能

B.对象是人们要进行研究的任何事务

C.对象是封装的基本单位

D.类封装比对象封装更具体、更细致

正确答案：D

**18.人机界面的风格大致经过了( )代的演变.**

A.三

B.四

C.五

D.六

正确答案：B，解析：①命令和询问方式②菜单式③面向窗口的点选界面④HCI技术与超文本、多任务概念结合起来

**19.系统流程图是描述()的工具。**

A.逻辑系统

B.程序系统

C.体系系统

D.物理系统

正确答案：D解析：系统流程图是描绘物理系统的传统工具。是用图形符号以黑盒子形式描绘系统里面的每个部件（程序、文件、数据库、表格、人工过程等等）。表达的是信息在系统各部件之间流动的情况，而不是对信息进行加工处理的控制过程。

**20.SA方法是一种( )**

A.自顶向下逐层分解的分析方法

B.自底向上逐层分解的分析方法

C.面向对象的分析方法

D.其他都不是

正确答案：A 

**21.软件维护工作的最主要部分是（ ）**

A.校正性维护

B.适应性维护

C.完善性维护

D.预防性维护

正确答案： C

**22.瀑布模型是一种()。**

A.软件开发方法

B.软件生存周期

C.程序设计方法学

D.软件生存周期模型

正确答案：D

**23.原型化方法是一种()型的设计过程。**

A.自外向内

B.自顶向下

C.自内向外

D.自底向上

正确答案：A 

**24.传统的测试策略是从（ ）开始**

A.单元测试

B.集成测试

C.系统测试

D.人员测试

正确答案：A

**25.软件测试法中，（　　）主要分析程序的内部结构。**

A.白盒法

B.黑盒法

C.因果图法

D.错误推测法

正确答案：A

二、多选题 (共 5 道试题,共 10 分)

**26.选择程序设计语言时，我们需要考虑的问题有( )**

A.项目应用领域

B.软件开发方法

C.软件的执行环境

D.算法和数据结构的复杂性

E.软件开发人员的知识

正确答案：ABCDE

**27.下面关于软件的特征的有（）**

A.软件是逻辑的，而不是产品

B.软件是被开发和设计出来的，而不是传统意义上被制造的

C.软件的研制需要投入大量的、复杂的脑力劳动，成本高

D.软件研制不需要太多人力

正确答案：ABC 

**28.以下是常见的面向对象的方法有（）**

A.Booch方法

B.Coad／Yourdon方法

C.OMT方法

D.Jacobson方法

正确答案：解析：ABCD，Booch、UML、Coad、OMT、Jacobson，Jackson方法是一种面向数据结构的开发方法。       

**29.下列属于白盒测试的方法是( )**

A.语句覆盖

B.条件覆盖

C.路径覆盖

D.等价类覆盖

正确答案： ABC

**30.软件测试的方法有（）**

A.黑盒法

B.白盒法

C.空盒法

D.系统法

正确答案：AB

三、判断题 (共 20 道试题,共 40 分)

**31.渐增式测试:该测试是逐个把未经过测试的模块组装到已经测试过的模块上去,进行集成测试。每加入一个新模块进行一次集成的测试,重复此过程直至程序组装完毕( )**

正确答案：对

**32.针对不同工作目标，软件项目计划有：项目实施计划、质量保证计划、软件测试计划、文档编制计划、用户培训计划、综合支持计划、软件发布计划。（）**

正确答案：对

**33.通过功能分解可以完成数据流图的细化。（）**

正确答案：对

**34.测试人员将一次迭代内测试工作的结果和测试计划建立的目标进行对比，做出评估，这一过程叫做评估测试。()**

正确答案：对 

**35.面向对象的特征:(1)对象唯一性(2)分类性(3)继承性(4)多态性(多形性) ( )**

正确答案：对  

**36.软件维护费用增加的主要原因是维护的生产率非常低。( )**

正确答案：对   

**37.支持设计、实现或测试等特定软件开发阶段的CASE工作台是一组软件包。()**

正确答案：错    

**38.增量模型是一种整体开发模型。()**

正确答案：错     

**39.逻辑覆盖是黑盒测试方法之一（）**

正确答案：错    

**40.传统的SA方法主要用于数据处理方面的问题，主要工具DFD体现了系统的“做什么”功能，但它仅是一个静态模型，没有处理的顺序，即控制模型（）**

正确答案：对   

**41.对象具有状态，一个对象用数据值来描述它的状态。（）**

正确答案：对  

**42.数据字典有以下四类条目：数据流、数据项、数据存储、基本加工。()**

正确答案：对   

**43.传统软件开发方法的缺陷：（1）面向过程为主（2）软件结构稳定性差（3）软件开发的抽象力度小（4）软件重用未能得到很好的解决。（）**

正确答案：对    

**44.为了克服瀑布模型的局限性，使开发过程具有一定的灵活性和可修改性，于是产生了增量模型。它是在瀑布模型的基础上加以修改而形成的。（）**

正确答案：对     

**45.任何程序都可以由顺序、选择及重复三种基本控制结构构造（）。**

正确答案：对      

**46.UI设计必须考虑软件使用者的体力和脑力,人的能力是界面设计原则的基础()**

正确答案：对       

**47.软件维护内容有四种:校正性维护,适应性维护,完善性维护和预防性维护()**

正确答案：对        

**48.详细设计的基本任务有：算法设计、数据结构设计、物理设计、其他设计，例如代码设计、输入/输出格式设计、人机对话设计、编写详细设计说明书、评审（）。**

正确答案：对         

**49.面向对象设计可分为系统设计和对象设计（）**

正确答案：对  

**50.数据流图是SA方法中用于表示系统逻辑模型的一种工具（）。**

正确答案：对   

### 4.西交《软件工程概论》期末考试复习集

一、单选题：

**1.题目：从事物的组成部件及每个部件的属性,功能来认识事物.这种方法被称为(  )的方法.**

A.  面向对象

B.  面向数据

C.  面向过程

D.  面向属性

正确选项：A

 

**2.题目：对象模型的描述工具是（）**

A.  状态图

B.  数据流图

C.  对象图

D.  结构图

正确选项：C

 

**3.题目：软件的发展经历了(  )个发展阶段**

A.  1

B.  2

C.  3

D.  4

正确选项：D

 

**4.题目：在排序法中，（　　）是从未排序序列中依次取出元素，与已排序序列中的元素作比较，将其放入已排序序列的正确位置。**

A.  选择排序

B.  快速排序

C.  插入排序

D.  冒泡排序

正确选项：A

 

**5.题目：为改正软件系统中潜藏的错误而进行的维护活动称为(  )**

A.  纠错性维护

B.  适应性维护

C.  改善性维护

D.  预防性维护

正确选项：A

 

**6.题目：以下不属于白盒测试技术的是(  )**

A.  逻辑覆盖

B.  基本路径测试

C.  循环覆盖测试

D.  等价类划分

正确选项：D

 

**7.题目：软件测试方法中，黑盒测试方法和白盒测试方法是常用的方法，其中黑盒测试方法主要用于测试（）**

A.  结构合理性

B.  软件外部功能

C.  程序正确性

D.  程序内部逻辑

正确选项：B

 

**8.题目：一个软件的宽度是指其控制的(  ).**

A.  模块数

B.  层数

C.  跨度

D.  厚度

正确选项：C

 

**9.题目：分层的数据流图是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（）**

A.  细节

B.  输入与输出

C.  软件的作者

D.  绘制的时间

正确选项：B

 

**10.题目：为适应软件运行环境的变化而修改软件的活动称为(  ).**

A.  纠错性维护

B.  适应性维护

C.  改善性维护

D.  预防性维护

正确选项：B

 

**11.题目：程序内部的各个部分之间存在的联系，用结构图表达时，最关心的是模块的内聚性和（）**

A.  独立性

B.  有效性

C.  耦合性

D.  安全性

正确选项：C

 

**12.题目：当模块中包含复杂的条件组合,只有(  )能够清晰地表达出各种动作之间的对应关系.**

A.  判定表和判定树

B.  盒图

C.  流程图

D.  关系图

正确选项：A

 

**13.题目：Jackson方法在需求分析阶段的主要步骤不包括(   ).**

A.  了解实体行为

B.  标识实体与行为

C.  生成实体结构图

D.  创建软件系统模型

正确选项：A

 

**14.题目：软件维护工作的最主要部分是（）**

A.  校正性维护

B.  适应性维护

C.  完善性维护

D.  预防性维护

正确选项：C

 

**15.题目：以下说法错误的是（）**

A.  面向对象方法不仅支持过程抽象，而且支持数据抽象

B.  某些面向对象的程序设计语言还支持参数化抽象

C.  信息隐藏通过对象的封装性来实现

D.  在面向对象方法中，类是最基本的模块

正确选项：D，对象是最基本的模块

 

**16.题目：同一类中有相同的数据结构，这是（）级别的共享**

A.  不同应用

B.  同一应用

C.  不同类

D.  同一类

正确选项：D

 

**17.题目：对于集成测试，下列说法错误的是（）**

A.  应对每一个测试用例都执行测试规程

B.  应将测试结果与预期结果比较，研究两者的偏离原因

C.  将缺陷报告给相关构件工程师，不需要他们修改

D.  将缺陷报告给测试设计人员，由它们评估整个测试工作的结果

正确选项：C

 

**18.题目：软件工程方法得以实施的主要保证是（）**

A.  硬件环境

B.  开发人员的素质

C.  软件开发工具和软件开发的环境

D.  软件开发的环境

正确选项：C

 

**19.题目：实践表明,确定发生错误的位置和内在原因所需的工作量几乎占整个调试工作量的(  )**

A.  30

B.  50

C.  70

D.  90

正确选项：D

 

**20.题目：需求分析最终结果是产生（）**

A.  项目开发计划

B.  可行性分析报告

C.  需求规格说明书

D.  设计说明书

正确选项：C

 

**21.题目：SA方法是一种（）**

A.  自顶向下逐层分解的分析方法

B.  自底向上逐层分解的分析方法

C.  面向对象的分析方法

D.  其他都不是

正确选项：A

 

**22.题目：下面有关软件维护的叙述（）是正确的**

A.  设计软件时就应考虑到将来的可修改性

B.  维护软件是一件很吸引人的创造性工作

C.  维护软件就是改正软件中的错误

D.  谁编写软件就应由谁来维护这个软件

正确选项：A

 

**23.题目：以下说法错误的是（）**

A.  对象具有很强的表达能力和描述功能

B.  对象是人们要进行研究的任何事务

C.  对象是封装的基本单位

D.  类封装比对象封装更具体、更细致

正确选项：D

 

**24.题目：瀑布模型的问题是（）**

A.  用户容易参与开发

B.  缺乏灵活性

C.  用户与开发者易沟通

D.  适用可变需求

正确选项：B

 

**25.题目：研究软硬件资源的有效性是进行（）研究的一方面。**

A.  技术可行性

B.  经济可行性

C.  社会可行性

D.  操作可行性

正确选项：A

 

**26.题目：将软件组装成系统的一种测试技术叫(  ).**

A.  集成测试

B.  单元测试

C.  集合测试

D.  系统测试

正确选项：A

 

**27.题目：需求分析是（）**

A.  软件开发工作的基础

B.  软件生存周期的开始

C.  由系统分析员单独完成的

D.  由用户自己单独完成的

正确选项：A

 

**28.题目：检查软件产品是否符合需求定义的过程称为(  )。**

A.  集成测试

B.  确认测试

C.  验证测试

D.  验收测试

正确选项：B

 

**29.题目：软件生存周期包括可行性分析和项目开发计划、需求分析、概要设计、详细设计、编码、(  )、维护等活动。**

A.  应用

B.  测试

C.  检测

D.  其他答案都不正确

正确选项：B

 

**30.题目：软件生存周期中时间最长的阶段是(  )。**

A.  需求分析阶段

B.  概要设计阶段

C.  测试阶段

D.  维护阶段

正确选项：D

 

**31.题目：SA方法是一种(  )**

A.  自顶向下逐层分解的分析方法

B.  自底向上逐层分解的分析方法

C.  面向对象的分析方法

D.  其他都不是

正确选项：A

 

**32.题目：白盒测试方法重视(  )的度量**

A.  测试覆盖率

B.  测试数据多少

C.  测试费用

D.  测试周期

正确选项：A

 

**33.题目：程序的3中基本结构是(  )**

A.  过程、子程序、分程序

B.  顺序、条件、循环

C.  递归、堆栈、队列

D.  调用、返回、转移

正确选项：B

 

**34.题目：尽管有不合法的输入,软件仍能继续正常工作的能力是指(  )**

A.  兼容性

B.  可靠性

C.  容错性

D.  稳定性

正确选项：C

 

**35.题目：面向对象程序设计语言与其他程序设计语言的最主要差别是它具有(  )**

A.  模块性

B.  抽象性

C.  继承性

D.  共享性

正确选项：C

 

**36.题目：面向对象分析阶段建立的三个模型中,核心的模型是(  )模型。**

A.  功能

B.  动态

C.  对象

D.  分析

正确选项：C

 

**37.题目：软件是一种(   )产品**

A.  有形

B.  逻辑

C.  物质

D.  消耗

正确选项：B

 

**38.题目：研究软硬件资源的有效性是进行(  )研究的一方面**

A.  技术可行性

B.  经济可行性

C.  社会可行性

D.  操作可行性

正确选项：A

 

**39.题目：一个CASE工作台是一组(  ),支持设计、实现或测试等特定的软件开发阶段**

A.  工具集

B.  软件包

C.  平台集

D.  程序包

正确选项：A

 

二、多选题：

**1.题目：下列属于模块的耦合性类型的是(  )**

A.  程序耦合

B.  数据耦合

C.  标记耦合

D.  控制耦合

E.  公共耦合

正确选项：BCDE

 

**2.题目：选择程序设计语言时，我们需要考虑的问题有(  )**

A.  项目应用领域

B.  软件开发方法

C.  软件的执行环境

D.  算法和数据结构的复杂性

E.  软件开发人员的知识

正确选项：ABCDE

 

**3.题目：下列属于面向对象程序设计语言的是(  )**

A.  C++

B.  JAVA

C.  BASIC

D.  C#

E.  Smalltalk

正确选项：ABDE，Smalltalk是一种早期的面向对象编程语言，被认为是面向对象编程的奠基石。

 

**4.题目：软件工程的目标包括(  )**

A.  付出较低的开发成本

B.  取得较好的软件性能

C.  易于移植

D.  能够按时完成开发任务

E.  较低的维护费用

F.  较高的软件可靠性

正确选项：ABCDEF

 

**5.题目：面向对象的特征有(  )**

A.  对象唯一性

B.  分类性

C.  继承性

D.  抽象性

E.  多态性

正确选项：ABCE

 

**6.题目：Constantine提出的“组织范型”包括（）**

A.  封闭式范型

B.  随机式范型

C.  开放式范型

D.  同步式范型

正确选项：ABCD

Constantine提出的“组织范型”包括以下四种：

 

封闭式范型：按照传统的权力层次来组织项目组，适用于开发与过去已经做过的产品相似的软件。

 

随机式范型：团队松散，依靠成员的个人自发性，适用于需要创新和技术性突破的项目。

 

开放式范型：尝试结合封闭式和随机式的优点，成员合作完成工作，适合解决复杂的问题，但效率可能不如其他团队高。

 

同步式范型：团队有赖于问题的自然区分，不需要很多的交流即可共同解决问题。

 

**7.题目：软件测试的方法有（）**

A.  黑盒法

B.  白盒法

C.  空盒法

D.  系统法

正确选项：AB

 

**8.题目：可行性研究的任务包括(  )**

A.  技术可行性

B.  经济可行性

C.  社会可行性

D.  过程可行性

正确选项：ABC

 

**9.题目：需求分析的任务包括(  )**

A.  问题识别

B.  编写文档

C.  导出软件的物理模型

D.  导出软件的逻辑模型

正确选项：ABD

 

**10.题目：技术可行性考虑的问题有(  )**

A.  开发风险分析

B.  资源分析

C.  相关技术的反展

正确选项：ABC

 

三、判断题：

**1.题目：数据字典有以下四类条目：数据流、数据项、数据存储、基本加工。**

正确选项：对

 

**2.题目：RUP设计的主要结果是设计模型，用来可视化的描述系统的实现。(  )**

正确选项：对

 

**3.题目：3种可能的控制流机制分别是：过程驱动控制、事件驱动控制、线程驱动控制（）**

正确选项：对

 

**4.题目：螺旋模型将瀑布模型和增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。(  )**

正确选项：对

螺旋模型将瀑布模型和增量模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。

螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。

每个螺旋周期分为4个工作步骤：制定计划、风险分析、实施工程、用户评估。

 

**5.题目：基本的估算方法有自顶向下估算、自底向上估算、差别估算法等等。(  )**

正确选项：对

对于一个大型的软件项目，由于项目的复杂性，开发成本的估算不是一件简单的事，要进行一系列的估算处理。主要靠分解和类推的手段进行。基本估算方法分为3类。

 

1)自顶向下的估算方法这种方法的主要思想是从项目的整体出发，进行类推。即估算人员根据以前已完成项目所消耗的总成本(或总工作量)，来推算将要开发的软件的总成本(或总工作量)，然后按比例将它分配到各开发任务单元中去，再来检验它是否能满足要求。这种方法的优点是估算工作量小，速度快。缺点是对项目中的特殊困难估计不足，估算出来的成本盲目性大，有时会遗漏被开发软件的某些部分。

 

2)自底向上的估计法这种方法的主要思想是把待开发的软件细分，直到每一个子任务都已经明确所需要的开发工作量，然后把它们加起来，得到软件开发的总工作量。这是一种常见的估算方法。它的优点是估算各个部分的准确性高。缺点是缺少各项子任务之间相互联系所需要的工作量，还缺少许多与软件开发有关的系统级工作量(配置管理、质量管理、项目管理)。所以往往估算值偏低，必须用其他方法进行检验和校正。

 

3)差别估计法这种方法综合了上述两种方法的优点，其主要思想是把待开发的软件项目与过去已完成的软件项目进行类比，从其开发的各个子任务中区分出类似的部分和不同的部分。类似的部分按实际量进行计算，不同的部分则采用相应的方法进行估算。

 

**6.题目：可用性：系统在给定的时间点上根据需求说明成功地运行的概率。也可以说可用性是当有请求时即在一定时刻）系统能执行有用服务的可能性。(  )**

正确选项：对

软件可靠性的定义：程序在给定的时间间隔内，按照规格说明书的规定成功运行的概率。

 

软件可用性的定义：程序在给定的时间点，按照规格说明书的规定，成功运行的概率。

 

**7.题目：需求文档是需求分析阶段最重要的技术文档之一（）**

正确选项：对

 

**8.题目：面向对象软件的测试过程有：单元测试、集成测试、确认测试等。(  )**

正确选项：对

 

**9.题目：面向对象设计准则是：模块化，抽象信息隐藏，低耦合，高内聚。**

正确选项：对

 

**10.题目：渐增式测试：该测试是逐个把未经过测试的模块组装到已经测试过的模块上去，进行集成测试。每加入一个新模块进行一次集成的测试，重复此过程直至程序组装完毕（）**

正确选项：对

 

**11.题目：类有三种复用方式：实例复用、继承复用、多态复用。**

正确选项：对

 

**12.题目：偶然内聚是最强的内聚（）**

正确选项：错

最弱的是偶然内聚，功能内聚。这是最强的内聚

 

**13.题目：概要设计的基本任务有：1）设计软件系统结构简称软件结构）2）数据结构及数据库设计3）编写概要设计文档4）评审。(  )**

正确选项：对

 

**14.题目：详细设计的基本任务有：算法设计、数据结构设计、物理设计、其他设计，例如代码设计、输入/输出格式设计、人机对话设计、编写详细设计说明书、评审。**

正确选项：对

 

**15.题目：用等价类划分的方法设计测试用例的步骤为：划分等价类、确定测试用例（）**

正确选项：对

 

**16.题目：静态测试是指通过运行程序发现问题（）**

正确选项：错

指利用静态分析工具对被测软件进行特性分析。

 

**17.题目：针对不同工作目标，软件项目计划有：项目实施计划、质量保证计划、软件测试计划、文档编制计划、用户培训计划、综合支持计划、软件发布计划。**

正确选项：对

 

**18.题目：软件调试方法一般分为动态测试方法、静态测试方法。动态测试方法中又根据测试用例的设计方法不同，分为黑盒测试、白盒测试两类（）**

正确选项：对

 

**19.题目：软件维护费用增加的主要原因是维护的生产率非常低。**

正确选项：对

 

**20.题目：软件维护费用增加的主要原因是维护的生产率非常低。(  )**

正确选项：对

 

**21.题目：传统软件开发方法的缺陷：面向过程为主、软件结构稳定性差、软件开发的抽象力度小、软件重用未能得到很好的解决。**

正确选项：对

 

**22.题目：面向对象的特征：(1)对象唯一性(2)分类性(3)继承性(4)多态性(多形性)**

正确选项：对

 

**23.题目：Wirfs－Brock等人提出了种类－责任－协作者开发类图的卡片技术。该技术使用实际的或虚拟的索引卡片，为定义类提供较多的信息。**

正确选项：对

 

**24.题目：软件维护分为改正性维护、适应性维护、增强性维护（）**

正确选项：错

 

**25.题目：软件维护内容有四种：校正性维护，适应性维护，完善性维护和预防性维护（）**

正确选项：对

 

**26.题目：分析的几项原则有：组装与分解相结合的原则、抽象化与具体化相结合的原则、封装原则、相关性原则、行为约束原则。(  )** 

正确选项：对

 

**27.题目：Lethbridge对领域分析的理解是：领域分析是软件工程师了解背景信息的过程（）**

正确选项：对

 

**28.题目：IDEF0用来描述系统的功能活动及联系，建立系统的功能模型。(  )**

正确选项：对

 

**29.题目：软件体系结构的几种模型包括：结构模型、框架模型、动态模型、过程模型、功能模型**

正确选项：对

 

**30.题目：测试设计人员尤其看重的两条度量标准是：测试完全性、可靠性。**

正确选项：对

在软件测试中，测试完整性和可靠性是设计人员特别关注的两个度量标准。

 

测试完整性：指测试活动覆盖了所有预定的测试目标和需求，确保没有遗漏任何关键部分。

 

测试可靠性：指测试过程和结果的一致性和稳定性，确保测试能够重复执行并获得相同的结果。

 

**31.题目：Booch方法的开发模型分静态模型和动态模型类型。(  )**

正确选项：对

 

**32.题目：对象建模的过程：确定类、准备数据字典、确定关联、确定属性、使用继承来细化类、完善对象模型**

正确选项：对

 

**33.题目：划分模块时，尽量做到低内聚、高耦合（）**

正确选项：错

 

**34.题目：具有明确功能并可以分离出来的软件或硬件叫做构件（）**

正确选项：对

 

**35.题目：面向对象的方法包含面向对象分析、面向对象设计和面向对象实现（）**

正确选项：对

 

**36.题目：维护没有副作用。(  )**

正确选项：错

  

**37.题目：对象之间进行通信的一种构造叫消息（）**

正确选项：对

 

**38.题目：支持设计、实现或测试等特定软件开发阶段的CASE工作台是一组软件包。(  )**

正确选项：错

工具集

 

**39.题目：大多数开发系统都采用基于文件集成的策略。**

正确选项：对

 

**40.题目：“软件工程”概念的提出是为了克服软件危机(  )**

正确选项：对

 

**41.题目：3种可能的控制流机制分别是:过程驱动控制、事件驱动控制、线程驱动控制(  )**

正确选项：对

 

**42.题目：CASE这一术语的英文是ComputerAidedSoftwareEngineering(  )**

正确选项：对

 

**43.题目：Lethbridge对领域分析的理解是:领域分析是软件工程师了解背景信息的过程(  )**

正确选项：对

 

**44.题目：传统程序的复用以调用公共模块为主,而面向对象复用很多是用继承实现的(  )**

正确选项：对

 

**45.题目：软件维护分为改正性维护、适应性维护、增强性维护(  )**

正确选项：错

 

**46.题目：软件再工程是视图增加当前系统的总体质量、提高可维护性的工程(  )**

正确选项：对

 

四、主观填空题：

**1.题目：瀑布模型（）适应需求可变的软件开发,只有到（）才能见到整个软件系统。** 

正确选项：不

正确选项：开发结束

 

**2.题目：CASE这一术语的英文是（）。**

 正确选项：Computer　Aided　Software　Engineering

 

**3.题目：螺旋模型将（）模型和（）模型结合起来,加入了两种模型均忽略了的风险分析,弥补了这两种模型的不足。**

 正确选项：瀑布

正确选项：演化

 

**4.题目：构造原型的目的、方式及内容的取舍不同,原型特征可分为（）、（）、（）、（）四类。**

正确选项：系统的界面形式

正确选项：系统的总体结构

正确选项：系统的主要处理功能和性能

正确选项：数据库模式

 

**5.题目：软件开发环境是相关的一组（）的集合,它支持一定的软件开发方法或按照一定的软件开发模型组织而成的。**

正确选项：软件工具

  

**6.题目：软件工具通常由工具.工具接口和（）三部分构成。**

正确选项：工具用户接口

 

**7.题目：变换模型是一种适合于（）方法的模型。从（）开始,经过一系列（）,最终得到系统的目标程序。**

正确选项：形式化开发

正确选项：软件需求形式化说明

正确选项：变换

 

五、简答题：

**1.题目：软件产品具有哪些特性?**

正确选项：软件是一种逻辑产品，不是客观存在的实体，具有无形性，它是脑力劳动的结晶，它以程序和文档的形式保存在计算机存储器的磁盘和光盘介质上，通过操作计算机才能体现它的功能和作用。软件产品的生产主要是研制，软件产品的成本主要体现在软件的开发和研制上，软件开发研制完成后，通过复制就可以产生大量的软件产品，不需要再花费人力、物力。软件产品不会用坏，不存在磨损、消耗等问题。软件产品的生产主要是脑力劳动，还未完全摆脱手工开发方式，大部分产品是“定做”的。软件费用不断增加，软件成本相当昂贵。软件的研制工作需要投入大量的、复杂的、高强度的脑力劳动，它的成本非常高。

 

**2.题目：什么是软件生存周期模型?有哪些主要模型?**

正确选项：软件生存周期模型是描述软件开发过程中各种活动如何执行的模型。软件生存周期模型确立了软件开发和演绎中各阶段的次序限制以及各阶段活动的准则，确立了开发过程所遵守的规定和限制。主要的软件生存周期模型有瀑布模型、增量模型、螺旋模型、喷泉模型、变换模型和基于知识的模型。

 

**3.题目：什么是软件生存周期?它有哪些活动?**

正确选项：软件生存周期是指一个软件从提出开发要求开始直到该软件报废为止的整个时期。软件生存周期包括可行性分析和项目开发计划、需求分析、概要设计、详细设计、编码、测试、维护等活动，可以将这些活动以适当的方式分配到不同阶段去完成。

 

**4.题目：什么是实验型原型模型?**

正确选项：这是一种把原型思想用于设计阶段的快速原型模型。若对于一个大型软件系统的设计方案没有把握时，要考核设计方案是否正确、能否实现，可通过原型模型的开发运行来证实。一旦通过原型模型的开发运行，证实设计方案是正确的、能实现的，可废弃这个原型，按照开发过程来开发。

 

### 5.西交新学期《软件工程概论》在线作业一

一、单选题

1. **盒图也称为(  )或Chapin图.这种表达方式取消了流程线,它强迫程序员以结构化方式思考和解决问题.**

选项A：流程图

选项B：框图

选项C：判定表

选项D：N-S图

参考答案：D

 

2. **以下说法错误的是（）**

选项A：面向对象方法不仅支持过程抽象，而且支持数据抽象

选项B：某些面向对象的程序设计语言还支持参数化抽象

选项C：信息隐藏通过对象的封装性来实现

选项D：在面向对象方法中，类是最基本的模块

参考答案：D

 

3. **将软件组装成系统的一种测试技术叫( ).**

选项A：集成测试

选项B：单元测试

选项C：集合测试

选项D：系统测试

参考答案：A

 

4. **黑盒测试是从（ ）观点出发的测试，白盒测试是从（ ）观点出发的测试。正确选项为（ ）**

选项A：开发人员、管理人员

选项B：用户、管理人员

选项C：用户、开发人员

选项D：开发人员、用户

参考答案：C

 

5. **一个CASE工作台是一组(  ),支持设计、实现或测试等特定的软件开发阶段**

选项A：工具集

选项B：软件包

选项C：平台集

选项D：程序包

参考答案：A

 

6. **分层DFD是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（ ）**

选项A：细节

选项B：输入与输出

选项C：软件的作者

选项D：绘制的时间

参考答案：B

 

**7.软件生存周期中时间最长的阶段是()。**

选项A：需求分析阶段

选项B：概要设计阶段

选项C：测试阶段

选项D：维护阶段

参考答案：D

 

**8.以下不属于白盒测试技术的是(  )**

选项A：逻辑覆盖

选项B：基本路径测试

选项C：循环覆盖测试

选项D：等价类划分

参考答案：D

 

**9.软件设计的准则中不包括（　　）。**

选项A：编程语言选择准则

选项B：信息屏蔽准则

选项C：结构化和模块化准则

选项D：抽象准则

参考答案：A

 

**10.软件工程学的目的应该是最终解决软件生产的()问题。**

选项A：提高软件的开发效率

选项B：使软件生产工程化

选项C：消除软件的生产危机

选项D：加强软件的质量保证

参考答案：B

 

**11.分层的数据流图是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（  ）**

选项A：细节

选项B：输入与输出

选项C：软件的作者

选项D：绘制的时间

参考答案：B

 

**12.需求分析最终结果是产生(  )**

选项A：项目开发计划

选项B：可行性分析报告

选项C：需求规格说明书

选项D：设计说明书

参考答案：C

 

**13.可行性研究的步骤中不包括( )的内容.**

选项A：复查初步分析结果.

选项B：研究现有的系统

选项C：导出新系统高层逻辑模型.

选项D：建立新系统的物理模型解法.

参考答案：C

 

**14.加工是对数据流图中不能再分解的基本加工的精确说明,下述()是加工的最核心。**

选项A：加工顺序

选项B：加工逻辑

选项C：执行频率

选项D：激发条件

参考答案：B

 

**15.同一类中有相同的数据结构，这是（ ）级别的共享**

选项A：不同应用

选项B：同一应用

选项C：不同类

选项D：同一类

参考答案：D

 

**16.以下说法错误的是（ ）**

选项A：对象具有很强的表达能力和描述功能

选项B：对象是人们要进行研究的任何事务

选项C：对象是封装的基本单位

选项D：类封装比对象封装更具体、更细致

参考答案：D

 

**17.人机界面的风格大致经过了(  )代的演变.**

选项A：三

选项B：四

选项C：五

选项D：六

参考答案：B

 

**18.系统流程图是描述()的工具。**

选项A：逻辑系统

选项B：程序系统

选项C：体系系统

选项D：物理系统

参考答案：D

 

**19.SA方法是一种( )**

选项A：自顶向下逐层分解的分析方法

选项B：自底向上逐层分解的分析方法

选项C：面向对象的分析方法

选项D：其他都不是

参考答案：A

 

**20.软件维护工作的最主要部分是（ ）**

选项A：校正性维护

选项B：适应性维护

选项C：完善性维护

选项D：预防性维护

参考答案：C

 

**21.瀑布模型是一种()。**

选项A：软件开发方法

选项B：软件生存周期

选项C：程序设计方法学

选项D：软件生存周期模型

参考答案：D

 

**22.原型化方法是一种()型的设计过程。**

选项A：自外向内

选项B：自顶向下

选项C：自内向外

选项D：自底向上

参考答案：A

 

**23.传统的测试策略是从（ ）开始**

选项A：单元测试

选项B：集成测试

选项C：系统测试

选项D：人员测试

参考答案：A

 

**24.软件测试法中，（　　）主要分析程序的内部结构。**

选项A：白盒法

选项B：黑盒法

选项C：因果图法

选项D：错误推测法

参考答案：A



 二、多选题

**25.选择程序设计语言时，我们需要考虑的问题有(  )**

选项A：项目应用领域

选项B：软件开发方法

选项C：软件的执行环境

选项D：算法和数据结构的复杂性

选项E：软件开发人员的知识

参考答案：A,B,C,D,E

 

**26.下面关于软件的特特征的有（）**

选项A：软件是逻辑的，而不是产品

选项B：软件是被开发和设计出来的，而不是传统意义上被制造的

选项C：软件的研制需要投入大量的、复杂的脑力劳动，成本高

选项D：软件研制不需要太多人力

参考答案：A,B,C

 

**27.以下是常见的面向对象的方法有（）**

选项A：Booch方法

选项B：Coad／Yourdon方法

选项C：OMT方法

选项D：Jacobson方法

参考答案：A,B,C,D

 

**28.下列属于白盒测试的方法是(  )**

选项A：语句覆盖

选项B：条件覆盖

选项C：路径覆盖

选项D：等价类覆盖

参考答案：A,B,C

 

**29.软件测试的方法有（）**

选项A：黑盒法

选项B：白盒法

选项C：空盒法

选项D：系统法

参考答案：A,B

 

三、判断题

**30.渐增式测试:该测试是逐个把未经过测试的模块组装到已经测试过的模块上去,进行集成测试。每加入一个新模块进行一次集成的测试,重复此过程直至程序组装完毕( )**

选项A：对

选项B：错

参考答案：A

 

**31.针对不同工作目标，软件项目计划有：项目实施计划、质量保证计划、软件测试计划、文档编制计划、用户培训计划、综合支持计划、软件发布计划。**

选项A：错误

选项B：正确

参考答案：B

 

**32.通过功能分解可以完成数据流图的细化。**

选项A：对

选项B：错

参考答案：A

 

**33.测试人员将一次迭代内测试工作的结果和测试计划建立的目标进行对比，做出评估，这一过程叫做评估测试。( )**

选项A：错误

选项B：正确

参考答案：B

 

**34.面向对象的特征:(1)对象唯一性(2)分类性(3)继承性(4)多态性(多形性) ( )**

选项A：对

选项B：错

参考答案：A

 

**35.软件维护费用增加的主要原因是维护的生产率非常低。( )**

选项A：错误

选项B：正确

参考答案：B

 

**36.支持设计、实现或测试等特定软件开发阶段的CASE工作台是一组软件包。()**

选项A：对

选项B：错

参考答案：B

 

**37.增量模型是一种整体开发模型。()**

选项A：对

选项B：错

参考答案：B

 

**38.逻辑覆盖是黑盒测试方法之一（）**

选项A：错误

选项B：正确

参考答案：A

 

**39.传统的SA方法主要用于数据处理方面的问题，主要工具DFD体现了系统的“做什么”功能，但它仅是一个静态模型，没有处理的顺序，即控制模型（ ）**

选项A：错误

选项B：正确

参考答案：B

 

**40.对象具有状态，一个对象用数据值来描述它的状态。**

选项A：错误

选项B：正确

参考答案：B

 

**41.数据字典有以下四类条目：数据流、数据项、数据存储、基本加工。( )**

选项A：错误

选项B：正确

参考答案：B

 

**42.传统软件开发方法的缺陷：（1）面向过程为主（2）软件结构稳定性差（3）软件开发的抽象力度小（4）软件重用未能得到很好的解决。**

选项A：错误

选项B：正确

参考答案：B

 

**43.为了克服瀑布模型的局限性，使开发过程具有一定的灵活性和可修改性，于是产生了增量模型。它是在瀑布模型的基础上加以修改而形成的。**

选项A：错误

选项B：正确

参考答案：B

 

**44.任何程序都可以由顺序、选择及重复三种基本控制结构构造（）。**

选项A：错误

选项B：正确

参考答案：B

 

**45.UI设计必须考虑软件使用者的体力和脑力,人的能力是界面设计原则的基础( )**

选项A：对

选项B：错

参考答案：A

 

**46.软件维护内容有四种:校正性维护,适应性维护,完善性维护和预防性维护( )**

选项A：对

选项B：错

参考答案：A

 

**47.详细设计的基本任务有：算法设计、数据结构设计、物理设计、其他设计，例如代码设计、输入/输出格式设计、人机对话设计、编写详细设计说明书、评审。**

选项A：错误

选项B：正确

参考答案：B

 

**48.面向对象设计可分为系统设计和对象设计（ ）**

选项A：错误

选项B：正确

参考答案：B

 

**49.数据流图是SA方法中用于表示系统逻辑模型的一种工具（）。**

选项A：错误

选项B：正确

参考答案：B

  

### 6.西交17春《软件工程概论》在线作业

试卷总分:100  得分:100

一、 单选题 (共 19 道试题,共 38 分)

1. **对象模型的描述工具是（）**

A. 状态图

B. 数据流图

C. 对象图

D. 结构图

   满分：2 分

正确答案:C

 

2. **软件测试的目的是（）**

A. 证明软件的正确性

B. 找出软件系统中存在的所有错误

C. 证明软件系统中存在错误

D. 尽可能多的发现软件系统中的错误

   满分：2 分

正确答案:B

 

3. **传统的测试策略是从（）开始**

A. 单元测试

B. 集成测试

C. 系统测试

D. 人员测试

   满分：2 分

正确答案:A

 

4. **软件维护工作的最主要部分是（）**

A. 校正性维护

B. 适应性维护

C. 完善性维护

D. 预防性维护

   满分：2 分

正确答案:C

 

5. **以下不属于软件维护的困难表现的是（）**

A. 读懂别人的程序是困难的

B. 文档的不一致性

C. 源程序及相关文档的错误或丢失

D. 软件开发和软件维护在人员和时间上的差异

   满分：2 分

正确答案:C

 

6. **在软件生存周期中，工作量所占比例最大的阶段是（）阶段**

A. 需求分析

B. 设计

C. 测试

D. 维护

   满分：2 分

正确答案:D

 

7. **同一类中有相同的数据结构，这是（）级别的共享**

A. 不同应用

B. 同一应用

C. 不同类

D. 同一类

   满分：2 分

正确答案:D

  

8. **内容耦合指（）**

A. 两个模块之间传递的是数据结构

B. 一个模块调用另一个模块时，传递的是控制变量

C. 通过一个公共数据环境相互作用的哪些模块间的耦合

D. 一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部

   满分：2 分

正确答案:D

 

9. **以下说法错误的是（）**

A. 面向对象分析与面向对象设计的定义没有明显的区别

B. 在实际的软件开发过程中面向对象分析与面向对象设计的界限是模糊的

C. 面向对象分析和面向对象设计活动是一个多次反复迭代的过程

D. 从面向对象分析到面向对象设计，是一个逐渐扩充模型的过程

   满分：2 分

正确答案:A

 

10. **以下说法错误的是（）**

A. 面向对象方法不仅支持过程抽象，而且支持数据抽象

B. 某些面向对象的程序设计语言还支持参数化抽象

C. 信息隐蔽通过对象的封装来实现

D. 在面向对象方法中，类是最基本的模块

   满分：2 分

正确答案:D

 

11. **以下说法错误的是（）**

A. 面向对象方法不仅支持过程抽象，而且支持数据抽象

B. 某些面向对象的程序设计语言还支持参数化抽象

C. 信息隐藏通过对象的封装性来实现

D. 在面向对象方法中，类是最基本的模块

   满分：2 分

正确答案:D

  

12. **指出PDL是下列（）语言**

A. 高级程序设计语言

B. 伪码

C. 中级程序设计语言

D. 低级程序设计语言

   满分：2 分

正确答案:B

 

13. **下面错误的说法是（）**

A. 每个数据流必须用名词或名词短语命名

B. 每个加工必须有名字，通常是动词短语

C. 每个数据存储必须用名词或名词短语

D. 每个数据源点或终点必须有名字

   满分：2 分

正确答案:A

 

14. **需求分析是（）**

A. 软件开发工作的基础

B. 软件生存周期的开始

C. 由系统分析员单独完成的

D. 由用户自己单独完成的

   满分：2 分

正确答案:A

 

15. **软件工程方法得以实施的主要保证是（）**

A. 硬件环境

B. 开发人员的素质

C. 软件开发工具和软件开发的环境

D. 软件开发的环境

   满分：2 分

正确答案:C

  

16. **软件测试方法中，黑盒测试方法和白盒测试方法是常用的方法，其中黑盒测试方法主要用于测试（）**

A. 结构合理性

B. 软件外部功能

C. 程序正确性

D. 程序内部逻辑

   满分：2 分

正确答案:B



17. **瀑布模型的问题是（）**

A. 用户容易参与开发

B. 缺乏灵活性

C. 用户与开发者易沟通

D. 适用可变需求

   满分：2 分

正确答案:B

  

18. **对于集成测试，下列说法错误的是（）**

A. 应对每一个测试用例都执行测试规程

B. 应将测试结果与预期结果比较，研究两者的偏离原因

C. 将缺陷报告给相关构件工程师，不需要他们修改

D. 将缺陷报告给测试设计人员，由它们评估整个测试工作的结果

   满分：2 分

正确答案:C

  

19. **分层DFD是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（）**

A. 细节

B. 输入与输出

C. 软件的作者

D. 绘制的时间

   满分：2 分

正确答案:B

 

二、 多选题 (共 1 道试题,共 2 分)

1. **Constantine提出的“组织范型”包括（）**

A. 封闭式范型

B. 随机式范型

C. 开放式范型

D. 同步式范型

   满分：2 分

正确答案:ABCD

  

三、 判断题 (共 30 道试题,共 60 分)

1. **通过黑盒测试主要发现以下错误：1）是否有不正确或遗漏了的功能。2）在接口上，能否正确地接受输入数据，能否产生正确的输出信息。3）访问外部信息是否有错。4）性能上是否满足要求等等。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

  

2. **Wirfs－Brock等人提出了种类－责任－协作者开发类图的卡片技术。该技术使用实际的或虚拟的索引卡片，为定义类提供较多的信息。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

3. **IDEF0用来描述系统的功能活动及联系，建立系统的功能模型。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

4. **传统软件开发方法的缺陷：（1）面向过程为主（2）软件结构稳定性差（3）软件开发的抽象力度小（4）软件重用未能得到很好的解决。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B 

 

5. **测试人员将一次迭代内测试工作的结果和测试计划建立的目标进行对比，做出评估，这一过程叫做评估测试。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

6. **可用性：系统在给定的时间点上根据需求说明成功地运行的概率。也可以说可用性是当有请求时即在一定时刻）系统能执行有用服务的可能性。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

7. **软件维护费用增加的主要原因是维护的生产率非常低。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

8. **基本的估算方法有自顶向下估算、自底向上估算、差别估算法等等。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

9. **带来高维护费用的关键因素有：人员的不稳定、合同责任、维护人员技术水平、系统结构衰退。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

  

10. **数据字典有以下四类条目：数据流、数据项、数据存储、基本加工。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

  

11. **类有三种复用方式：实例复用、继承复用、多态复用。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

12. **维护没有副作用。()**

A. 错误

B. 正确

   满分：2 分

正确答案:A

 

13. **测试模型包括：测试用例、测试过程、测试构件。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

14. **软件层次一般分为专用应用层、通用应用层、中间件层、系统软件层四个层。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

15. **Booch方法的开发模型分静态模型和动态模型类型。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

  

16. **分析的几项原则有：（1）组装与分解相结合的原则。（2）抽象化与具体化相结合的原则（3）封装原则（4）相关性原则（5）行为约束原则。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

17. **软件项目计划有:（1）项目实施计划（软件开发计划）（2）质量保证计划（3）软件测试计划（4）文档编制计划（5）用户培训计划（6）综合支持计划（7）软件发布计划。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

18. **面向对象软件的测试过程有：单元测试、集成测试、确认测试等。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

19. **内聚性是一个构件内部各种元素彼此结合的紧密程度的度量。包括：偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、功能内聚。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

20. **软件的可维护性、可使用性、可靠性是衡量软件质量的几个主要特性。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

21. **桩模块用来代替被测模块所调用的模块。它的作用是返回被测模块所需的信息。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

  

22. **软件工程是用科学知识和技术原理来定义、开发、维护软件的一门学科。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

  

23. **在需求分析阶段，首先进行问题识别，即双方确定对问题的综合需求，这些需求包括：功能需求、性能需求、环境需求、用户界面需求。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

24. **UML是一种定义良好、易于表达、功能强大且普遍适用的建模语言。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

25. **Wasserman1995提出了5种创建设计的方法：模块化分解、面向数据的分解、面向事件的分解、由外往内的设计、面向对象的设计。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

26. **非渐增式测试：该测试是首先对每个模块分别进行单元测试，然后再把所有的模块按设计要求组装在一起进行的测试。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

27. **螺旋模型将瀑布模型和增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

28. **RUP设计的主要结果是设计模型，用来可视化的描述系统的实现。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

  

29. **概要设计的基本任务有：1）设计软件系统结构简称软件结构）2）数据结构及数据库设计3）编写概要设计文档4）评审。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

30. **软件生存周期包括可行性研究、项目开发计划、需求分析、软件设计、编码、测试、维护等活动。()**

A. 错误

B. 正确

   满分：2 分

正确答案:B

 

### 7.西交《软件工程概论》在线作业

试卷总分：100    测试时间：--    试卷得分：100

一、单选题（共 19 道试题，共 38 分。）  得分：38

1. **下面错误的说法是（）**

A. 每个数据流必须用名词或名词短语命名

B. 每个加工必须有名字，通常是动词短语

C. 每个数据存储必须用名词或名词短语

D. 每个数据源点或终点必须有名字

答案:A

满分：2 分 得分：2

2. **软件测试的目的是（）**

A. 证明软件的正确性

B. 找出软件系统中存在的所有错误

C. 证明软件系统中存在错误

D. 尽可能多的发现软件系统中的错误

答案:B

满分：2 分 得分：2

3. **瀑布模型的问题是（）**

A. 用户容易参与开发

B. 缺乏灵活性

C. 用户与开发者易沟通

D. 适用可变需求

答案:B

满分：2 分 得分：2

4. **传统的测试策略是从（）开始**

A. 单元测试

B. 集成测试

C. 系统测试

D. 人员测试

答案:A

满分：2 分 得分：2

5. **对象模型的描述工具是（）**

A. 状态图

B. 数据流图

C. 对象图

D. 结构图

答案:C

满分：2 分 得分：2

6. **以下说法错误的是（）**

A. 面向对象方法不仅支持过程抽象，而且支持数据抽象

B. 某些面向对象的程序设计语言还支持参数化抽象

C. 信息隐蔽通过对象的封装来实现

D. 在面向对象方法中，类是最基本的模块

答案:D

满分：2 分 得分：2

7. **软件工程方法得以实施的主要保证是（）**

A. 硬件环境

B. 开发人员的素质

C. 软件开发工具和软件开发的环境

D. 软件开发的环境

答案:C

满分：2 分  得分：2

8. **以下不属于软件维护的困难表现的是（）**

A. 读懂别人的程序是困难的

B. 文档的不一致性

C. 源程序及相关文档的错误或丢失

D. 软件开发和软件维护在人员和时间上的差异

答案:C

满分：2 分 得分：2

9. **在软件生存周期中，工作量所占比例最大的阶段是（）阶段**

A. 需求分析

B. 设计

C. 测试

D. 维护   

答案:D

满分：2 分 得分：2

10. **指出PDL是下列（）语言**

A. 高级程序设计语言

B. 伪码

C. 中级程序设计语言

D. 低级程序设计语言

答案:B

满分：2 分 得分：2

11. **软件测试方法中，黑盒测试方法和白盒测试方法是常用的方法，其中黑盒测试方法主要用于测试（）**

A. 结构合理性

B. 软件外部功能

C. 程序正确性

D. 程序内部逻辑

答案:B

满分：2 分 得分：2

12. **以下说法错误的是（）**

A. 面向对象分析与面向对象设计的定义没有明显的区别

B. 在实际的软件开发过程中面向对象分析与面向对象设计的界限是模糊的

C. 面向对象分析和面向对象设计活动是一个多次反复迭代的过程

D. 从面向对象分析到面向对象设计，是一个逐渐扩充模型的过程

答案:A

满分：2 分 得分：2

13. **分层DFD是一种比较严格又易于理解的描述方式，它的顶层图描述了系统的（）**

A. 细节

B. 输入与输出

C. 软件的作者

D. 绘制的时间

答案:B

满分：2 分 得分：2

14. **对于集成测试，下列说法错误的是（）**

A. 应对每一个测试用例都执行测试规程

B. 应将测试结果与预期结果比较，研究两者的偏离原因

C. 将缺陷报告给相关构件工程师，不需要他们修改

D. 将缺陷报告给测试设计人员，由它们评估整个测试工作的结果

答案:C

满分：2 分 得分：2

15. **同一类中有相同的数据结构，这是（）级别的共享**

A. 不同应用

B. 同一应用

C. 不同类

D. 同一类

答案:D

满分：2 分 得分：2

16. **以下说法错误的是（）**

A. 面向对象方法不仅支持过程抽象，而且支持数据抽象

B. 某些面向对象的程序设计语言还支持参数化抽象

C. 信息隐藏通过对象的封装性来实现

D. 在面向对象方法中，类是最基本的模块

答案:D

满分：2 分 得分：2

17. **软件维护工作的最主要部分是（）**

A. 校正性维护

B. 适应性维护

C. 完善性维护

D. 预防性维护   

答案:C

满分：2 分 得分：2

18. **需求分析是（）**

A. 软件开发工作的基础

B. 软件生存周期的开始

C. 由系统分析员单独完成的

D. 由用户自己单独完成的

答案:A

满分：2 分 得分：2

19. **内容耦合指（）**

A. 两个模块之间传递的是数据结构

B. 一个模块调用另一个模块时，传递的是控制变量

C. 通过一个公共数据环境相互作用的哪些模块间的耦合

D. 一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部

答案:D

满分：2 分 得分：2

二、多选题（共 1 道试题，共 2 分。）  得分：2

1. **Constantine提出的“组织范型”包括（）**

A. 封闭式范型

B. 随机式范型

C. 开放式范型

D. 同步式范型   

答案:ABCD

满分：2 分 得分：2

三、判断题（共 30 道试题，共 60 分。）  得分：60

1. **类有三种复用方式：实例复用、继承复用、多态复用。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

2. **IDEF0用来描述系统的功能活动及联系，建立系统的功能模型。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

3. **螺旋模型将瀑布模型和增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

4. **在需求分析阶段，首先进行问题识别，即双方确定对问题的综合需求，这些需求包括：功能需求、性能需求、环境需求、用户界面需求。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

5. **软件层次一般分为专用应用层、通用应用层、中间件层、系统软件层四个层。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

6. **UML是一种定义良好、易于表达、功能强大且普遍适用的建模语言。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

7. **Booch方法的开发模型分静态模型和动态模型类型。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

8. **软件生存周期包括可行性研究、项目开发计划、需求分析、软件设计、编码、测试、维护等活动。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

9. **内聚性是一个构件内部各种元素彼此结合的紧密程度的度量。包括：偶然内聚、逻辑内聚、时间内聚、过程内聚、通信内聚、顺序内聚、功能内聚。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

10. **带来高维护费用的关键因素有：人员的不稳定、合同责任、维护人员技术水平、系统结构衰退。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

11. **软件维护费用增加的主要原因是维护的生产率非常低。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

12. **软件的可维护性、可使用性、可靠性是衡量软件质量的几个主要特性。()**

A. 错误

B. 正确   

答案:B

满分：2 分 得分：2

13. **软件项目计划有:（1）项目实施计划（软件开发计划）（2）质量保证计划（3）软件测试计划（4）文档编制计划（5）用户培训计划（6）综合支持计划（7）软件发布计划。()**

A. 错误

B. 正确 

答案:B

满分：2 分 得分：2

14. **测试模型包括：测试用例、测试用例、测试构件。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

15. **基本的估算方法有自顶向下估算、自底向上估算、差别估算法等等。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

16. **Wirfs－Brock等人提出了种类－责任－协作者开发类图的卡片技术。该技术使用实际的或虚拟的索引卡片，为定义类提供较多的信息。()**

A. 错误

B. 正确   

答案:B

满分：2 分 得分：2

17. **面向对象软件的测试过程有：单元测试、集成测试、确认测试等。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

18. **通过黑盒测试主要发现以下错误：1）是否有不正确或遗漏了的功能。2）在接口上，能否正确地接受输入数据，能否产生正确的输出信息。3）访问外部信息是否有错。4）性能上是否满足要求等等。()**

A. 错误

B. 正确   

答案:B

满分：2 分 得分：2

19. **RUP设计的主要结果是设计模型，用来可视化的描述系统的实现。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

20. **可用性：系统在给定的时间点上根据需求说明成功地运行的概率。也可以说可用性是当有请求时即在一定时刻）系统能执行有用服务的可能性。()**

A. 错误

B. 正确  

答案:B

满分：2 分 得分：2

21. **传统软件开发方法的缺陷：（1）面向过程为主（2）软件结构稳定性差（3）软件开发的抽象力度小（4）软件重用未能得到很好的解决。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

22. **分析的几项原则有：（1）组装与分解相结合的原则。（2）抽象化与具体化相结合的原则（3）封装原则（4）相关性原则（5）行为约束原则。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

23. **Wasserman1995提出了5种创建设计的方法：模块化分解、面向数据的分解、面向事件的分解、由外往内的设计、面向对象的设计。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

24. **数据字典有以下四类条目：数据流、数据项、数据存储、基本加工。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

25. **测试人员将一次迭代内测试工作的结果和测试计划建立的目标进行对比，做出评估，这一过程叫做评估测试。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

26. **软件工程是用科学知识和技术原理来定义、开发、维护软件的一门学科。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

27. **概要设计的基本任务有：1）设计软件系统结构简称软件结构）2）数据结构及数据库设计3）编写概要设计文档4）评审。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

28. **维护没有副作用。()**

A. 错误

B. 正确   

答案:A

满分：2 分 得分：2

29. **非渐增式测试：该测试是首先对每个模块分别进行单元测试，然后再把所有的模块按设计要求组装在一起进行的测试。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2

30. **桩模块用来代替被测模块所调用的模块。它的作用是返回被测模块所需的信息。()**

A. 错误

B. 正确

答案:B

满分：2 分 得分：2



​                        

### 8.西安交通大学19年5月补考《软件工程概论》作业考核试题

一、 单选题 (共 10 道试题,共 30 分)

1.**可行性分析中,系统流程图用于描述()。**

A.当前运行系统

B.当前逻辑模型

C.目标系统

D.新系统

正确答案:A

 

2.**软件生存周期包括可行性分析和项目开发计划、需求分析、概要设计、详细设计、编码、()、维护等活动。**

A.应用

B.测试

C.检测

D.以上答案都不正确

正确答案:B

 

3.**在软件开发和维护中所产生的一系列严重的问题通常称为软件危机,这些问题中相对次要的因素是()。**

A.文档质量

B.开发效率

C.软件功能

D.软件性能

正确答案:D

 

4.**在软件的开发与维护过程中,用来存储.更新.恢复和管理一个软件的多版本,它是()工具。**

A.文档分析

B.项目管理

C.成本估算

D.版本控制

正确答案:D

 

5.**()是计算机程序及其说明程序的各种文档。**

A.软件

B.文档

C.数据

D.程序

正确答案:A

 

6.**软件生存周期中时间最长的阶段是()。**

A.需求分析阶段

B.概要设计阶段

C.测试阶段

D.维护阶段

正确答案:D

 

7.**软件开发方法中的原型化方法是一种()型的设计过程。**

A.自外向内

B.自顶向下

C.自内向外

D.自底向上

正确答案:A

 

8**.软件开发环境支持一定的()或按照一定的软件开发模型组织而成。**

A.软件生存周期

B.软件过程

C.软件开发方法

D.软件开发模型

正确答案:C

 

9**.加工是对数据流图中不能再分解的基本加工的精确说明,下述()是加工的最核心。**

A.加工顺序

B.加工逻辑

C.执行频率

D.激发条件

正确答案:B

 

10.**软件生存周期模型有多种,下列选项中,()不是软件生存周期模型。**

A.螺旋模型

B.增量模型

C.功能模型

D.瀑布模型

正确答案:C

 

二、 判断题 (共 5 道试题,共 10 分)

1.**瀑布模型本质上是一种线性顺序模型。**

A.对

B.错

正确答案:A

 

2.**需求分析要回答“软件必须做什么?”**

A.对

B.错

正确答案:A

 

3.**原型化方法适用于需求不确定性高的系统。**

A.对

B.错

正确答案:A

 

4.**通过功能分解可以完成数据流图的细化。**

A.对

B.错

正确答案:A

 

5.**大多数开发系统都采用基于文件集成的策略。**

A.对

B.错

正确答案:A

 

三、 主观填空题 (共 10 道试题,共 30 分)

**1.需求分析工具主要包括:正文和数据流图工具、（）工具、面向对象的分析工具。**

正确答案:数据字典

 

**2.（）的目的就是用最小的代价在尽可能短的时间内确定该软件项目是否能够开发,是否值得去开发。**

正确答案:软件可行性研究

 

**3.可行性研究需要从（）可行性、（）可行性、（）可行性三个方面分析研究每种解决方法的可行性。**

正确答案:技术 经济 生产

 

**4.软件生命周期模型中的瀑布模型（）适应需求可变的软件开发,只有到（）才能见到整个软件系统。**

正确答案:不、开发结束

 

**5.用原型过程来代替设计阶段,考察设计方案的可行性与合理性,这是快速原型的（）原型。**

正确答案:实验型

 

**6.软件工具通常由工具.工具接口和（）三部分构成。**

正确答案:工具用户接口

 

**7.软件生命周期模型中的螺旋模型将（）模型和（）模型结合起来,加入了两种模型均忽略了的风险分析,弥补了这两种模型的不足。**

正确答案:瀑布 演化

 

**8.变换模型是一种适合于（）方法的模型。从（）开始,经过一系列（）,最终得到系统的目标程序。**

正确答案:形式化开发、软件需求形式化说明、变换

 

**9.对CASE工具分类的标准可分为（）,（）和（）。**

正确答案:功能、支持的过程、支持的范围

 

**10.在可行性研究的具体步骤中最后一步是（）。**

正确答案:编写可行性报告

 

四、 简答题 (共 3 道试题,共 30 分)

**1.什么是软件生存周期?它有哪些活动?**

‌软件生存周期‌指一个软件从提出开发需求开始，直到被废弃或终止使用的整个时期。它通过划分多个阶段，使复杂的软件开发过程更易管理和控制‌。

软件生存周期通常包含以下核心活动，按时间顺序可分为：

  ‌1.可行性分析与项目开发计划‌

​    分析技术、经济和操作可行性，制定项目开发计划‌。

  ‌2.需求分析‌

​    明确用户需求，形成无歧义的功能和非功能需求文档‌。

  ‌3.概要设计与详细设计‌

​    ‌概要设计‌：定义系统架构和模块划分‌。

​    ‌详细设计‌：细化模块功能，设计具体算法和数据结构‌。

  ‌4.编码‌

​    将设计文档转换为可执行的程序代码‌。

  ‌4.测试‌

​    通过单元测试、集成测试、系统测试等验证软件功能与性能‌。

  6.‌运行与维护‌

​    修复缺陷、优化性能、适应新需求，直至软件被废弃‌

 

**2.什么是软件生存周期模型?它有哪些?**

答：软件生命周期模型是描述软件开发过程中各种活动如何执行的模型。主要有：瀑布模型、原型模型、增量模型、螺旋模型、喷泉模型、基于知识的模型和变换模型。

 

**3.什么是实验型原型模型?**

快速原型模型根据原型的不同作用，有三类原型模型：(1)探索型原型。这种类型的原型模型是把原型用于开发的需求分析阶段，目的是要弄清用户的需求，确定所期望的特性，并探索各种方案的可行性。它主要针对开发目标模糊，用户与开发着对项目都缺乏经验的情况，通过对原型的开发来明确用户的需求。(2)实验型原型。这种原型主要用于设计阶段，考核实现方案是否合适，能否实现，对于一个大型系统，若对设计方案心中投有把握时，可通过这种原型来证实设计方案的正确性。(3)演化型原型。这种原型主要用于及早向用户提交一个原型系统，该原型系统或者包含系统的框或者包含系统的主要功能。在得到用户的认可后，将原型系统不断扩充演变为最终的软件系统，它将原型的思路扩展到软件开发的全过程。

 

**4.原型的开发环境是什么?**

　快速原型技术是一种涉及多学科的新型综合制造技术。80年代后，随着计算机辅助设计的应用，产品造型和设计能力得到极大提高，然而在产品设计完成后，批量生产前，必须制出样品以表达设计构想，快速获取产品设计的反馈信息，并对产品设计的可行性作出评估、论证。在市场竞争日趋激烈的今天，时间就是效益。为了提高产品市场竞争力，从产品开发到批量投产的整个过程都迫切要求降低成本和提高速度。快速原型技术的出现，为这一问题的解决提供了有效途径，倍受国内外重视。

　　原型是指模拟某种产品的原始模型，在其他产业中经常使用。软件开发中的原型是软件的一个早期可运行的版本，它反映了最终系统的重要特性。

　　快速原型模型又称原型模型，它是增量模型的另一种形式；它是在开发真实系统之前，构造一个原型，在该原型的基础上，逐渐完成整个系统的开发工作。例如，客户需要一个ATM机软件，可以先设计一个仅包含刷卡、密码检测、数据输入和账单打印的原型软件提供给客户，此时还不包括网络处理与数据库存取以及数据应急、故障处理等服务。快速原型模型的第一步是建造一个快速原型，实现客户或未来的用户与系统的交互，用户或客户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足客户的要求，开发人员可以确定客户的真正需求是什么；第二步则在第一步的基础上开发客户满意的软件产品。

​                              



​        

 
