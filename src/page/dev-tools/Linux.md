---
lang: zh-CN
title: Linux
order: 1
description: Linux常用命令
---

## 1.常用的命令

### 1.1文件与目录的基本操作

列出文件或者目录的信息，目录的信息就是其中包含的文件。

```shell
ls [-aAdfFhilnrRSt] file|dir
-a : 列出全部的文件
-d : 仅列出目录本身
-l : 以长数据串行列出，包含文件的属性与权限等等数据
```

更换当前目录。

```shell
cd [相对路径或绝对路径]
```

创建目录。

```shell
mkdir [-mp] 目录名称
-m : 配置目录权限
-p : 递归创建目录
```

删除，必须为空。

```shell
rmdir [-p] 目录名称
-p : 递归删除目录

rm [-fir] 文件或目录
-r : 递归删除
```

更新文件时间或者建立新文件。

```shell
touch [-acdmt] filename
-a :  更新 atime
-c :  更新 ctime，若该文件不存在则不建立新文件
-m :  更新 mtime
-d :  后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"
-t :  后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
```

复制文件。

如果源文件有两个以上，则目的文件一定要是目录才行。

```shell
cp [-adfilprsu] source destination
-a : 相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明
-d : 若来源文件为链接文件，则复制链接文件属性而非文件本身
-i : 若目标文件已经存在时，在覆盖前会先询问
-p : 连同文件的属性一起复制过去
-r : 递归持续复制
```

移动文件。

```shell
mv [-fiu] source destination
-f :  force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
```



### 1.2修改权限

可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。

```shell
chmod [-R] xyz dirname/filename
#也可以使用符号来设定权限。
chmod [ugoa]  [+-=] [rwx] dirname/filename
- u: 拥有者
- g: 所属群组
- o: 其他人
- a: 所有人
- +: 添加权限
- -: 移除权限
- =: 设定权限
```

### 1.3链接

```shell
ln [-sf] source_filename dist_filename
-s : 默认是 hard link，加 -s 为 symbolic link
-f : 如果目标文件存在时，先删除目标文件
```

![](http://www.img.youngxy.top/Java/fig/linux%E9%93%BE%E6%8E%A5.jpg)

### 1.4获取文件内容

```shell
cat [-AbEnTv] filename
-n : 打印出行号，连同空白行也会有行号，-b 不会

more：和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。

less：和 more 类似，但是多了一个向前翻页的功能。

head [-n number] filename
-n : 后面接数字，代表显示几行的意思

tail是 head 的反向操作，只是取得是后几行。
```



### 1.5指令与文件搜索

```shell
which [-a] command
-a : 将所有指令列出，而不是只列第一个

whereis [-bmsu] dirname/filename

locate [-ir] keyword
-r: 正则表达式

find [basedir] [option]
example: find . -name "shadow*"
```

### 1.6压缩与打包

```shell
tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z : 使用 zip；
-j : 使用 bzip2；
-J : 使用 xz；
-c : 新建打包文件；
-t : 查看打包文件里面有哪些文件；
-x : 解打包或解压缩的功能；
-v : 在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename: 要处理的文件；
-C 目录 :  在特定目录解压缩。
```

### 1.7管道指令

将一个命令的标准输出作为另一个命令的标准输入。

```shell
ls -al /etc | less
```

### 1.8正则表达式

```shell
grep [-acinv] [--color=auto] 搜寻字符串 filename
-c :  统计个数
-i :  忽略大小写
-n :  输出行号
-v :  反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto : 找到的关键字加颜色显示
```

### 1.9查看进程

```shell
查看自己的进程：
ps -l

查看系统所有进程：
ps aux

查看特定的进程
ps aux | grep threadx

实时显示进程信息
top

查看特定端口的进程
 netstat -anp | grep port
```



## 2.内核

**Linux内核的任务：**

1.从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。

2.从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。

3.内核是一个资源管理程序。负责将可用的共享资源(CPU时间、磁盘空间、网络连接等)分配得到各个系统进程。

4.内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。

**内核实现策略：**

1.微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。

2.宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。Linux内核就是基于这个策略实现的。

**哪些地方用到了内核机制？**

1.进程（在cpu的虚拟内存中分配地址空间，各个进程的地址空间完全独立;同时执行的进程数最多不超过cpu数目）之间进行通 信，需要使用特定的内核机制。

2.进程间切换(同时执行的进程数最多不超过cpu数目)，也需要用到内核机制。

进程切换也需要像FreeRTOS任务切换一样保存状态，并将进程置于闲置状态/恢复状态。

3.进程的调度。确认哪个进程运行多长的时间。



## 3.基本组件

- 内核（Kernel）:


Linux 内核是操作系统的核心部分，负责管理和控制硬件资源，并提供基本的系统功能。它处理进程管理、内存管理、设备驱动程序、文件系统、网络协议栈等重要任务。Linux 内核具有模块化的设计，使得用户可以根据需要添加或删除特定的模块。

- Shell：

Shell 是用户与操作系统交互的命令行解释器。它接受用户输入的命令，并将其传递给操作系统进行执行。Shell 还提供了脚本编程的能力，允许用户编写一系列的命令以自动化任务。常见的 Linux Shell 包括 Bash、Zsh 和 Fish 等，它们提供了丰富的命令和功能。

- GNU 工具：

GNU 工具是一组由 GNU 项目开发的实用工具集合，用于完成各种任务。这些工具包括常见的命令行工具，如文本编辑器（例如 Emacs 和 Vim）、文件操作工具（例如 ls、cp 和 rm）、文本处理工具（例如 grep 和 sed）等。GNU 工具是 Linux 系统的重要组成部分。

- 系统库：

Linux 提供了广泛的系统库，用于应用程序开发。最常用的是 GNU C 库（glibc），它提供了 C 语言标准函数和系统调用的封装。此外，还有其他库，如 libstdc++（C++ 的标准库）、libpthread（线程库）、libm（数学函数库）等，它们为开发者提供了丰富的函数和功能。

- X Window System：

X Window System 是 Linux 中常用的图形窗口系统，它提供了图形界面环境以及与图形硬件和输入设备的交互。X Window System 使用客户端-服务器模型，其中 X 服务器负责图形显示和输入设备控制。用户可以通过 X 客户端连接到 X 服务器，并在其上运行图形化应用程序。

- 桌面环境：

Linux 上有多个桌面环境可供选择，每个桌面环境都具有自己的外观、特性和工具集。

例如：GNOME 和 KDE 是两个最受欢迎的桌面环境，它们提供了完整的图形用户界面和一系列应用程序，包括文件管理器、文本编辑器、终端模拟器等。

- 文件系统：

Linux 支持多种文件系统，用于组织和管理存储设备上的文件和目录。常见的文件系统包括 EXT4、XFS 等。文件系统负责维护文件的元数据以及文件数据的物理存储位置。它还提供了对文件的访问和操作的接口。

- 网络协议栈：

Linux 内核支持各种网络协议，如 TCP/IP、UDP、HTTP、FTP 等。网络协议栈是在内核中实现的协议和算法的集合，它使得 Linux 能够进行网络通信。Linux 提供了丰富的网络工具和命令，如 ifconfig、ping、netstat 等，用于配置网络接口、测试连接和监控网络状态。



## 4.进程间通信方式

- 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 共享内存( shared  memory)：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
- 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

这里主要比较一下高级通信的这三种方式的特点。

- 管道通信(PIPE)：
         两个进程利用管道进行通信时．发送信息的进程称为写进程．接收信息的进程称为读进程。管道通信方式的中间介质就是文件．通常称这种文件为管道文件．它就像管道一样将一个写进程和一个读进程连接在一起，实现两个进程之间的通信。写进程通过写入端(发送端)往管道文件中写入信息；读进程通过读出端(接收端)从管道文件中读取信息。两个进程协调不断地进行写和读，便会构成双方通过管道传递信息的流水线。
         利用系统调用PIPE()可以创建一个无名管道文件，通常称为无名管道或PIPE；利用系统调用MKNOD()可以创建一个有名管道文件．通常称为有名管道或FIFO。无名管道是一种非永久性的管道通信机构．当它访问的进程全部终止时，它也将随之被撤消。无名管道只能用在具有家族联系的进程之间。有名管道可以长期存在于系统之中．而且提供给任意关系的进程使用，但是使用不当容易导致出错．所以操作系统将命名管道的管理权交由系统来加以控制管道文件被创建后，可以通过系统调用WRITE()和READ()来实现对管道的读写操作；通信完后，可用CLOSE()将管道文件关闭。

- 消息缓冲通信(MESSAGE)
         多个独立的进程之间可以通过消息缓冲机制来相互通信．这种通信的实现是以消息缓冲区为中间介质．通信双方的发送和接收操作均以消息为单位。在存储器中，消息缓冲区被组织成队列，通常称之为消息队列。消息队列一旦创建后即可由多进程共享．发送消息的进程可以在任意时刻发送任意个消息到指定的消息队列上，并检查是否有接收进程在等待它所发送的消息。若有则唤醒它：而接收消息的进程可以在需要消息的时候到指定的消息队列上获取消息．如果消息还没有到来．则转入睡眠状态等待。
  共享内存通信(SHARED MEMORY)

- 共享内存 

  ​        这种通信方式允许多个进程在外部通信协议或同步，互斥机制的支持下使用同一个内存段(作为中间介质)进行通信．它是一种有效的数据通信方式，其特点是没有中间环节．直接将共享的内存页面通过附接．映射到相互通信的进程各自的虚拟地址空间中．从而使多个进程可以直接访问同一个物理内存页面．如同访问自己的私有空间一样(但实质上不是私有的而是共享的)。因此这种进程间通信方式是在同一个计算机系统中的诸进程间实现通信的快捷的方法．而它的局限性也在于此．即共享内存的诸进程必须共处同一个计算机系统．有物理内存可以共享才行。

- **三种方式的特点（优缺点）：**
  无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错。
- 消息缓冲可以不再局限于父子进程．而允许任意进程通过共享消息队列来实现进程间通信．并由系统调用函数来实现消息发送和接收之间的同步．从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题．使用方便，但是信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合。
- 共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。



## 5.目录结构

Linux 使用一种称为目录树的层次结构来组织文件和目录。目录树由根目录（/）作为起始点，向下延伸，形成一系列的目录和子目录。每个目录可以包含文件和其他子目录。结构层次鲜明，就像一棵倒立的树。

**inode 具体包含以下信息:**

- 权限 (read/write/excute)；
- 拥有者与群组 (owner/group)；
- 容量；
- 建立或状态改变的时间 (ctime)；
- 最近一次的读取时间 (atime)；
- 最近修改的时间 (mtime)；
- 定义文件特性的旗标 (flag)，如 SetUID...；
- 该文件真正内容的指向 (pointer)。

inode 具有以下特点:

- 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；
- 每个文件都仅会占用一个 inode。

inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块记录引用信息。

建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。

可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。



**最基础的三个目录如下:**

- / (root, 根目录)
- /usr (unix software resource): 所有系统默认软件都会安装到这个目录；
- /var (variable): 存放系统或程序运行过程中的数据文件。

![](http://www.img.youngxy.top/Java/fig/linux%E7%9B%AE%E5%BD%95.png)

**文件属性**：

用户分为三种: 文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。

使用 ls 查看一个文件时，会显示一个文件的信息，例如 `drwxr-xr-x. 3 root root 17 May 6 00:14 .config`，对这个信息的解释如下:

- drwxr-xr-x: 文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段
- 3: 链接数
- root: 文件拥有者
- root: 所属群组
- 17: 文件大小
- May 6 00:14: 文件最后被修改的时间
- .config: 文件名

常见的文件类型及其含义有:

- d: 目录
- -: 文件
- l: 链接文件

9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。

