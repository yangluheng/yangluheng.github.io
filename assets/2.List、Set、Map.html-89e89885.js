import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as d,c as i,d as a,e,b as r,f as s}from"./app-9ea20e45.js";const o={},_=s('<h2 id="_2-1list" tabindex="-1"><a class="header-anchor" href="#_2-1list" aria-hidden="true">#</a> 2.1List</h2><h2 id="_2-2set" tabindex="-1"><a class="header-anchor" href="#_2-2set" aria-hidden="true">#</a> 2.2Set</h2><h2 id="_2-3map" tabindex="-1"><a class="header-anchor" href="#_2-3map" aria-hidden="true">#</a> 2.3Map</h2><h3 id="_2-3-1为什么jdk1-8中hashmap从头插入改成尾插入" tabindex="-1"><a class="header-anchor" href="#_2-3-1为什么jdk1-8中hashmap从头插入改成尾插入" aria-hidden="true">#</a> 2.3.1为什么JDK1.8中HashMap从头插入改成尾插入</h3>',4),c={href:"https://blog.csdn.net/qq_35590459/article/details/108988011",target:"_blank",rel:"noopener noreferrer"},l=a("p",null,"JDK1.7中扩容时，每个元素的rehash之后，都会插入到新数组对应索引的链表头，所以这就导致原链表顺序为A->B->C，扩容之后，rehash之后的链表可能为C->B->A，元素的顺序发生了变化。在并发场景下，扩容时可能会出现循环链表的情况。而JDK1.8从头插入改成尾插入元素的顺序不变，避免出现循环链表的情况。",-1),p={id:"_2-3-2为什么jdk1-8采用红黑树存储hash冲突的元素",tabindex:"-1"},f=a("a",{class:"header-anchor",href:"#_2-3-2为什么jdk1-8采用红黑树存储hash冲突的元素","aria-hidden":"true"},"#",-1),b={href:"https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},m=s('<p>红黑树本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得<strong>红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。能够加快检索速率。</strong></p><h3 id="_2-3-3为什么在长度小于8时使用链表-不一直使用红黑树" tabindex="-1"><a class="header-anchor" href="#_2-3-3为什么在长度小于8时使用链表-不一直使用红黑树" aria-hidden="true">#</a> 2.3.3为什么在长度小于8时使用链表，不一直使用红黑树？</h3><p>桶中元素的插入只会在hash冲突时发生，而hash冲突发生的概率较小，一直维护一个红黑树比链表耗费资源更多，在桶中元素量较小时没有这个必要。</p><h3 id="_2-3-4为什么要使用红黑树而不使用avl树" tabindex="-1"><a class="header-anchor" href="#_2-3-4为什么要使用红黑树而不使用avl树" aria-hidden="true">#</a> 2.3.4为什么要使用红黑树而不使用AVL树？</h3><p>红黑树与AVLl树，在检索的时候效率差不多，都是通过平衡来二分查找。但红黑树不像avl树一样追求绝对的平衡，红黑树允许局部很少的不完全平衡，这样对于效率影响不大，但省去了很多没有必要的调平衡操作，avl树调平衡有时候代价较大，所以效率不如红黑树。</p><h3 id="_2-3-5为什么数组容量必须是2次幂" tabindex="-1"><a class="header-anchor" href="#_2-3-5为什么数组容量必须是2次幂" aria-hidden="true">#</a> 2.3.5为什么数组容量必须是2次幂？</h3><p>索引计算公式为i = (n - 1) &amp; hash，如果n为2次幂，那么n-1的低位就全是1，哈希值进行与操作时可以保证低位的值不变，从而保证分布均匀，效果等同于hash%n，但是位运算比取余运算要高效的多。</p><h3 id="_2-3-6为什么单链表转为红黑树要求桶内的元素个数大于8" tabindex="-1"><a class="header-anchor" href="#_2-3-6为什么单链表转为红黑树要求桶内的元素个数大于8" aria-hidden="true">#</a> 2.3.6为什么单链表转为红黑树要求桶内的元素个数大于8？</h3><p>当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，而一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。</p><p>同理，少于8就从红黑树转回单链表是为了节省维护一个树的资源消耗，而选择8作为临界值，是因理想情况下一个bin中元素个数达到6的概率是0.00001316，达到7的概率为0.00000094，二者跨度较大，可以减小树和链表之间频繁转化的可能性。</p>',10);function u(x,k){const h=n("ExternalLinkIcon");return d(),i("div",null,[_,a("p",null,[e("原文链接："),a("a",c,[e("https://blog.csdn.net/qq_35590459/article/details/108988011"),r(h)])]),l,a("h3",p,[f,e(" 2.3.2为什么JDK1.8采用红黑树存储"),a("a",b,[e("Hash"),r(h)]),e("冲突的元素？")]),m])}const L=t(o,[["render",u],["__file","2.List、Set、Map.html.vue"]]);export{L as default};
