import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o,c as i,d as a,e as n,b as t,f as s}from"./app-4c312946.js";const l={},u=s(`<h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h2><h2 id="栈" tabindex="-1"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h2><h3 id="java官方推荐的实现方式-deque" tabindex="-1"><a class="header-anchor" href="#java官方推荐的实现方式-deque" aria-hidden="true">#</a> Java官方推荐的实现方式：Deque</h3><p>今日在刷LeetCode hot100的时候，看到K神题解下的一个评论：</p><figure><img src="http://www.img.youngxy.top/Java/fig/deque1.PNG" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以，我一个小白当然是去百度一下这个Deque为啥Java官方要推荐作为Stack的实现呢？</p><p>话不多说，直接上菜！</p><h4 id="q1-在-java-语言中-不推荐使用-stack-类" tabindex="-1"><a class="header-anchor" href="#q1-在-java-语言中-不推荐使用-stack-类" aria-hidden="true">#</a> Q1：在 Java 语言中，不推荐使用 Stack 类？</h4><p>是的。实际上，这个不推荐不是某个技术专家或者某个企业的规范标准，而是来自 Java 官方。</p><p>如果大家在 Java 中查询 Stack 的文档，就会看到如下标为蓝色的说明：</p><figure><img src="http://www.img.youngxy.top/Java/fig/jdk-deque.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>简单翻译：一个更加完整，一致的，后进先出的栈相关的操作，应该由 Deque 接口提供。并且，也推荐使用 Deque 这种数据结构（比如 ArrayDeque）来实现。</p><p>因此，如果你想使用栈这种数据结构，Java 官方推荐的写法是这样的（假设容器中的类型是 Integer）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="q2-java-中的-stack-类到底怎么了" tabindex="-1"><a class="header-anchor" href="#q2-java-中的-stack-类到底怎么了" aria-hidden="true">#</a> Q2：Java 中的 Stack 类到底怎么了？</h4><p>Java 中的 Stack 类，最大的问题是，继承了 Vector 这个类。根据 Java 官方文档中的类关系，如下所示：</p><figure><img src="http://www.img.youngxy.top/Java/fig/jdk-stack.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Vector 是什么类？简单来说，Vector 就是一个动态数组。</p><p>最大的问题在于，继承使得子类继承了父类的所有公有方法。</p><p>而 Vector 作为动态数组，是有能力在数组中的任何位置添加或者删除元素的。因此，Stack 继承了 Vector，Stack 也有这样的能力！</p><p>尝试如下的代码片段，在 Java 中是正确的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="q3-问题出在哪里" tabindex="-1"><a class="header-anchor" href="#q3-问题出在哪里" aria-hidden="true">#</a> Q3：问题出在哪里？</h4><p>Java 中的 Stack 实现，是被业界一直认为非常糟糕的实现。实际上，它犯了面向对象设计领域的一个基本错误：Stack 和 Vector 之间的关系，不应该是继承关系，而应该是组合关系（composition）。</p><p>关于继承关系和组合关系的区别，相信大家在 OOD 学习过程中，听过无数遍。</p><p>继承关系描述的是 is-a 的关系，即“是一个”的关系。</p><p>猫是一个动物，所以猫这个类可以继承动物类；</p><p>程序员是一个雇员，所以程序员这个类可以继承雇员类。</p><p>而组合关系描述的是 has-a 的关系，即“有一个”的关系。</p><p>车里有一台发动机，所以发动机这个类和车这个类之间，应该是组合关系，即车中包含一个成员变量，是发动机这个类的对象；</p><p>电脑里有 CPU，内存，显卡。所以 CPU，内存，显卡，这些类和电脑类之间的关系，都应该是组合关系。</p><p>上面这些例子，都是我们在生活中看得到摸得到的实体，我们在做类设计的时候，通常不会犯糊涂。但遇到更抽象的对象的时候，事情可能就不一样了。</p><p>比如，栈这种数据结构，和动态数组这种数据结构之间，到底应该是 is-a 的关系？还是 has-a 的关系？</p><p>使用自然语言描述，听起来似乎说：栈是一个动态数组，毛病不大。但其实仔细思考，就会发现，栈不是一个动态数组！</p><p>因此，很多时候，对于现实中并不存在的设计对象，人类很可能想不清楚 is-a 和 has-a 的关系。在这里，我再提供一个简单的原则：判断一下，如果设计成继承关系的话，我们是否有可能把子类进行向上的父类转型？如果可能，则应该设计成继承关系，否则应该是组合关系。</p><p>换句话说，在这个例子中，我们是否可能将栈当做一个动态数组使用？答案是不可能。所以，栈和动态数组之间的关系不应该是继承关系。</p><p>实际上，在真实的世界中，真正的继承关系是很少的。真正的继承关系中，父类大多是一个很抽象的概念，比如“人”，比如“动物”。但是我们设计的大多数类，不是这么抽象的概念。整体来说，组成关系更常用。</p><p>这个概念不是我说的，而是业界公认的 OOP 设计原则。叫做：Composition over inheritance。如果用中文说，就是应该优先考虑组合关系。</p><p>在 OOP 设计中，很多人会更倾向于使用继承关系，毕竟继承关系看起来更“面向对象”一些，也是面向对象讲解的重点。但是，在具体实践中，组合更常见！说得再绝对一些：多用组合，少用继承！</p><h4 id="q4-java-官方不知道这个-stack-类的实现不好吗-为什么不改" tabindex="-1"><a class="header-anchor" href="#q4-java-官方不知道这个-stack-类的实现不好吗-为什么不改" aria-hidden="true">#</a> Q4：Java 官方不知道这个 Stack 类的实现不好吗？为什么不改？</h4><p>Java 官方当然知道这个实现不好。但是，因为要保持兼容性（backward compatibility），对于已经正式发布的代码，Java 官方不能做接口设计层面的修改。否则，使用老版本 Java 的程序，将在新的 Java 环境下无法执行，这是 Java 官方不愿意看到的。</p><p>Java 官方可以做到的是，将这个类标志成“弃用”（deprecated），以让新版本的开发者不再允许使用这个类，但老版本的程序，还能继续执行。</p><p>但是，这么多年了，Java 官方也并没有将 Stack 标为“弃用”，只是在文档上注明“不建议使用”。</p><h4 id="q5-为什么使用接口" tabindex="-1"><a class="header-anchor" href="#q5-为什么使用接口" aria-hidden="true">#</a> Q5：为什么使用接口？</h4><p>下面，我们再来看一下 Java 官方推荐的写法：使用 Deque 接口：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接口最大的意义之一，就是做了更高层次的抽象：只定义了一个类应该满足哪些方法，而对具体的实现方式不做限制。</p><p>比如，我们都知道，在 Java 语言中，Queue 就是一个接口。我们想实现一个队列，可以这么写：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> q1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> q2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述实现中，q1 和 q2 的底层具体实现不同，一个是 LinkedList，一个是 ArrayDeque。但是，从用户的角度看，q1 和 q2 是一致的：都是一个队列，只能执行队列规定的方法。</p><p>这样做，将“队列”这样一个概念，和底层数据结构的具体实现——LinkedList 或者 ArrayDeque 解耦了：</p><p>底层开发人员可以随意维护自己的 LinkedList 类或者 ArrayDeque 类，只要他们满足 Queue 接口规定的规范；</p><p>开发者可以选择合适的数据结构来定义 Queue；</p><p>而 Queue 的更上层使用者，无需知道 q1 或者 q2 的实现细节，从他们的角度看，只要能调用 Queue 的相关方法：peek, poll, offer 等等，来满足上层的业务需求，就好了。</p><p>而且这样做，完美解决了之前说的，继承关系把父类的所有方法都拿过来的问题。接口的设计相当于做了访问限制。LinkedList 中有很多方法，但是，当我们使用 LinkedList 实现 Queue 接口的时候，用户只能调用 Queue 中定义的方法。</p><p>从这个角度，我们也能看出 Stack 设计的另一个不合理之处：Stack 和 Queue 同样作为一种特殊的线性数据结构，都应该只是规定一系列操作的接口而已，具体的底层实现，由开发者再做选择。</p><p>但因为 Stack 做成了一个类，继承了 Vector，也就只能基于 Vector 这一种固定的数据结构了。</p><p>为了修正这个问题，Java 官方推出了 Deque 接口，作为实现栈的接口。</p><h4 id="q6-什么是-deque-接口" tabindex="-1"><a class="header-anchor" href="#q6-什么是-deque-接口" aria-hidden="true">#</a> Q6：什么是 Deque 接口？</h4><p>Deque 是双端队列的意思。所谓的双端队列，就是能在线性数据结构的两段，进行插入和删除操作。</p><p>大家可以想象，由于 Stack 的定义是在同一端进，同一端出。所以，如果 Deque 可以满足在两段进行插入和删除，自然也能在同一端进行插入和删除，也就是可以以此为基础，做成一个 Stack。</p><h4 id="q7-等等-这里有问题" tabindex="-1"><a class="header-anchor" href="#q7-等等-这里有问题" aria-hidden="true">#</a> Q7：等等！这里有问题！</h4><p>很多同学应该能马上反应过来了。这里有问题！</p><p>因为我们根据 Java 官方推荐的方法声明的这个 Stack，虽然变量名称是Stack，但它实际上是一个 Deque。这就意味着，这个Stack，可以在两段做插入和删除操作！但是，真正的栈，只能在同一端做插入和删除操作！</p><p>这难道不是重蹈了 Stack 这个类的覆辙？毕竟，我们最开始分析，就说 Stack 这个类的一大问题，是继承了 Vector 这个类的若干我们不需要的方法，破坏了封装性，比如在任何一个位置插入一个元素。现在这个基于 Deque 接口的Stack，依然有我们不需要的方法啊！</p><p>没错！这就是 Java 的历史遗留问题了。这个问题至此已经无解了。因为 Stack 这个关键字被占据了。Java 官方不想推出一个叫做 RealStack 或者 CorrectStack 一类的接口名称。所以，按照 Java 官方的推荐所建立的这个Stack，依然不完美。</p><p>但至今为止，Java 暂时只是做到这个份儿上。</p><p>或许，Oracle 少打一些官司，多研究一下如何处理这些历史遗留问题，Java 能更好吧。</p><p>所以，在实际的工程应用上，有人也并不建议使用 Deque 做为 Stack 的实现，而是自己再做一层封装。</p>`,70),r={href:"http://baddotrobot.com/blog/2013/01/10/stack-vs-deque/%E3%80%82",target:"_blank",rel:"noopener noreferrer"},d=s(`<figure><img src="http://www.img.youngxy.top/Java/fig/stackvsdeque.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="q8-链表呢" tabindex="-1"><a class="header-anchor" href="#q8-链表呢" aria-hidden="true">#</a> Q8：链表呢？</h4><p>再说一个小问题。</p><p>大家可以看到，Java 官方推荐的创建栈的方式，使用了 Deque 接口。并且，在底层实现上，使用了 ArrayDeque，也就是基于动态数组的实现。为什么？</p><p>大家应该都知道，动态数组是可以进行扩容操作的。在触发扩容的时候，时间复杂度是 O(n) 的，但整体平均时间复杂度（Amortized Time）是 O(1)。</p><p>但是，基于链表的实现，不会牵扯到扩容问题，因此，每一次添加操作，从时间复杂度的角度，都是 O(1) 的。</p><p>虽然如此，可是实际上，当数据量达到一定程度的时候，链表的性能是远远低于动态数组的。</p><p>这是因为，对于链表来说，每添加一个元素，都需要重新创建一个 Node 类的对象，也就是都需要进行一次 new 的内存操作。而对内存的操作，是非常慢的。</p><p>举个例子，对于队列，测试它们的性能。代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>		<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> q1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> q2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> start1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            q1<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> start2 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            q2<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end2 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end1 <span class="token operator">-</span> start1 <span class="token operator">+</span> <span class="token string">&quot;ms&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end2 <span class="token operator">-</span> start2 <span class="token operator">+</span> <span class="token string">&quot;ms&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终的结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>76ms
4163ms
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是使用 LinkedList，会比使用 ArrayDeque 慢 5 倍以上！</p><p>因此，甚至有人建议：在实践中，尤其是面对大规模数据的时候，不应该使用链表！</p><p>最后，关于在面试中，如果有同学需要使用“栈”这种数据结构，选择 Stack 这个类，面试官会怎么看？我参考了网上的其博主的文章写的@lk 同学的看法：</p><figure><img src="http://www.img.youngxy.top/Java/fig/deque2.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,16),k={href:"https://blog.csdn.net/Dlgdlgd/article/details/125768706",target:"_blank",rel:"noopener noreferrer"},g=s('<h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h2><h2 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树" aria-hidden="true">#</a> 红黑树</h2><h5 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1.简介</h5><p>红黑树是一种自平衡的二叉查找树，是一种高效的查找树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。</p><h5 id="_2-为什么需要红黑树" tabindex="-1"><a class="header-anchor" href="#_2-为什么需要红黑树" aria-hidden="true">#</a> 2.为什么需要红黑树？</h5><p>对于二叉搜索树，如果插入的数据是随机的，那么它就是接近平衡的二叉树，平衡的二叉树，它的操作效率（查询，插入，删除）效率较高，时间复杂度是O（logN）。但是可能会出现一种极端的情况，那就是插入的数据是有序的（递增或者递减），那么所有的节点都会在根节点的右侧或左侧，此时，二叉搜索树就变为了一个链表，它的操作效率就降低了，时间复杂度为O(N)，所以可以认为二叉搜索树的时间复杂度介于O（logN）和O(N)之间，视情况而定。那么为了应对这种极端情况，红黑树就出现了，它是具备了某些特性的二叉搜索树，能解决非平衡树问题，红黑树是一种接近平衡的二叉树（说它是接近平衡因为它并没有像AVL树的平衡因子的概念，它只是靠着满足红黑节点的5条性质来维持一种接近平衡的结构，进而提升整体的性能，并没有严格的卡定某个平衡因子来维持绝对平衡）。</p><h5 id="_3-红黑树的特性" tabindex="-1"><a class="header-anchor" href="#_3-红黑树的特性" aria-hidden="true">#</a> 3.红黑树的特性</h5><p>首先，红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，<strong>红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红节点一个黑节点，当从根节点到叶子节点的路径上黑色节点相同时，最长路径刚好是最短路径的两倍）</strong>。它同时满足以下特性：</p><ul><li><p>节点是<strong>红色</strong>或<strong>黑色</strong></p></li><li><p>根是<strong>黑色</strong></p></li><li><p>叶子节点（外部节点，空节点）都是**黑色，**这里的叶子节点指的是最底层的空节点（外部节点），下图中的那些null节点才是叶子节点，null节点的父节点在红黑树里不将其看作叶子节点</p></li><li><p>红色节点的子节点都是黑色；</p><p><strong>红色</strong>节点的父节点都是<strong>黑色</strong>；</p><p>从根节点到叶子节点的所有路径上不能有 2 个连续的<strong>红色</strong>节点</p></li><li><p>从任一节点到叶子节点的所有路径都包含相同数目的<strong>黑色</strong>节点</p></li></ul><figure><img src="https://img-blog.csdnimg.cn/14c3c358dc3e4428b59add6dfe85b361.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5LiDbW9k,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h5 id="_4-红黑树的效率" tabindex="-1"><a class="header-anchor" href="#_4-红黑树的效率" aria-hidden="true">#</a> 4.红黑树的效率</h5><p>红黑树的查找，插入和删除操作，时间复杂度都是O(logN)。</p><p><strong>查找操作时</strong>，它和普通的相对平衡的二叉搜索树的效率相同，都是通过相同的方式来查找的，没有用到红黑树特有的特性。</p><p>但如果<strong>插入的时候</strong>是有序数据，那么红黑树的查询效率就比二叉搜索树要高了，因为此时二叉搜索树不是平衡树，它的时间复杂度O(N)。</p><p><strong>插入和删除操作</strong>时，由于红黑树的每次操作平均要旋转一次和变换颜色，所以它比普通的二叉搜索树效率要低一点，不过时间复杂度仍然是O(logN)。总之，红黑树的优点就是对有序数据的查询操作不会慢到O(N)的时间复杂度。</p><p>红黑树和AVL树的比较：</p><ul><li>AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异</li><li>红黑树的<strong>插入删除</strong>比AVL树更便于控制操作</li><li>红黑树整体性能略优于AVL树（红黑树旋转情况少于AVL树）</li></ul><h2 id="哈希表结构" tabindex="-1"><a class="header-anchor" href="#哈希表结构" aria-hidden="true">#</a> 哈希表结构</h2>',19);function h(v,m){const e=c("ExternalLinkIcon");return o(),i("div",null,[u,a("p",null,[n("比如，大家可以看一下这篇探讨 Stack 和 Deque 的文章："),a("a",r,[n("http://baddotrobot.com/blog/2013/01/10/stack-vs-deque/。"),t(e)])]),d,a("p",null,[n("参考："),a("a",k,[n("https://blog.csdn.net/Dlgdlgd/article/details/125768706"),t(e)])]),g])}const q=p(l,[["render",h],["__file","数据结构.html.vue"]]);export{q as default};
