import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as d,c,a as e,e as i,d as o,f as a}from"./app-04c54d9a.js";const l={},s=a('<p>大家好，这篇文章来一起看下TCP中那些烦人（常考）的面试题，话不多说，发车！</p><p>为了检验对这些知识掌握的深度，先给大家列出目录：</p><p><strong>1.TCP基础</strong></p><ul><li>TCP 头格式有哪些？</li><li>为什么需要 TCP 协议？ TCP 工作在哪一层？</li><li>什么是 TCP ？</li><li>什么是 TCP 连接？</li><li>如何唯一确定一个 TCP 连接呢？</li><li>UDP 和 TCP 有什么区别呢？分别的应用场景是？</li><li>TCP 和 UDP 可以使用同一个端口吗？</li></ul><p><strong>2.TCP三次握手</strong></p><ul><li>TCP 三次握手过程是怎样的？</li><li>如何在 Linux 系统中查看 TCP 状态？</li><li>为什么是三次握手？不是两次、四次？</li><li>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</li><li>初始序列号 ISN 是如何随机产生的？</li><li>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</li><li>第一次握手丢失了，会发生什么？</li><li>第二次握手丢失了，会发生什么？</li><li>第三次握手丢失了，会发生什么？</li><li>什么是 SYN 攻击？如何避免 SYN 攻击？</li></ul><p><strong>3.TCP四次挥手</strong></p><ul><li>TCP 四次挥手过程是怎样的？</li><li>为什么挥手需要四次？</li><li>第一次挥手丢失了，会发生什么？</li><li>第二次挥手丢失了，会发生什么？</li><li>第三次挥手丢失了，会发生什么？</li><li>第四次挥手丢失了，会发生什么？</li><li>为什么 TIME_WAIT 等待的时间是 2MSL？</li><li>为什么需要 TIME_WAIT 状态？</li><li>TIME_WAIT 过多有什么危害？</li><li>如何优化 TIME_WAIT？</li><li>服务器出现大量 TIME_WAIT 状态的原因有哪些？</li><li>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</li><li>如果已经建立了连接，但是客户端突然出现故障了怎么办？</li><li>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</li></ul><p><strong>4.Socket 编程</strong></p><ul><li>针对 TCP 应该如何 Socket 编程？</li><li>listen 时候参数 backlog 的意义？</li><li>accept 发生在三次握手的哪一步？</li><li>客户端调用 close 了，连接是断开的流程是什么？</li><li>没有 accept，能建立 TCP 连接吗？</li><li>没有 listen，能建立 TCP 连接吗？</li></ul><h2 id="_1-tcp基础" tabindex="-1"><a class="header-anchor" href="#_1-tcp基础" aria-hidden="true">#</a> 1.TCP基础</h2><h3 id="_1-1tcp-头格式有哪些" tabindex="-1"><a class="header-anchor" href="#_1-1tcp-头格式有哪些" aria-hidden="true">#</a> 1.1TCP 头格式有哪些？</h3><figure><img src="http://www.img.youngxy.top/Java/fig/tcp-format.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',13),p={href:"https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html",target:"_blank",rel:"noopener noreferrer"},h=a('<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h3 id="_1-2为什么需要-tcp-协议-tcp-工作在哪一层" tabindex="-1"><a class="header-anchor" href="#_1-2为什么需要-tcp-协议-tcp-工作在哪一层" aria-hidden="true">#</a> 1.2为什么需要 TCP 协议？ TCP 工作在哪一层？</h3><p><strong>原因：</strong><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h3 id="_1-3什么是-tcp" tabindex="-1"><a class="header-anchor" href="#_1-3什么是-tcp" aria-hidden="true">#</a> 1.3什么是 TCP ？</h3><p>总结一句话：TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p>具体的给面试官扯一扯：</p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h3 id="_1-4什么是-tcp-连接" tabindex="-1"><a class="header-anchor" href="#_1-4什么是-tcp-连接" aria-hidden="true">#</a> 1.4什么是 TCP 连接？</h3><p>大白话：<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p>包含三个东西：</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="_1-5如何唯一确定一个-tcp-连接呢" tabindex="-1"><a class="header-anchor" href="#_1-5如何唯一确定一个-tcp-连接呢" aria-hidden="true">#</a> 1.5如何唯一确定一个 TCP 连接呢？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址（IP地址，32位，存在IP头部）</li><li>源端口（端口，16位，存在TCP头部）</li><li>目的地址（IP地址，32位，存在IP头部）</li><li>目的端口（端口，16位，存在TCP头部）</li></ul><p>这地方有个常见面试题：</p><p><strong>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</strong></p><p>服务端通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和端口是可变的，其理论值计算公式如下:</p>',22),g=e("p",{class:"katex-block"},[e("span",{class:"katex-display"},[e("span",{class:"katex"},[e("span",{class:"katex-mathml"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[e("semantics",null,[e("mrow",null,[e("mi",null,"T"),e("mi",null,"C"),e("mi",null,"P"),e("mtext",null,"的最大连接数"),e("mo",null,"="),e("mtext",null,"客户端的"),e("mi",null,"I"),e("mi",null,"P"),e("mtext",null,"数"),e("mo",null,"⋅"),e("mtext",null,"客户端的端口数")]),e("annotation",{encoding:"application/x-tex"}," TCP 的最大连接数 = 客户端的IP数 \\cdot 客户端的端口数 ")])])]),e("span",{class:"katex-html","aria-hidden":"true"},[e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6833em"}}),e("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"TCP"),e("span",{class:"mord cjk_fallback"},"的最大连接数"),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),e("span",{class:"mrel"},"="),e("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6833em"}}),e("span",{class:"mord cjk_fallback"},"客户端的"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.07847em"}},"I"),e("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P"),e("span",{class:"mord cjk_fallback"},"数"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),e("span",{class:"mbin"},"⋅"),e("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),e("span",{class:"base"},[e("span",{class:"strut",style:{height:"0.6833em"}}),e("span",{class:"mord cjk_fallback"},"客户端的端口数")])])])])],-1),P=a('<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限，还收到物理内存和其他因素影响。</p><h3 id="_1-6udp-和-tcp-有什么区别呢-分别的应用场景是" tabindex="-1"><a class="header-anchor" href="#_1-6udp-和-tcp-有什么区别呢-分别的应用场景是" aria-hidden="true">#</a> 1.6UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><figure><img src="http://www.img.youngxy.top/Java/fig/udp-format.webp" alt="UDP 头部格式" tabindex="0" loading="lazy"><figcaption>UDP 头部格式</figcaption></figure><h4 id="_1-6-1tcp-和-udp-区别" tabindex="-1"><a class="header-anchor" href="#_1-6-1tcp-和-udp-区别" aria-hidden="true">#</a> 1.6.1TCP 和 UDP 区别：</h4><p><strong>1.连接</strong></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><strong>2. 服务对象</strong></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><strong>3. 可靠性</strong></p>',10),u=e("li",null,"TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。",-1),T={href:"https://xiaolincoding.com/network/3_tcp/quic.html",target:"_blank",rel:"noopener noreferrer"},_=a('<p><strong>4. 拥塞控制、流量控制</strong></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><strong>5. 首部开销</strong></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><strong>6. 传输方式</strong></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><strong>7. 分片不同</strong></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><h4 id="_1-6-2tcp-和-udp-应用场景" tabindex="-1"><a class="header-anchor" href="#_1-6-2tcp-和-udp-应用场景" aria-hidden="true">#</a> 1.6.2TCP 和 UDP 应用场景：</h4><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li>FTP 文件传输；</li><li>HTTP / HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 DNS、SNMP 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><p>这里有两道常见面试题：</p><p><strong>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></p><p>原因： TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><p><strong>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></p><p>比较靠谱的原因：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。</p><h3 id="_1-7tcp-和-udp-可以使用同一个端口吗" tabindex="-1"><a class="header-anchor" href="#_1-7tcp-和-udp-可以使用同一个端口吗" aria-hidden="true">#</a> 1.7TCP 和 UDP 可以使用同一个端口吗？</h3><p>总结：可以的。</p><p>传输层的<strong>端口号</strong>的作用，是为了区分同一个主机上不同应用程序的数据包。</p><p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><p>因此，TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p>',24),C={href:"https://xiaolincoding.com/network/3_tcp/port.html",target:"_blank",rel:"noopener noreferrer"},m=a('<h2 id="_2-tcp三次握手" tabindex="-1"><a class="header-anchor" href="#_2-tcp三次握手" aria-hidden="true">#</a> <strong>2.TCP三次握手</strong></h2><h3 id="_2-1tcp-三次握手过程是怎样的" tabindex="-1"><a class="header-anchor" href="#_2-1tcp-三次握手过程是怎样的" aria-hidden="true">#</a> 2.1TCP 三次握手过程是怎样的？</h3><p>三次握手的过程如下图：</p><figure><img src="http://www.img.youngxy.top/Java/fig/TCP三次握手1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p><p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p><h3 id="_2-2如何在-linux-系统中查看-tcp-状态" tabindex="-1"><a class="header-anchor" href="#_2-2如何在-linux-系统中查看-tcp-状态" aria-hidden="true">#</a> 2.2如何在 Linux 系统中查看 TCP 状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p><h3 id="_2-3为什么是三次握手-不是两次、四次" tabindex="-1"><a class="header-anchor" href="#_2-3为什么是三次握手-不是两次、四次" aria-hidden="true">#</a> 2.3为什么是三次握手？不是两次、四次？</h3><p><em>避免历史连接</em></p><p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p><p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p><p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p><p>我们考虑一个场景，客户端先发送了 SYN（seq = 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p><p>看看三次握手是如何阻止历史连接的：</p><figure><img src="http://www.img.youngxy.top/Java/fig/tcp2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</li><li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。</li><li>服务端收到 RST 报文后，就会释放连接。</li><li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li></ul><p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p><p><em>同步双方初始序列号</em></p><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p><p><em>避免资源浪费</em></p><p>如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，这会造成什么情况呢？</p><p>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h3 id="_2-4为什么每次建立-tcp-连接时-初始化的序列号都要求不一样呢" tabindex="-1"><a class="header-anchor" href="#_2-4为什么每次建立-tcp-连接时-初始化的序列号都要求不一样呢" aria-hidden="true">#</a> 2.4为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><p>主要原因有两个方面：</p><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul><figure><img src="http://www.img.youngxy.top/Java/fig/tcp3.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-5初始序列号-isn-是如何随机产生的" tabindex="-1"><a class="header-anchor" href="#_2-5初始序列号-isn-是如何随机产生的" aria-hidden="true">#</a> 2.5初始序列号 ISN 是如何随机产生的？</h3><p>基于时钟的。</p><h3 id="_2-6既然-ip-层会分片-为什么-tcp-层还需要-mss-呢" tabindex="-1"><a class="header-anchor" href="#_2-6既然-ip-层会分片-为什么-tcp-层还需要-mss-呢" aria-hidden="true">#</a> 2.6既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h3><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p><h3 id="_2-7第一次握手丢失了-会发生什么" tabindex="-1"><a class="header-anchor" href="#_2-7第一次握手丢失了-会发生什么" aria-hidden="true">#</a> 2.7第一次握手丢失了，会发生什么？</h3><p>重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p><h3 id="_2-8第二次握手丢失了-会发生什么" tabindex="-1"><a class="header-anchor" href="#_2-8第二次握手丢失了-会发生什么" aria-hidden="true">#</a> 2.8第二次握手丢失了，会发生什么？</h3><p>重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p><p><strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p><h3 id="_2-9第三次握手丢失了-会发生什么" tabindex="-1"><a class="header-anchor" href="#_2-9第三次握手丢失了-会发生什么" aria-hidden="true">#</a> 2.9第三次握手丢失了，会发生什么？</h3><p><strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p><h3 id="_2-10什么是-syn-攻击-如何避免-syn-攻击" tabindex="-1"><a class="header-anchor" href="#_2-10什么是-syn-攻击-如何避免-syn-攻击" aria-hidden="true">#</a> 2.10什么是 SYN 攻击？如何避免 SYN 攻击？</h3><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>正常流程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出连接对象。</li></ul><p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p><p>SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p><p>避免 SYN 攻击方式，可以有以下四种方法：</p><ul><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；</li></ul><h2 id="_3-tcp四次挥手" tabindex="-1"><a class="header-anchor" href="#_3-tcp四次挥手" aria-hidden="true">#</a> <strong>3.TCP四次挥手</strong></h2><h3 id="_3-1tcp-四次挥手过程是怎样的" tabindex="-1"><a class="header-anchor" href="#_3-1tcp-四次挥手过程是怎样的" aria-hidden="true">#</a> 3.1TCP 四次挥手过程是怎样的？</h3><figure><img src="http://www.img.youngxy.top/Java/fig/tcp断开1.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h3 id="_3-2为什么挥手需要四次" tabindex="-1"><a class="header-anchor" href="#_3-2为什么挥手需要四次" aria-hidden="true">#</a> 3.2为什么挥手需要四次？</h3><p>服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p><h3 id="_3-3第一次挥手丢失了-会发生什么" tabindex="-1"><a class="header-anchor" href="#_3-3第一次挥手丢失了-会发生什么" aria-hidden="true">#</a> 3.3第一次挥手丢失了，会发生什么？</h3><p>触发超时重传机制，重传 FIN 报文。</p><h3 id="_3-4第二次挥手丢失了-会发生什么" tabindex="-1"><a class="header-anchor" href="#_3-4第二次挥手丢失了-会发生什么" aria-hidden="true">#</a> 3.4第二次挥手丢失了，会发生什么？</h3><p>客户端就会触发超时重传机制，重传 FIN 报文。</p><h3 id="_3-5第三次挥手丢失了-会发生什么" tabindex="-1"><a class="header-anchor" href="#_3-5第三次挥手丢失了-会发生什么" aria-hidden="true">#</a> 3.5第三次挥手丢失了，会发生什么？</h3><p>服务端就会重发 FIN 报文。</p><h3 id="_3-6第四次挥手丢失了-会发生什么" tabindex="-1"><a class="header-anchor" href="#_3-6第四次挥手丢失了-会发生什么" aria-hidden="true">#</a> 3.6第四次挥手丢失了，会发生什么？</h3><p>服务端就会重发 FIN 报文。</p><h3 id="_3-7为什么-time-wait-等待的时间是-2msl" tabindex="-1"><a class="header-anchor" href="#_3-7为什么-time-wait-等待的时间是-2msl" aria-hidden="true">#</a> 3.7为什么 TIME_WAIT 等待的时间是 2MSL？</h3><p>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><h3 id="_3-8为什么需要-time-wait-状态" tabindex="-1"><a class="header-anchor" href="#_3-8为什么需要-time-wait-状态" aria-hidden="true">#</a> 3.8为什么需要 TIME_WAIT 状态？</h3><p><em>防止历史连接中的数据，被后面相同四元组的连接错误的接收</em></p><p><strong>让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><em>保证「被动关闭连接」的一方，能被正确的关闭</em></p><p><strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><h3 id="_3-9time-wait-过多有什么危害" tabindex="-1"><a class="header-anchor" href="#_3-9time-wait-过多有什么危害" aria-hidden="true">#</a> 3.9TIME_WAIT 过多有什么危害？</h3><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是占用端口资源</li></ul><h3 id="_3-10如何优化-time-wait" tabindex="-1"><a class="header-anchor" href="#_3-10如何优化-time-wait" aria-hidden="true">#</a> 3.10如何优化 TIME_WAIT？</h3><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><h3 id="_3-11服务器出现大量-time-wait-状态的原因有哪些" tabindex="-1"><a class="header-anchor" href="#_3-11服务器出现大量-time-wait-状态的原因有哪些" aria-hidden="true">#</a> 3.11服务器出现大量 TIME_WAIT 状态的原因有哪些？</h3><p>服务器主动断开了很多 TCP 连接。</p><h3 id="_3-12服务器出现大量-close-wait-状态的原因有哪些" tabindex="-1"><a class="header-anchor" href="#_3-12服务器出现大量-close-wait-状态的原因有哪些" aria-hidden="true">#</a> 3.12服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h3><p><strong>服务端的程序没有调用 close 函数关闭连接</strong>。</p><h3 id="_3-13如果已经建立了连接-但是客户端突然出现故障了怎么办" tabindex="-1"><a class="header-anchor" href="#_3-13如果已经建立了连接-但是客户端突然出现故障了怎么办" aria-hidden="true">#</a> 3.13如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP<strong>保活机制</strong>：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><h3 id="_3-14如果已经建立了连接-但是服务端的进程崩溃会发生什么" tabindex="-1"><a class="header-anchor" href="#_3-14如果已经建立了连接-但是服务端的进程崩溃会发生什么" aria-hidden="true">#</a> 3.14如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h3><p>内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p><h2 id="_4-socket-编程" tabindex="-1"><a class="header-anchor" href="#_4-socket-编程" aria-hidden="true">#</a> <strong>4.Socket 编程</strong></h2><h3 id="_4-1accept-发生在三次握手的哪一步" tabindex="-1"><a class="header-anchor" href="#_4-1accept-发生在三次握手的哪一步" aria-hidden="true">#</a> 4.1accept 发生在三次握手的哪一步？</h3><p><strong>服务端 accept 成功返回是在三次握手成功之后。</strong></p><h3 id="_4-2没有-accept-能建立-tcp-连接吗" tabindex="-1"><a class="header-anchor" href="#_4-2没有-accept-能建立-tcp-连接吗" aria-hidden="true">#</a> 4.2没有 accept，能建立 TCP 连接吗？</h3><p><strong>可以的</strong>。</p><p>accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。</p><h3 id="_4-3没有-listen-能建立-tcp-连接吗" tabindex="-1"><a class="header-anchor" href="#_4-3没有-listen-能建立-tcp-连接吗" aria-hidden="true">#</a> 4.3没有 listen，能建立 TCP 连接吗？</h3><p><strong>可以的</strong>。</p><p>客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能 TCP 建立连接。</strong></p><h2 id="_5-tcp高级" tabindex="-1"><a class="header-anchor" href="#_5-tcp高级" aria-hidden="true">#</a> 5.TCP高级</h2><h3 id="_5-1重传机制" tabindex="-1"><a class="header-anchor" href="#_5-1重传机制" aria-hidden="true">#</a> 5.1重传机制</h3><p><strong>超时重传</strong>:在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p><strong>快速重传</strong>:当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><h3 id="_5-2滑动窗口" tabindex="-1"><a class="header-anchor" href="#_5-2滑动窗口" aria-hidden="true">#</a> 5.2滑动窗口</h3><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。<strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p><p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p><p>接收窗口和发送窗口的大小是相等的吗？</p><p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p><h3 id="_5-3流量控制" tabindex="-1"><a class="header-anchor" href="#_5-3流量控制" aria-hidden="true">#</a> 5.3流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p><p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><h3 id="_5-4拥塞控制" tabindex="-1"><a class="header-anchor" href="#_5-4拥塞控制" aria-hidden="true">#</a> 5.4拥塞控制</h3><p>流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h4 id="_5-4-1慢启动" tabindex="-1"><a class="header-anchor" href="#_5-4-1慢启动" aria-hidden="true">#</a> 5.4.1慢启动</h4><p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p><p>慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul><h4 id="_5-4-2拥塞避免算法" tabindex="-1"><a class="header-anchor" href="#_5-4-2拥塞避免算法" aria-hidden="true">#</a> 5.4.2拥塞避免算法</h4><p>它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p><p>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h4 id="_5-4-3拥塞发生" tabindex="-1"><a class="header-anchor" href="#_5-4-3拥塞发生" aria-hidden="true">#</a> 5.4.3拥塞发生</h4><p><strong>发生超时重传的拥塞发生算法</strong>:</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul><p><strong>发生快速重传的拥塞发生算法</strong>:</p><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><h4 id="_5-4-4快速恢复" tabindex="-1"><a class="header-anchor" href="#_5-4-4快速恢复" aria-hidden="true">#</a> 5.4.4快速恢复</h4><p>快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><figure><img src="http://www.img.youngxy.top/Java/fig/拥塞发生-快速重传.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_5-5tcp-和-udp-可以使用同一个端口吗" tabindex="-1"><a class="header-anchor" href="#_5-5tcp-和-udp-可以使用同一个端口吗" aria-hidden="true">#</a> 5.5TCP 和 UDP 可以使用同一个端口吗？</h3><p><strong>可以的</strong>。传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p><h3 id="_5-6客户端的端口可以重复使用吗" tabindex="-1"><a class="header-anchor" href="#_5-6客户端的端口可以重复使用吗" aria-hidden="true">#</a> 5.6客户端的端口可以重复使用吗？</h3><p>可以。</p><p><strong>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</strong></p>',159);function f(S,x){const t=n("ExternalLinkIcon");return d(),c("div",null,[s,e("p",null,[i("看了"),e("a",p,[i("大佬小林coding"),o(t)]),i("的文章，我总结面试常考的也就是：")]),h,g,P,e("ul",null,[u,e("li",null,[i("UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章："),e("a",T,[i("如何基于 UDP 协议实现可靠传输？"),o(t)])])]),_,e("p",null,[i("可以看这篇文章："),e("a",C,[i("TCP 和 UDP 可以使用同一个端口吗？"),o(t)])]),m])}const N=r(l,[["render",f],["__file","TCP和UDP.html.vue"]]);export{N as default};
