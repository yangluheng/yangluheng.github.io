import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as n,c as l,d as e,e as r,b as o,f as s}from"./app-b8659a8e.js";const d={},c=s('<h3 id="键入网址到网页显示-期间发生了什么" tabindex="-1"><a class="header-anchor" href="#键入网址到网页显示-期间发生了什么" aria-hidden="true">#</a> 键入网址到网页显示，期间发生了什么？</h3><figure><img src="https://oss.javaguide.cn/github/javaguide/url输入到展示出来的过程.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="osi-七层模型" tabindex="-1"><a class="header-anchor" href="#osi-七层模型" aria-hidden="true">#</a> OSI 七层模型</h3><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" tabindex="0" loading="lazy"><figcaption>OSI 七层模型</figcaption></figure><h3 id="tcp-ip-四层模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip-四层模型" aria-hidden="true">#</a> TCP/IP 四层模型</h3><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/网络/tcpip参考模型.drawio.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h3><h3 id="ip" tabindex="-1"><a class="header-anchor" href="#ip" aria-hidden="true">#</a> IP</h3><h3 id="udp" tabindex="-1"><a class="header-anchor" href="#udp" aria-hidden="true">#</a> UDP</h3><h3 id="arp" tabindex="-1"><a class="header-anchor" href="#arp" aria-hidden="true">#</a> ARP</h3><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p><p>ARP 协议工作时有一个大前提，那就是 <strong>ARP 表</strong>。</p><p>在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <code>&lt;IP, MAC, TTL&gt;</code> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p><p>ARP 的工作原理将分两种场景讨论：</p><ol><li><strong>同一局域网内的 MAC 寻址</strong>；</li><li><strong>从一个局域网到另一个局域网中的网络设备的寻址</strong>。</li></ol><h4 id="同一局域网内的-mac-寻址" tabindex="-1"><a class="header-anchor" href="#同一局域网内的-mac-寻址" aria-hidden="true">#</a> 同一局域网内的 MAC 寻址</h4><p>假设当前有如下场景：IP 地址为<code>137.196.7.23</code>的主机 A，想要给同一局域网内的 IP 地址为<code>137.196.7.14</code>主机 B，发送 IP 数据报文。</p><blockquote><p>再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。</p></blockquote><p>为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：</p><ol><li><p>主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。</p></li><li><p>主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。</p><p>ARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——<code>FF-FF-FF-FF-FF-FF</code>，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。</p></li><li><p>主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。</p></li><li><p>主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。</p><p>ARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。</p></li><li><p>主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。</p></li></ol><p>总结来说，ARP 协议是一个<strong>广播问询，单播响应</strong>协议。</p><h4 id="不同局域网内的-mac-寻址" tabindex="-1"><a class="header-anchor" href="#不同局域网内的-mac-寻址" aria-hidden="true">#</a> 不同局域网内的 MAC 寻址</h4><p>更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。</p><p>接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在子网内的所有设备（接口）都将不会捕获该分组，因为该分组的目的 IP 地址在另一个子网中，本子网内不会有设备成功接收。那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：</p><ol><li><p>主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。</p><p>目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。</p></li><li><p>主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。</p></li><li><p>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。</p></li><li><p>目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。</p><p>到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。</p></li><li><p>路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。</p></li><li><p>路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。</p></li><li><p>路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。</p></li></ol><h3 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h3><h4 id="http-状态码有哪些" tabindex="-1"><a class="header-anchor" href="#http-状态码有哪些" aria-hidden="true">#</a> HTTP 状态码有哪些？</h4><p>HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码" tabindex="0" loading="lazy"><figcaption>常见 HTTP 状态码</figcaption></figure><h4 id="http-1-0-和-http-1-1-有什么区别" tabindex="-1"><a class="header-anchor" href="#http-1-0-和-http-1-1-有什么区别" aria-hidden="true">#</a> HTTP/1.0 和 HTTP/1.1 有什么区别？</h4><ul><li><strong>连接方式</strong> : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。</li><li><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存机制</strong> : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>Host 头（Host Header）处理</strong> :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。</li></ul><h4 id="http-1-1-和-http-2-0-有什么区别" tabindex="-1"><a class="header-anchor" href="#http-1-1-和-http-2-0-有什么区别" aria-hidden="true">#</a> HTTP/1.1 和 HTTP/2.0 有什么区别？</h4><ul><li><strong>IO 多路复用（Multiplexing）</strong> ：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本）。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</li><li><strong>二进制帧（Binary Frames）</strong> ：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</li><li><strong>头部压缩（Header Compression）</strong> ：HTTP/1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP/2.0 支持对<code>Header</code>压缩，减少了网络开销。</li><li><strong>服务器推送（Server Push）</strong>：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。</li></ul><h4 id="http-2-0-和-http-3-0-有什么区别" tabindex="-1"><a class="header-anchor" href="#http-2-0-和-http-3-0-有什么区别" aria-hidden="true">#</a> HTTP/2.0 和 HTTP/3.0 有什么区别？</h4><ul><li><strong>传输协议</strong> ：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</li><li><strong>连接建立</strong> ：HTTP/2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP/3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。</li><li><strong>队头阻塞</strong> ：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</li></ul><h3 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h3><h4 id="http-和-https-有什么区别" tabindex="-1"><a class="header-anchor" href="#http-和-https-有什么区别" aria-hidden="true">#</a> HTTP 和 HTTPS 有什么区别？</h4><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li><strong>SEO（搜索引擎优化）</strong> ：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li></ul><h3 id="dns" tabindex="-1"><a class="header-anchor" href="#dns" aria-hidden="true">#</a> DNS</h3><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。</p><p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p><p>所以域名的层级关系类似一个树状结构：</p>',47),h=e("li",null,"根 DNS 服务器（.）",-1),p=e("li",null,"顶级域 DNS 服务器（.com）",-1),P={href:"http://server.com",target:"_blank",rel:"noopener noreferrer"},T=e("p",null,"根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。",-1),g=e("p",null,"这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。",-1),A=e("p",null,"因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。",-1),u=e("h4",{id:"域名解析的工作流程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#域名解析的工作流程","aria-hidden":"true"},"#"),r(" 域名解析的工作流程：")],-1),H={href:"http://www.server.com",target:"_blank",rel:"noopener noreferrer"},f={href:"http://www.server.com",target:"_blank",rel:"noopener noreferrer"},I={href:"http://www.server.com",target:"_blank",rel:"noopener noreferrer"},_={href:"http://www.server.com",target:"_blank",rel:"noopener noreferrer"},C={href:"http://www.server.com",target:"_blank",rel:"noopener noreferrer"},S={href:"http://www.server.com",target:"_blank",rel:"noopener noreferrer"},m={href:"http://server.com",target:"_blank",rel:"noopener noreferrer"},w=e("li",null,"权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。",-1),b=e("li",null,"本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。",-1);function M(R,x){const t=a("ExternalLinkIcon");return n(),l("div",null,[c,e("ul",null,[h,p,e("li",null,[r("权威 DNS 服务器（"),e("a",P,[r("server.com"),o(t)]),r("）")])]),T,g,A,u,e("ol",null,[e("li",null,[r("客户端首先会发出一个 DNS 请求，问 "),e("a",H,[r("www.server.com"),o(t)]),r(" 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。")]),e("li",null,[r("本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 "),e("a",f,[r("www.server.com"),o(t)]),r("，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 "),e("a",I,[r("www.server.com"),o(t)]),r(" 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。")]),e("li",null,[r("根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“"),e("a",_,[r("www.server.com"),o(t)]),r(" 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”")]),e("li",null,[r("本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 "),e("a",C,[r("www.server.com"),o(t)]),r(" 的 IP 地址吗？”")]),e("li",null,[r("顶级域名服务器说：“我给你负责 "),e("a",S,[r("www.server.com"),o(t)]),r(" 区域的权威 DNS 服务器的地址，你去问它应该能问到”。")]),e("li",null,[r("本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” "),e("a",m,[r("server.com"),o(t)]),r(" 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。")]),w,b])])}const D=i(d,[["render",M],["__file","计算机网络.html.vue"]]);export{D as default};
