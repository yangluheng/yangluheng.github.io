import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c as o,a as n,e as a,d as t,f as e}from"./app-ec602bdf.js";const c={},r=e(`<h2 id="_1-项目介绍" tabindex="-1"><a class="header-anchor" href="#_1-项目介绍" aria-hidden="true">#</a> 1.项目介绍</h2><p><strong>开发技术</strong>：Spring Cloud + Spring Boot + MybatisPlus + Redis + MySQL + Mongodb + Zookeeper + kafka + ElasticSearch + Docker + 第三方技术阿里云OSS;</p><p><strong>项目背景：</strong>”来看头条“ 项目类似于今日头条，是一个新闻资讯类项目。该项目由用户端和自媒体端组成。在用户端，实现了用户通过app端登录功能、浏览文章功能、搜索文章功能、用户历史记录功能。在自媒体端，实现了自媒体管理员登录功能、发布文章功能、删除文章功能、上传素材功能、文章内容审核功能</p><p><strong>项目重难点：</strong> 网关搭建；文章详情静态化及存储；文章自动审核及延迟发布；分布式锁解决集群下的方法抢占执行；热点文章实时计算</p><p><strong>技术栈的具体应用</strong>：</p><ul><li>Spring-Cloud-Gateway : 微服务之前架设的网关服务，实现服务注册中的API请求路由，以及控制流速控制和熔断处理都是常用的架构手段，而这些功能Gateway天然支持</li><li>运用Spring Boot快速开发框架，构建项目工程；并结合Spring Cloud全家桶技术，实现app后端、自媒体等微服务。</li><li>运用Spring Cloud Alibaba Nacos作为项目中的注册中心和配置中心</li><li>运用mybatis-plus作为持久层提升开发效率</li><li>采用kafka作为消息服务中间件，把自媒体文章上下架放进消息队列；通过用户的行为（点赞、评论、喜欢）实时记录用户数据，通过kafkaStream流式计算最新的数据；与客户端系统消息通知</li><li>运用Redis缓存技术，实现热数据的计算，提升系统性能指标，同时作为消息中间件异步消费任务。</li><li>使用Mysql存储用户数据，以保证数据查询的高性能</li><li>使用Mongodb存储用户历史记录数据，以保证用户热数据高扩展和高性能指标</li><li>运用AI技术，来完成系统自动化功能，以提升效率及节省成本,比如文章审核</li></ul><h2 id="_2-优化" tabindex="-1"><a class="header-anchor" href="#_2-优化" aria-hidden="true">#</a> 2.优化</h2><h3 id="_2-1优化一" tabindex="-1"><a class="header-anchor" href="#_2-1优化一" aria-hidden="true">#</a> 2.1优化一</h3><p>**缺陷 ：**写操作（定时刷新）比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</p><p><strong>解决办法：</strong></p><ul><li>数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个分布式锁来保证更新 cache 的时候不存在线程安全问题。</li></ul><h3 id="_2-2优化二" tabindex="-1"><a class="header-anchor" href="#_2-2优化二" aria-hidden="true">#</a> 2.2优化二</h3><p>**缺陷：**消费者丢失消息的情况</p><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法</strong>:</p><ul><li>我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。 但是这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</li><li>解决Kafka重复消费，开启kafka本身存在的幂等性。<strong>acks=all</strong>和<strong>enable.idempotence=true</strong>来保证幂等性,这样 Producer 在重试发送消息时,Broker端就可以过滤重复消息。</li></ul><h3 id="_2-3优化三" tabindex="-1"><a class="header-anchor" href="#_2-3优化三" aria-hidden="true">#</a> 2.3优化三</h3><h4 id="_2-3-1存储技术选型" tabindex="-1"><a class="header-anchor" href="#_2-3-1存储技术选型" aria-hidden="true">#</a> <strong>2.3.1存储技术选型：</strong></h4><table><thead><tr><th style="text-align:center;">功能</th><th style="text-align:center;">阿里云oss</th><th style="text-align:center;">minio</th></tr></thead><tbody><tr><td style="text-align:center;">文件管理</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">文件管理权限策略</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">纠删码数据修复</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">持续备份</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">使用SDK管理资源</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">监控</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">版本控制</td><td style="text-align:center;">开启版本控制后，针对文件的覆盖和删除操作将会以历史版本的形式保存下来，在错误覆盖或者删除文件后，能够将存储空间中存储的文件恢复至任意时刻的历史版本</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">在指定时间内自动批量删除</td><td style="text-align:center;">支持生命周期规则，您可以通过生命周期规则定期将非热门数据转换为低频访问、归档存储或冷归档存储，并删除过期数据</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">提升数据上传、下载速率</td><td style="text-align:center;">支持传输加速服务</td><td style="text-align:center;">受限于服务器网卡带宽</td></tr><tr><td style="text-align:center;">高性能、高吞吐的数据访问服务</td><td style="text-align:center;">缓存OSS中的热点文件，并提供高性能、高吞吐量的数据访问服务</td><td style="text-align:center;">设置访问一个对象并下载下来进行缓存，那接下来的请求都会直接访问缓存磁盘上的对象，直至其过期失效</td></tr><tr><td style="text-align:center;">加密、保护敏感数据</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">防护DDoS攻击</td><td style="text-align:center;">当受保护的Bucket遭受大流量攻击时，OSS高防会将攻击流量牵引至高防集群进行清洗，并将正常访问流量回源到目标Bucket，确保业务的正常进行。</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">记录资源的访问信息</td><td style="text-align:center;">可以通过日志功能完成OSS的操作审计、访问统计、异常事件回溯和问题定位等工作</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">控制流量</td><td style="text-align:center;">在上传、下载、拷贝文件时进行流量控制，以保证您其他应用的网络带宽</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">对数据进行分析和处理</td><td style="text-align:center;">图片处理、视频截帧、智能媒体管理</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">使用工具管理资源</td><td style="text-align:center;">OSS支持图形化工具、命令行工具、文件挂载工具、FTP工具等方便您管理OSS资源</td><td style="text-align:center;">支持图形化工具、命令行工、各类SDK</td></tr><tr><td style="text-align:center;">同城容灾、异地容灾</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">数据合规保留</td><td style="text-align:center;">允许用户以“不可删除、不可篡改”方式保存和使用数据。</td><td style="text-align:center;">×</td></tr></tbody></table><p>阿里云OSS是一个成熟的云服务,由阿里云提供技术支持和服务保障,使用方便,与其他阿里云服务集成度高。MinIO是开源软件,需要自行部署和维护。OSS有成熟的访问权限控制,安全性好。MinIO安全性取决于自行配置。</p><h4 id="_2-3-2数据库框架选型" tabindex="-1"><a class="header-anchor" href="#_2-3-2数据库框架选型" aria-hidden="true">#</a> <strong>2.3.2数据库框架选型：</strong></h4><p>MyBatis和MyBatis-Plus都是Java语言中非常常用的ORM框架，二者有以下区别：</p><p><strong>实现方式不同：</strong></p><p>MyBatis是基于XML或注解方式进行数据库操作的持久化框架，它提供了简单的CRUD操作及动态SQL生成等功能。而MyBatis-Plus是在MyBatis框架上的封装，通过对于增强简化后的API更加方便地进行开发，并且在性能、效率和易用性上都有一定的优化。</p><p><strong>编程风格有所差异：</strong></p><p>MyBatis的编程风格更加传统，需要定义mapper.xml文件并根据传入的参数使用相应的SQL查询语句，需要实现 Mybatis 提供的各种方法；而MyBatis-Plus具有许多针对CRUD进行的简化方法，通过继承BaseMapper以及使用Lambda表达式，可以让我们像SpringDataJPA类似地使用接口编程方式进行数据库操作。</p><p>下面通过代码示例来演示一下MyBatis和MyBatis-Plus的区别：</p><ul><li>MyBatis的实现</li></ul><p>首先在Mybatis中需要配置sql mapper映射文件，如下所示：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- userMapper.xml --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.demo.dao.UserMapper<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>getUserById<span class="token punctuation">&quot;</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>java.lang.Integer<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.demo.entity.User<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        select * from t_user where id=#{id}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后通过Mybatis的SqlSession执行相关方法实现数据查询：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SqlSessionFactory</span> sessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token string">&quot;com.demo.dao.UserMapper.getUserById&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>MyBatis-Plus的实现</li></ul><p>在MyBatis-Plus中则要比上述方式简单得多，并且提供了更加方便的CRUD操作。例如我们可以定义一个接口继承BaseMapper接口并调用其中提供的方法来操作数据库，如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下是从数据库中根据ID查询数据时，可以在Service层直接调用BaseMapper中提供的selectById()方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserMapper</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> baseMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,38),d={href:"https://blog.csdn.net/qq_51447496/article/details/131166800",target:"_blank",rel:"noopener noreferrer"},u=n("h4",{id:"_2-3-3消息队列选型",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2-3-3消息队列选型","aria-hidden":"true"},"#"),a(" 2.3.3"),n("strong",null,"消息队列选型：")],-1),k={href:"https://www.youngxy.top/page/Kafka/Kafka.html",target:"_blank",rel:"noopener noreferrer"},g=e(`<p>Kafka 和 RocketMQ 都支持 10w 级别的高吞吐量。</p><p>Kafka 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是大数据领域的实时计算、日志采集等场景，用 Kafka 绝对没错，社区活跃度高，业内标准。</p><p>RocketMQ 特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ 是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。但如果阿里不再维护这个技术了，社区有可能突然黄掉的风险。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用 RocketMQ。</p><p>RabbitMQ 适用于公司对外提供能力，可能会有很多主题接入的中台业务场景，毕竟它是百万级主题数的。它的时效性是毫秒级的，但实际毫秒级和微秒级在感知上没有什么太大的区别，所以它的这一大优点并不太会作为考量标准。同时，它的功能是比较完善的，开源社区活跃度高，能解决开发中遇到的bug，所以万级别数据量业务场景的小公司可以优先选择功能完善的RabbitMQ。它的缺点就是用 Erlang 语言编写，所以很多开发人员很难去看懂源码并进行二次开发和维护，也就是说对于公司来说可能处于不可控的状态。</p><p>ActiveMQ 现在很少有人用，没怎么经过大规模吞吐量场景的考验，社区不怎么活跃，官方社区现在对 ActiveMQ 5.x 维护也越来越少，所以不推荐使用。</p><h3 id="_2-4优化四" tabindex="-1"><a class="header-anchor" href="#_2-4优化四" aria-hidden="true">#</a> 2.4优化四</h3><p>缺陷：对于变量存在多线程并发竞争</p><p><strong>解决办法：</strong></p><p>为变量设置ThreadLocal。</p><h3 id="_2-5身份验证怎么做的" tabindex="-1"><a class="header-anchor" href="#_2-5身份验证怎么做的" aria-hidden="true">#</a> 2.5身份验证怎么做的？</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>AuthorizedFilter + AppJwtUtil
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>用户向服务器发送用户名、密码以及验证码用于登陆系统。用户进入网关开始登陆，网关过滤器进行判断，如果是登录，则路由到后台管理微服务进行登录。</li><li>如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。</li><li>用户以后每次向后端发请求都在 Header 中带上这个 JWT ，再次进入网关开始访问，网关过滤器接收用户携带的TOKEN。</li><li>服务端检查 JWT 并从中获取用户相关信息。网关过滤器解析TOKEN ，判断是否有权限，如果有，则放行，如果没有则返回未认证错误。</li></ol><p>两点建议：</p><ol><li>建议将 JWT 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。</li><li>请求服务端并携带 JWT 的常见做法是将其放在 HTTP Header 的 <code>Authorization</code> 字段中（<code>Authorization: Bearer Token</code>）。</li></ol><p><strong>乐观锁：</strong></p><p>使用版本号。</p><p><strong>分布式id：</strong></p><p>随着业务的增长，文章表可能要占用很大的物理存储空间，为了解决该问题，后期使用数据库分片技术。将一个数据库进行拆分，通过数据库中间件连接。如果数据库中该表选用ID自增策略，则可能产生重复的ID，此时应该使用分布式ID生成策略来生成ID。</p><p>文章端相关的表都使用雪花算法生成id,包括ap_article、 ap_article_config、 ap_article_content</p><p>mybatis-plus已经集成了雪花算法，完成以下两步即可在项目中集成雪花算法</p><p>第一：在实体类中的id上加入如下配置，指定类型为id_worker</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">,</span>type <span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span><span class="token constant">ID_WORKER</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第二：在application.yml文件中配置数据中心id和机器id</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>
  <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token important">*:mapper/*.xml</span>
  <span class="token comment"># 设置别名包扫描路径，通过该属性可以给包中的类注册别名</span>
  <span class="token key atrule">type-aliases-package</span><span class="token punctuation">:</span> com.heima.model.article.pojos
  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>
    <span class="token key atrule">datacenter-id</span><span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token key atrule">workerId</span><span class="token punctuation">:</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-6网关搭建" tabindex="-1"><a class="header-anchor" href="#_2-6网关搭建" aria-hidden="true">#</a> 2.6网关搭建：</h3><p>思路分析：</p><ol><li>用户进入网关开始登陆，网关过滤器进行判断，如果是登录，则路由到后台管理微服务进行登录</li><li>用户登录成功，后台管理微服务签发JWT TOKEN信息返回给用户</li><li>用户再次进入网关开始访问，网关过滤器接收用户携带的TOKEN</li><li>网关过滤器解析TOKEN ，判断是否有权限，如果有，则放行，如果没有则返回未认证错误</li></ol><p>具体实现：</p><p>第一：</p><p>​ 在认证过滤器中需要用到jwt的解析，所以需要把工具类拷贝一份到网关微服务</p><p>第二：</p><p>​ 在网关微服务中新建全局过滤器</p><h3 id="_2-7文章详情静态化及存储" tabindex="-1"><a class="header-anchor" href="#_2-7文章详情静态化及存储" aria-hidden="true">#</a> 2.7文章详情静态化及存储：</h3><p><strong>文章详情静态化：</strong></p><p>​ FreeMarker 是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><p>​ 模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， 不是像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p><p><strong>存储：AliyunOSS</strong></p><p>对象存储可提供更好的数据保护，加密、保护敏感数据。</p><figure><img src="http://www.img.youngxy.top/Java/fig/image-20210602180856833.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-8文章自动审核及延迟发布" tabindex="-1"><a class="header-anchor" href="#_2-8文章自动审核及延迟发布" aria-hidden="true">#</a> 2.8文章自动审核及延迟发布：</h3><p><strong>文章自动审核：</strong></p><p>1 自媒体端发布文章后，开始审核文章（异步线程的方式审核文章，在自动审核的方法上加上@Async注解（标明要异步调用），在自媒体引导类中使用@EnableAsync注解开启异步调用）</p><p>2 审核的主要是审核文章的内容（文本内容和图片）</p><p>3 借助第三方提供的接口审核文本</p><p>4 借助第三方提供的接口审核图片，由于图片存储到OSS中，需要先下载才能审核</p><p>5 如果审核失败，则需要修改自媒体文章的状态，status:2 审核失败 status:3 转到人工审核</p><p>6 如果审核成功，则需要在文章微服务中创建app端需要的文章：</p><p>​ 在文章审核成功以后需要在app的article库中新增文章数据：</p><ul><li><p>​ 保存文章信息 ap_article</p></li><li><p>​ 保存文章配置信息 ap_article_config</p></li><li><p>​ 保存文章内容 ap_article_content</p></li></ul><figure><img src="http://www.img.youngxy.top/Java/fig/image-20210505010938575.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>延迟发布：</strong></p><p>redis实现：zset数据类型的去重有序（分数排序）特点进行延迟。例如：时间戳作为score进行排序</p><p>实现思路：</p><figure><img src="http://www.img.youngxy.top/Java/fig/image-20210513150440342.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>问题思路：</strong></p><p><strong>1.为什么任务需要存储在数据库中？</strong></p><p>延迟任务是一个通用的服务，任何需要延迟得任务都可以调用该服务，需要考虑数据持久化的问题，存储数据库中是一种数据安全的考虑。</p><p><strong>2.为什么redis中使用两种数据类型，list和zset？</strong></p><p>效率问题，算法的时间复杂度</p><p><strong>3.在添加zset数据的时候，为什么不需要预加载？</strong></p><p>任务模块是一个通用的模块，项目中任何需要延迟队列的地方，都可以调用这个接口，要考虑到数据量的问题，如果数据量特别大，为了防止阻塞，只需要把未来几分钟要执行的数据存入缓存即可。</p><p><strong>实现：</strong></p><ul><li>延迟队列服务提供对外接口：提供远程的feign接口</li><li>发布文章集成添加延迟队列接口</li><li>修改发布文章代码：把之前的异步调用修改为调用延迟任务</li><li>消费任务进行审核文章</li></ul><p><strong>4.为什么选用redis作为消息队列？</strong></p><p>把 Redis 当作队列来使用时，会面临的 2 个问题：</p><ul><li>Redis 本身可能会丢数据；</li><li>面对消息挤压，内存资源会紧张；</li></ul><p>所以，能不能将 Redis 作为消息队列来使用，关键看你的业务场景：</p><ul><li><p>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</p></li><li><p>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</p></li></ul><h3 id="_2-9分布式锁解决集群下的方法抢占执行" tabindex="-1"><a class="header-anchor" href="#_2-9分布式锁解决集群下的方法抢占执行" aria-hidden="true">#</a> 2.9分布式锁解决集群下的方法抢占执行：</h3><p><strong>问题描述：</strong></p><p>启动两台heima-leadnews-schedule服务，每台服务都会去执行refresh定时任务方法</p><p><strong>分布式锁：</strong></p><p>控制分布式系统有序的去对共享资源进行操作，通过互斥来保证数据的一致性。</p><p><strong>解决方案：</strong></p><p>sexnx （SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。</p><p>这种加锁的思路是，如果 key 不存在则为 key 设置 value，如果 key 已存在则 SETNX 命令不做任何操作</p><ul><li>客户端A请求服务器设置key的值，如果设置成功就表示加锁成功</li><li>客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败</li><li>客户端A执行代码完成，删除锁</li><li>客户端B在等待一段时间后再去请求设置key的值，设置成功</li><li>客户端B执行代码完成，删除锁</li></ul><h3 id="_2-10热点文章实时计算" tabindex="-1"><a class="header-anchor" href="#_2-10热点文章实时计算" aria-hidden="true">#</a> 2.10热点文章实时计算：</h3><figure><img src="http://www.img.youngxy.top/Java/fig/image-20210730201509223.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>思路说明：</p><figure><img src="http://www.img.youngxy.top/Java/fig/image-20210621235620854.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-11服务降级处理" tabindex="-1"><a class="header-anchor" href="#_2-11服务降级处理" aria-hidden="true">#</a> 2.11服务降级处理</h3><p>​</p><ul><li><p>服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃</p></li><li><p>服务降级虽然会导致请求失败，但是不会导致阻塞。</p></li></ul><p><strong>实现步骤：</strong></p><p>①：在heima-leadnews-feign-api编写降级逻辑</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * feign失败配置
 */</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IArticleClientFallback</span> <span class="token keyword">implements</span> <span class="token class-name">IArticleClient</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseResult</span> <span class="token function">saveArticle</span><span class="token punctuation">(</span><span class="token class-name">ArticleDto</span> dto<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ResponseResult</span><span class="token punctuation">.</span><span class="token function">errorResult</span><span class="token punctuation">(</span><span class="token class-name">AppHttpCodeEnum</span><span class="token punctuation">.</span><span class="token constant">SERVER_ERROR</span><span class="token punctuation">,</span><span class="token string">&quot;获取数据失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在自媒体微服务中添加类，扫描降级代码类的包</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span><span class="token string">&quot;com.heima.apis.article.fallback&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitConfig</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②：远程接口中指向降级代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;leadnews-article&quot;</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> <span class="token class-name">IArticleClientFallback</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IArticleClient</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/api/v1/article/save&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ResponseResult</span> <span class="token function">saveArticle</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">ArticleDto</span> dto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>③：客户端开启降级heima-leadnews-wemedia</p><p>在wemedia的nacos配置中心里添加如下内容，开启服务降级，也可以指定服务响应的超时的时间</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token comment"># 开启feign对hystrix熔断降级的支持</span>
  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token comment"># 修改调用超时时间</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">config</span><span class="token punctuation">:</span>
      <span class="token key atrule">default</span><span class="token punctuation">:</span>
        <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">2000</span>
        <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">2000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>待优化</strong>：</p><p>使用FastDFS作为静态资源存储器，在其上实现热静态资源缓存、淘汰等功能（待优化）</p><p>运用Hbase技术，存储系统中的冷数据，保证系统数据的可靠性（待优化）</p><p>运用ES搜索技术，对冷数据、文章数据建立索引，以保证冷数据、文章查询性能（待优化）</p><p>当用户 Logout 的话，JWT 也还有效。除非，我们在后端增加额外的处理逻辑比如将失效的 JWT 存储起来，后端先验证 JWT 是否有效再进行处理。</p><h2 id="_3-qps估算方法、性能测试" tabindex="-1"><a class="header-anchor" href="#_3-qps估算方法、性能测试" aria-hidden="true">#</a> 3.QPS估算方法、性能测试：</h2><p><strong>QPS（Query Per Second）：每秒请求数，就是说服务器在一秒的时间内处理了多少个请求。</strong></p><p>怎么估出每秒钟能处理多少请求呢？</p><p><strong>方式一:自己在接口里记录</strong></p><p>这种方式指的是在你的接口里，日志记录了能体现该接口特性的，并具有唯一性的字符串！</p><p>例如，下面这一段代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span> 
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/home&quot;</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IndexController</span> <span class="token punctuation">{</span>
 <span class="token comment">//省略</span>
 <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/index&quot;</span><span class="token punctuation">)</span> 
 <span class="token class-name">String</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
 logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;渣渣烟&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token string">&quot;index&quot;</span><span class="token punctuation">;</span> 
 <span class="token punctuation">}</span> 
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设现在我要统计index这个接口的QPS！</p><p>OK，什么叫能体现该接口特性的字符串呢！就像上面的&quot;渣渣烟&quot;这个字符串，只在index这个接口里出现过，没在其他其他接口里出现过！因此，只要统计出&quot;渣渣烟&quot;这个字符串在日志里的出现次数，就能知道该接口的请求次数！</p><p>什么叫具有唯一性的字符串呢！所谓唯一性，指的是&quot;渣渣烟&quot;这个字符串，在这个接口的一次调用流程中，只出现一次！如果出现两次，就会导致到时候统计出来的次数会多一倍，所以尽量选择具有唯一性的字段！</p><p><strong>方式二:利用tomcat的access log</strong></p><p>tomcat自带的access log功能：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>server.tomcat.accesslog.directory
设定log的目录，默认: logs
server.tomcat.accesslog.enabled
是否开启access log，默认: false
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，你访问一次/home/index地址，会有下面这样日志：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>127.0.0.1 - - [xxx] &quot;POST /home/index HTTP/1.1&quot; 200 138
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行一串命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> xx.log <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">&#39;GET /mvc2&#39;</span><span class="token operator">|</span><span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">&#39; &#39;</span> -f4<span class="token operator">|</span><span class="token function">uniq</span> -c<span class="token operator">|</span><span class="token function">sort</span> <span class="token parameter variable">-n</span> <span class="token parameter variable">-r</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>JMeter测试：</strong></p><figure><img src="http://www.img.youngxy.top/Java/fig/项目测试.PNG" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="自我介绍" tabindex="-1"><a class="header-anchor" href="#自我介绍" aria-hidden="true">#</a> <strong>自我介绍：</strong></h2><p>面试官，您好，首先很感谢您给我的面试机会！我叫杨路恒，今年24岁，山东济宁人，就读于陕西师范大学，今年研二，软件工程专业，研究方向为知识图谱。大学时间我主要利用课外时间学习了 Java 以及 一些框架 。在校期间参与了全国大学生数学建模竞赛和全国大学生英语竞赛，并且在数学建模比赛中担任队长并获得了陕西省一等奖。说到业余爱好的话，一个是比较喜欢通过博客整理分享自己所学知识，现在在CSDN上的粉丝数达到了3k+，访问量达到了44W+。 另一个是喜欢旅游和骑行的方式来放松。这就是我的自我介绍，感谢。</p>`,120);function v(m,b){const s=l("ExternalLinkIcon");return i(),o("div",null,[r,n("p",null,[a("参考："),n("a",d,[a("https://blog.csdn.net/qq_51447496/article/details/131166800"),t(s)])]),u,n("p",null,[a("详细请参考："),n("a",k,[a("https://www.youngxy.top/page/Kafka/Kafka.html"),t(s)])]),g])}const x=p(c,[["render",v],["__file","来看头条.html.vue"]]);export{x as default};
