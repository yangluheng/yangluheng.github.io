import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o,c as p,a as e,e as a,d as n,f as t}from"./app-6de35cd4.js";const r={},g=t(`<p>在并发编程中我们都知道<code>i++</code>操作是非线程安全的，这是因为 <code>i++</code>操作不是原子操作。</p><p>如何保证原子性呢？常用的方法就是<code>加锁</code>。在Java语言中可以使用 <code>Synchronized</code>和<code>CAS</code>实现加锁效果。</p><p><code>Synchronized</code>是悲观锁，线程开始执行第一步就是获取锁，一旦获得锁，其他的线程进入后就会阻塞等待锁。如果不好理解，举个生活中的例子：一个人进入厕所后首先把门锁上（获取锁），然后开始上厕所，这个时候有其他人来了只能在外面等（阻塞），就算再急也没用。上完厕所完事后把门打开（解锁），其他人就可以进入了。</p><p><code>CAS</code>是乐观锁，线程执行的时候不会加锁，假设没有冲突去完成某项操作，如果因为冲突失败了就重试，最后直到成功为止。</p><h2 id="_1-什么是-cas" tabindex="-1"><a class="header-anchor" href="#_1-什么是-cas" aria-hidden="true">#</a> 1.什么是 CAS？</h2><p>CAS（Compare-And-Swap）是<code>比较并交换</code>的意思，它是一条 CPU 并发原语，用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是<code>原子</code>的。下面用一个小示例解释一下。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，计算后要修改后的新值B。</p><p>（1）初始状态：在内存地址V中存储着变量值为 1。</p><figure><img src="http://www.img.youngxy.top/Java/fig/CAS1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（2）线程1想要把内存地址为 V 的变量值增加1。这个时候对线程1来说，旧的预期值A=1，要修改的新值B=2。</p><figure><img src="http://www.img.youngxy.top/Java/fig/CAS2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）在线程1要提交更新之前，线程2捷足先登了，已经把内存地址V中的变量值率先更新成了2。</p><figure><img src="http://www.img.youngxy.top/Java/fig/CAS3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（4）线程1开始提交更新，首先将预期值A和内存地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p><figure><img src="http://www.img.youngxy.top/Java/fig/CAS4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（5）线程1重新获取内存地址 V 的当前值，并重新计算想要修改的新值。此时对线程1来说，A=2，B=3。这个重新尝试的过程被称为<code>自旋</code>。如果多次失败会有多次自旋。</p><figure><img src="http://www.img.youngxy.top/Java/fig/CAS5.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（6）线程 1 再次提交更新，这一次没有其他线程改变地址 V 的值。线程1进行Compare，发现预期值 A 和内存地址 V的实际值是相等的，进行 Swap 操作，将内存地址 V 的实际值修改为 B。</p><figure><img src="http://www.img.youngxy.top/Java/fig/CAS6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>总结：更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 中的实际值相同时，才会将内存地址 V 对应的值修改为 B，这整个操作就是<code>CAS</code>。</p><h2 id="_2-cas-基本原理" tabindex="-1"><a class="header-anchor" href="#_2-cas-基本原理" aria-hidden="true">#</a> 2.CAS 基本原理</h2><p>CAS 主要包括两个操作：<code>Compare</code>和<code>Swap</code>，有人可能要问了：两个操作能保证是原子性吗？可以的。</p><p>CAS 是一种<code>系统原语</code>，原语属于操作系统用语，原语由若干指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，由操作系统硬件来保证。在 Intel 的 CPU 中，使用 cmpxchg 指令。</p><p>回到 Java 语言，JDK 是在 1.5 版本后才引入 CAS 操作，在<code>sun.misc.Unsafe</code>这个类中定义了 CAS 相关的方法。</p><p>在 Java 编程中我们通常不会直接使用到 CAS，都是通过 JDK 封装好的并发工具类来间接使用的，这些并发工具类都在<code>java.util.concurrent</code>包中。</p><h2 id="_3-cas-的问题" tabindex="-1"><a class="header-anchor" href="#_3-cas-的问题" aria-hidden="true">#</a> 3.CAS 的问题</h2><p>CAS 不是万能的，也有很多问题。</p><p><code>敲黑板：CAS有哪些问题，这是面试高频考点，需要重点掌握</code>。</p><h3 id="_3-1典型-aba-问题" tabindex="-1"><a class="header-anchor" href="#_3-1典型-aba-问题" aria-hidden="true">#</a> 3.1典型 ABA 问题</h3><p>ABA 是 CAS 操作的一个经典问题，假设有一个变量初始值为 A，修改为 B，然后又修改为 A，这个变量实际被修改过了，但是 CAS 操作可能无法感知到。</p><p>如果是整型还好，不会影响最终结果，但如果是对象的引用类型包含了多个变量，引用没有变实际上包含的变量已经被修改，这就会造成大问题。</p><p>如何解决？思路其实很简单，在变量前加版本号，每次变量更新了就把版本号加一，结果如下：</p><figure><img src="http://www.img.youngxy.top/Java/fig/ABA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最终结果都是 A 但是版本号改变了。</p><p>从 JDK 1.5 开始提供了<code>AtomicStampedReference</code>类，这个类的 <code>compareAndSe</code>方法首先检查<code>当前引用</code>是否等于<code>预期引用</code>，并且<code>当前标志</code>是否等于<code>预期标志</code>，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>​</p><h3 id="_3-2自旋开销问题" tabindex="-1"><a class="header-anchor" href="#_3-2自旋开销问题" aria-hidden="true">#</a> 3.2自旋开销问题</h3><p>CAS 出现冲突后就会开始<code>自旋</code>操作，如果资源竞争非常激烈，自旋长时间不能成功就会给 CPU 带来非常大的开销。</p><p>解决方案：可以考虑限制自旋的次数，避免过度消耗 CPU；另外还可以考虑延迟执行。</p><h3 id="_3-3只能保证单个变量的原子性" tabindex="-1"><a class="header-anchor" href="#_3-3只能保证单个变量的原子性" aria-hidden="true">#</a> 3.3只能保证单个变量的原子性</h3><p>当对一个共享变量执行操作时，可以使用 CAS 来保证原子性，但是如果要对多个共享变量进行操作时，CAS 是无法保证原子性的，比如需要将 i 和 j 同时加 1：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>i++；j++；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个时候可以使用 synchronized 进行加锁，有没有其他办法呢？有，将多个变量操作合成一个变量操作。从 JDK1.5 开始提供了<code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="_3-4总结" tabindex="-1"><a class="header-anchor" href="#_3-4总结" aria-hidden="true">#</a> 3.4总结</h3><p>CAS 是 Compare And Swap，是一条 CPU 原语，由操作系统保证原子性。</p><p>Java语言从 JDK1.5 版本开始引入 CAS ， 并且是 Java 并发编程J.U.C 包的基石，应用非常广泛。</p><p>当然 CAS 也不是万能的，也有很多问题：典型 ABA 问题、自旋开销问题、只能保证单个变量的原子性。</p>`,47),f={href:"https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247510278&idx=3&sn=a58a9ec9f805d0e109c4b09cd497c9ca&chksm=fbb120f8ccc6a9eecd9a0cc3aff335b12c88b3e9fa041008c1d970fe5f0bf564ca94e37946c1&scene=27",target:"_blank",rel:"noopener noreferrer"};function s(h,A){const c=d("ExternalLinkIcon");return o(),p("div",null,[g,e("p",null,[a("参考："),e("a",f,[a("https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247510278&idx=3&sn=a58a9ec9f805d0e109c4b09cd497c9ca&chksm=fbb120f8ccc6a9eecd9a0cc3aff335b12c88b3e9fa041008c1d970fe5f0bf564ca94e37946c1&scene=27"),n(c)])])])}const C=i(r,[["render",s],["__file","CAS.html.vue"]]);export{C as default};
